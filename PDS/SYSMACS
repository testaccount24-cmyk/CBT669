         MACRO
.*
.* Convert value in register to decimal string
.*
.* Syntax
.*   $CVD addr,REG=reg,LEN=len
.*   $CVD reg,addrÝ,len¨
.*        addr must be a address or a register (r)
.*
         $CVD  &REG=,&LEN=
         lclc  &dest,&ln,&r,&t
         lcla  &n
.*
&ln      setc  '&len'
         aif   (n'&syslist ge 2).parm2
&r       setc  '&reg'
&dest    setc  '&syslist(1)'
         ago   .parmend
.parm2   anop
&r       setc  '&syslist(1)'
&dest    setc  '&syslist(2)'
         aif   (k'&len gt 0).parmend
&ln      setc  '&syslist(3)'
.parmend anop
.* t'dest = C if address, U if register (r)
.*
         aif   (k'&r eq 0).regmiss
         aif   (k'&ln gt 0).lnn
&ln      setc  '4'
.lnn     anop
         cvd   &r,56(r13)
         aif   ('&dest'(1,1) eq '(').destr
         unpk  &dest.(&ln),56(8,r13)
         oi    &dest+&ln-1,x'f0'
         mexit
.destr   anop
&n       seta  k'&dest-2
&dest    setc  '&dest'(2,&n)
         unpk  0(&ln,&dest),56(8,r13)
         oi    &ln-1(&dest),x'f0'
         mexit
.regmiss mnote  8,'*** error - missing register spec'
         mexit
         MEND
         Macro
.*-
.* $LA - build LA instruction (inner macro)
.*
.* Returns length in a global variable, length either defined by the
.* 2rd operand, or computed from the 2nd operand.
.* Syntax:
.*   $la  r1,label      -> la    r1,label
.*   $la  r1,,label     -> la    r1,label
.*   $la  r1,number     -> lgfi  r1,nnn
.*   $la  r1,4(,r3)     -> la    r1,4(,r3)                -> length=0
.*   $la  r1,(r2)       -> lr    r1,r2                    -> length=0
.*   $la  r1,'kilroy'   -> la    r1,=c'kilroy'
.*   $la  r1,0          -> slr   r1,r1                    -> length=0
.*   $la  r1,x.label    -> lx    r1,label  (x: B, F or H) -> length=0
.* The length is returned in global variable $lalen, the type in
.* global variable $latype.
.*
.* updates
.* 2017-14-03  numeric value now different from label
.* 2018-06-16  2rd operand is now alternate src, not global length
.* 2019-01-11  change global $LALENC
.*-
&mlbl    $la   &reg,&psrc,&pasrc,&pasrc2,&glen=,&src2=
         lcla  &n,&l
         lclc  &s,&c,&r,&srct,&srcl,&src
         gbla  &$lalen
         gblc  &$lalenc
         gblc  &$latype
&$lalen  seta  0
&$lalenc setc ''
.* select source
         aif   (k'&psrc   gt 0).setsrc1
         aif   (k'&pasrc  gt 0).setsrc2
         aif   (k'&pasrc2 gt 0).setsrc3
         aif   (k'&src2   gt 0).setsrc4
         mnote  8,'** $LA mising source'
.setsrc1 anop
&src     setc  '&psrc'
         ago   .setsrcn
.setsrc2 anop
&src     setc  '&pasrc'
         ago   .setsrcn
.setsrc3 anop
&src     setc  '&pasrc2'
         ago   .setsrcn
.setsrc4 anop
&src     setc  '&src2'
.setsrcn anop
.*
&s       setc  Upper('&src')
         aif   ('&s   '(1,3) eq 'L''''').litlen
&srct    setc  t'&src
&srcl    setc  Lower('&src')
.* mnote *,'type &srct'
.*-
.* what kind of 1st operand do we have?
.*-
         aif   (k'&src gt 0).cp1
         mnote 8,'src operand missing'
         mexit
.cp1     aif   ('&src '(2,1) eq '.').load
         aif   ('&src' eq '0').clr          clear register
         aif   ('&src'(1,1) eq '(').reg     register
         aif   ('&src'(1,1) eq '''').txt    text
         aif   ('&srct' eq 'N').num        number
         ago   .lbl
.*- src is 0, means clear reg
.clr     anop  ,
&$latype setc  'CLR'
&mlbl    slr   &reg,&reg
         mexit
.*- src is a number
.num     anop  ,
&$latype setc  'NUM'
&mlbl    lgfi  &reg,&src
&$lalen  seta  &src
         mexit
.*- src is a label or address
.lbl     anop  ,                           label
&$latype setc  'LBL'
&mlbl    la    &reg,&src
&$lalenc setc  'l''&src'
&c       setc  t'&src
         aif   ('&c' ne 'A').setl0
&n       seta  l'&src
&$lalen  seta  &n
         mexit
.*- src is a register
.reg     anop  ,                           register
&$latype setc  'REG'
&n       seta  (k'&src)-2
&s       setc  '&src'(2,&n)
&mlbl    lr    &reg,&s
&$lalen  seta  1                            default
         mexit
.*- src is text
.txt     anop  ,
&$latype setc  'TXT'
&s       setc  '=c&src'
&mlbl    la    &reg,&s
&n       seta  (k'&src)-2
&$lalen  seta  &n
&$lalenc setc  '&n'
         mexit
.*- load from storage
.load    anop  ,
.* mnote *,'load'
&c       setc  Upper('&srcl'(1,1))
&n       seta  (k'&src)-2
&s       setc  '&src'(3,&n)
&$latype setc  'LFS'
&$lalen  seta  0
         aif   ('&c' eq 'F' or '&c' eq 'A').loadf
         aif   ('&c' eq 'H').loadh
         aif   ('&c' eq 'B').loadb
         mnote 8,*** invalid load parm &c'
         mexit
.loadf   anop  ,
&mlbl    l     &reg,&s                     load from fullword
         mexit
.loadh   anop  ,
&mlbl    lh    &reg,&s                     load from halfword
         mexit
.loadb   anop  ,
&mlbl    sr    &reg,&reg
         ic    &reg,&s                     load from byte
         mexit
*-
.litlen  anop
&n       seta  (k'&src)-4
&$lalen  seta  &n
         la    &reg,&n                     length of literal
         mexit
*-
.setl0   anop
&$lalen  seta  0
.x       Mend
         MACRO
.*-
.* Locate various control blocks and info
.*
.* Latest updates
.*  2024-09-03  Update DDNAME to use the DEVTYPE macro with XTIOT=YES
.*              New DEVTYPE call
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*-
&LBL     $LOCATE &QCB,&TYPE,&REG=R15,&USING=NO,&DCB=,&NAME=,           +
               &DDNAME=,&ERROR=,&PRINT=,&ECB=,&TIOTA=,                 +
               &DSECTS=,&TCB=TCB
.*--
         LCLA  &N,&M
         LCLC  &A,&L,&LL,&C,&O,&CB,&USNG
         gblc  &$locatea
&CB      SETC  UPPER('&QCB')
&USNG    SETC  UPPER('&USING')
&L       SETC  'Z'.'&SYSNDX'
.*--
         AIF   (K'&PRINT EQ 0).PRINTIN
         PUSH  PRINT
         PRINT &PRINT
.PRINTIN ANOP
         AIF   (K'&LBL EQ 0).LBL099
&LBL     CNOP  0,4
.LBL099  ANOP
.*--
         AIF   ('&CB' EQ 'TCB').TCB
         AIF   ('&CB' EQ 'JSTCB').JSTCB
         AIF   ('&CB' EQ 'JSCB').JSCB
         AIF   ('&CB' EQ 'JCT').JCT
         AIF   ('&CB' EQ 'ASCB').ASCB
         AIF   ('&CB' EQ 'TIOT').TIOT
         AIF   ('&CB' EQ 'JOBNAME' OR '&CB' EQ 'JBN').JBN
         AIF   ('&CB' EQ 'DDENTRY').DDENT
         AIF   ('&CB' EQ 'DEVTYPE').devtype
         AIF   ('&CB' EQ 'DDNAME' OR '&CB' EQ 'DD'                     +
               or '&CB' EQ 'DD' OR K'&DDNAME GT 0).DDNAME
         AIF   ('&CB' EQ 'SUBSYS').SSYS
         AIF   ('&CB' EQ 'JESCOMCHAR').JCOM
         AIF   ('&CB' EQ 'SMFID').SMFID
         AIF   ('&CB' EQ 'PGMNAME').PGMN
         AIF   ('&CB' EQ 'PGM').PGMN
         AIF   ('&CB' EQ 'ECT').ECT
         MNOTE 8,'*** ERROR - INVALID BLOCK - &CB'
         MEXIT
.*--
.* TCB - REQUIRED MAPPING MACRO: IKJTCB
.TCB     ANOP
         L     &REG,16(0,0)            -> CVT
         L     &REG,0(,&REG)           -> TCBWORDS
         L     &REG,4(,&REG)           -> CURRENT TCB
         AIF   ('&USING' NE 'YES').MEXIT
         USING TCB,&REG
         AGO   .MEXIT
.*--
.* JSTCB - REQUIRED MAPPING MACRO: IKJTCB
.JSTCB   ANOP
         $LOCATE TCB,REG=&REG
         L     &REG,TCBJSTCB-TCB(,&REG)  -> JOBSTEP TCB
         AIF   ('&USING' NE 'YES').MEXIT
         USING TCB,&REG
         AGO   .MEXIT
.*--
.* JSCB - REQUIRED MAPPING MACRO: IEZJSCB
.JSCB    ANOP
         $LOCATE JSTCB,REG=&REG
         L     &REG,TCBJSCB-TCB(,&REG)   -> JSCB
         AIF   ('&USING' NE 'YES').MEXIT
         USING IEZJSCBG,&REG
         AGO   .MEXIT
.*--
.* JCT  - REQUIRED MAPPING MACRO: IEFAJCTB
.JCT     ANOP
         $LOCATE JSCB,REG=&REG
         ICM   &REG,7,JSCBJCTA-IEZJSCB(&REG) -> JCT
         SLL   &REG,4                    CLEAR
         SRL   &REG,4                      HI-ORDER BYTE
         LA    &REG,16(,&REG)            FOUND BY TESTING
         AIF   ('&USING' NE 'YES').MEXIT
         USING INJMJCT,&REG
         AGO   .MEXIT
.*--
.* ASCB - REQUIRED MAPPING MACRO: IHAASCB
.ASCB    ANOP
         L     &REG,16                 -> CVT
         L     &REG,0(,&REG)           -> TCBWORDS
         L     &REG,12(,&REG)          -> CURRENT ASCB
         AIF   ('&USING' NE 'YES').MEXIT
         USING ASCB,&REG
         AGO   .MEXIT
.*--
.TIOT    ANOP
.JBN     ANOP
         $LOCATE TCB,USING=NO,REG=&REG
         L     &REG,12(,&REG)          -> TIOT
         AIF   (K'&TIOTA EQ 0).TIOTAN
         ST    &REG,&TIOTA             SAVE ADDRESS
.TIOTAN  ANOP
         AIF   ('&CB' NE 'JOBNAME' AND '&CB' NE 'JBN').MEXIT
         MNOTE *,'* &REG -> DC CL8''JOBNAME'' '
         AGO   .MEXIT
.*--
.* ECT  - REQUIRED MAPPING MACROS:
.*       IHAPSA,IKJTCB,IEZJSCB,IKJPSCB,IKJRLGB,IKJECT
.ECT     ANOP
         L     &reg,PSATOLD-PSA     -> TCB
         L     &reg,TCBJSCB-TCB(,&reg) -> JSCB
         L     &reg,JSCBPSCB-IEZJSCB(,&reg) -> PSCB
         L     &reg,PSCBRLGB-PSCB(,&reg) -> RELOGON BUFFER
         L     &reg,RLGBECT-RLGB(,&reg) -> ECT
         AIF   ('&USING' EQ 'NO').MEXIT
         USING ECT,&REG
         AGO   .MEXIT
.*--
.DDENT   ANOP
         $LOCATE TIOT,REG=&REG
         AH    &REG,&DCB+DCBTIOT-IHADCB  ADD OFFSET INTO TIOT
         MNOTE *,'* &REG + 4 -> DC CL8''DDNAME'' '
         AGO   .MEXIT
.*- DDNAME
.* Locate ddname using the devtype macro - really a IS-DD function.
.* &ddname = 8-byte ddname, text or address of.
.* At exit: r15 = 0 if ddname is found, otherwise 4
.*-
.DDNAME  ANOP
&LL      SETC  'LDD'.'&SYSNDX'
         j     &ll.b
&ll.p    DEVTYPE infolist=&ll.i,MF=L
&ll.l    equ   *-&ll.p
&ll.i    DEVTYPE info=DEVTYPE
&ll.b    ds    0h
         setreg r1,&ddname
         mvc   12(8,r13),0(r1)       copy ddname
         la    r1,12+8(,r13)         parm list
         mvc   12+8(&ll.l,r13),&ll.p copy to dynamic area
         xc    12+8+&ll.l(20,r13),12+8+&ll.l(r13)
         DEVTYPE 12(,r13),(12+8+&ll.l(r13),20),xtiot=YES,              c
               mf=(E,12+8(r13))
         ltr   r15,r15                 set zero/nzero cc
&$locatea setc '12+8+&ll.l(r13)'
         AGO   .MEXIT
.*- DEVTYPE
.* Return devtype for ddname, uing the DEVTYPE macro
.* At entry: r1 -> cl8'ddname'
.* At exit:  r1 -> xl4'devtype' or 0 (r15=0 'ok' or 4 'dd not found'
.*-
.DEVTYPE ANOP
* DEVTYPE, call Locate ddname
         $LOCATE DDNAME=&ddname
* DEVTYPE, after Locate ddname
         sr    r1,r1
         jnz   *+8
         la    r1,&$locatea
         AGO   .MEXIT
.*--------------------------------------------------------------------*
.*   LOCATE SUBSYSTEM CONTROL BLOCK                                   *
.*--------------------------------------------------------------------*
.SSYS    ANOP
         AIF   ('&REG' EQ 'R1').SSYS901
.*--------------------------------------------------------------------*
.*   GENERATE DSECTS                                                  *
.*--------------------------------------------------------------------*
         GBLB  &DSCTCVT,&DSCTTCB,&DSCTJES,&DSCTSSV,&DSCTSCV
         AIF   (N'&DSECTS EQ 0).DSCT090
         PUSH  PRINT
         PRINT NOGEN
&C       SETC  '&SYSECT'
&N       SETA  0
.DSCT010 ANOP
         AIF   (&N EQ N'&DSECTS).DSCT090
&N       SETA  &N+1
&O       SETC  '&DSECTS(&N)'
         AIF   ('&O' EQ 'CVT').DSCTCVT
         AIF   ('&O' EQ 'TCB').DSCTTCB
         AIF   ('&O' EQ 'JESCT').DSCTJES
         AIF   ('&O' EQ 'SSVT').DSCTSSV
         AIF   ('&O' EQ 'SCVT').DSCTSCV
         MNOTE  8,'*** INVALID DSECTNAME - &O'
         MEXIT
.DSCTCVT AIF   (&DSCTCVT).DSCT010
&DSCTCVT SETB  1
         CVT   DSECT=YES,PREFIX=NO
         AGO   .DSCT010
.DSCTTCB AIF   (&DSCTTCB).DSCT010
&DSCTTCB SETB  1
         IKJTCB
         AGO   .DSCT010
.DSCTJES AIF   (&DSCTJES).DSCT010
&DSCTJES SETB  1
         IEFJESCT
         AGO   .DSCT010
.DSCTSCV AIF   (&DSCTSCV).DSCT010
&DSCTSCV SETB  1
         IEFJSCVT
         AGO   .DSCT010
.DSCTSSV AIF   (&DSCTSSV).DSCT010
&DSCTSSV SETB  1
         IEFJSSVT
         AGO   .DSCT010
.DSCT090 ANOP
         POP   PRINT
&C       CSECT
.*--------------------------------------------------------------------*
.*   LOCATE SUBSYSTEM VECTOR TABLE                                    *
.*--------------------------------------------------------------------*
.SSYS100 ANOP
         L     R1,16                   -> CVT
         LA    R14,255                 LOOP PROTECTION
         L     R1,CVTJESCT-CVT(R1)
         L     &REG,JESSSCT-JESCT(R1)  POINT TO SUBSYS CVT
&L.A     CLC   =CL4'&NAME',SSCTSNAM-SSCT(&REG) CHECK NAME
         BE    &L.X0
         CLC   =XL4'00',SSCTSCTA-SSCT(&REG)  END OF SUBSYS CHAIN
         BE    &L.X4
         L     &REG,SSCTSCTA-SSCT(&REG)  GET NEXT SUBSYS CVT
         BCT   R14,&L.A
&L.X4    EQU   *
         SLR   &REG,&REG               NOT FOUND
&L.X0    EQU   *
         LTR   &REG,&REG
         AGO   .MEXIT
.SSYS901 ANOP
         MNOTE 8,'*** ERROR - REGISTERS 1 AND/OR 14 ARE USED INSIDE THE+
                MACRO AND CANNOT BE USED FOR THE REG OPERAND'
         AGO   .MEXIT
.*--------------------------------------------------------------------*
.*   LOCATE JES2 COMMAND CHAR                                         *
.*--------------------------------------------------------------------*
.JCOM    ANOP
         GBLB  &$LOCDSC2
         AIF   ('&DSECTS' EQ 'NO' OR &$LOCDSC2).JCOM100
         PUSH  PRINT
         PRINT NOGEN
&C       SETC  '&SYSECT'
         CVT   DSECT=YES,PREFIX=NO
         IEFJESCT
         IEFJSCVT
*        IEFJSSVT
         $XECB
         $SCAT
         $SVT
         POP   PRINT
&C       CSECT
&$LOCDSC2 SETB 1
.JCOM100 ANOP
&C       SETC  'JES2'
         AIF   (K'&NAME EQ 0).JCOM101
&C       SETC  '&NAME'
.JCOM101 ANOP
         $LOCATE SUBSYS,NAME=&C,REG=&REG,DSECTS=NO
         BZ    &L.X                    SUBSYSTEM NOT FOUND IF ZERO
         L     &REG,SSCTSSVT-SSCT(&REG) -> SUBSYSTEM VECTOR TABLE
         LA    &REG,$SVCOMCH-SSVT(&REG) -> COMMAND CHAR
&L.X     EQU   *
.*
.*--------------------------------------------------------------------*
.*   LOCATE SMFID - REDQ DSECTS : SMCA, CVT                           *
.*--------------------------------------------------------------------*
.SMFID  ANOP
         L     &REG,16                        -> CVT
         L     &REG,CVTSMCA-CVTMAP(&REG)      -> IEESMCA
         LA    &REG,SMCASID-SMCABASE(&REG)    SMFID
         MEXIT
.*--------------------------------------------------------------------*
.*   LOCATE PROGRAM NAME IN THE CDE                                   *
.*--------------------------------------------------------------------*
.PGMN    ANOP
         $LOCATE &TCB,REG=&REG
         L     &REG,TCBRBP-TCB(&REG)          -> CURRENT RB
         LA    &REG,0(,&REG)
         L     &REG,RBCDE-RBBASIC(&REG)       -> CDE
         LA    &REG,8(,&REG)                  ->  PROGRAMNAME
         MEXIT
.*--------------------------------------------------------------------*
.MEXIT   ANOP
         AIF   (K'&PRINT EQ 0).PRINTTN
         POP   PRINT
.PRINTTN ANOP
         MEND
         Macro
.*
.* Setup module start - basereg, working storage etc.
.*
.* base=(reg1Ý,reg2Ý,reg3¨¨)      setup up to 3 baseregs
.* work=(length,label,reg,C)      acquire dynamic storage. C=clear
.* work24=(length,label,reg,C)    acquire dynamic 24-bit storage. Clear
.* sa=label | *Ýn¨ | none         save area label or inline or none
.* prolog=address                 address of prolog subroutine
.* epilog=address                 address of epilog subroutine
.* endÝ,rc=value¨                 return via epilog
.* returnÝ,rc=value¨              return via epilog
.*
.* Uses external macro SETREG
.*
.* History
.* 2018-10-27  rc value for end can be syslist(2) i.e #module end,123
.* 2018-11-26  4th parm of work/work24 can be set to 'C' => clear stg
.* 2019-02-05  use &SYSCLOCK(1,16) instead of &SYSDATE+&SYSTIME
.*             add &ver option
.* 2019-02-14  add SYSSTATE OSREL=SYSSTATE,ARCHLVL=OSREL
.* 2020-11-01  rewrite the basereg setup section
.* 2020-11-23  use LAEY to address savearea
.* 2021-07-21  honor the AMODE and RMODE parameters
.* 2022-02-15  add SP= parameter
.* 2022-03-04  change BAS to JAS
.* 2022-04-16  move #MODEND internal to #MODULE
.* 2022-06-27  change $LA to SETREG
.* 2024-12-17  ignore the storage clear option, force clear.
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*
&mlbl    #MODULE &p1,&text=,&ver=,&rc=,&csect=csect,                   c
               &base=r12,&sa=,&work=,&work24=,&sp=,                    c
               &amode=31,&rmode=ANY,                                   c
               &prolog=,&epilog=,&xprolog=,&xepilog=,&print=NOGEN
.*-
         gblb  &#module
         aif   (&#module).done1
         mnote *,'Generate #MODEND macro'
         push  print
         print off
&#module setb  1
         Macro
.* companion to #MODULE, set rc and jump to termination routine
&mlbl    #MODEND &rc=
&mlbl    #MODULE END,RC=&rc&syslist(1)
         Mend
         pop   print
.done1   anop
.*-
         gblb  &#modequ
         gbla  &iezbits
         gblc  &#modname,&#module_name,&#module_rmode,&#module_amode,  c
               &#module_sp
         lcla  &n,&m
         lclc  &s,&l,&dt
         lclc  &worksz,&workrg,&worklb,&workloc,&workclr
&l        setc  '#M&sysndx'
          aif   (k'&p1 eq 0).nop1
&s        setc  Upper('&p1')
          aif   ('&s' eq 'END' or '&s' eq 'RETURN'                     c
               or '&s' eq 'EXIT').end
          mnote 8,'*** Invalid p1'
          mexit
.nop1     anop
          aif   (k'&mlbl gt 0).lblok
          mnote 8,'*** Missing label'
          mexit
.lblok    anop
&#modname setc  '&mlbl'
&#module_name setc  '&mlbl'
&#module_sp   setc  '&sp'
&worksz   setc  '&work(1)&work24(1)'
&worklb   setc  '&work(2)&work24(2)'
&workrg   setc  '&work(3)&work24(3)'
&workclr  setc  Upper('&work(4)&work24(4)')
.*-
.* Equate regs and bits
.*-
         push  print
         print &print
&n       seta  0
         aif   (&#modequ).equregn  bits allready set
&#modequ setb  1
.equreg  anop
r&n      equ   &n
&n       seta  &n+1
         aif   (&n le 16).equreg
.equregn anop
         aif   (&iezbits ne 0).equbitn  bits allready set
         IEZBITS
.equbitn anop
*-
* Module start
*-
.*       SYSSTATE OSREL=SYSSTATE,ARCHLVL=OSREL
*-
&mlbl    Amode &amode
&#module_amode setc '&amode'
&mlbl    Rmode &rmode
&#module_rmode setc '&rmode'
&mlbl    &Csect
         bakr  14,0
.*-base setup
*setup base register(s)
         balr  &base(1),0
         ahi   &base(1),&mlbl-*
&n       seta  2
&s       setc  '&base(1)'
.base200 aif   (&n gt n'&base).base400
         lr    &base(&n),&base(&n-1)
         ahi   &base(&n),4096
&s       setc  '&s,&base(&n)'
&n       seta  &n+1
         ago   .base200
.base400 using &mlbl,&s
.*-base setup end
         j     &l.idn
&dt      setc  '&sysclock'(1,16)       YYYY-MM-DD HH:MM
         aif   (k'&text eq 0).id
&n       seta  k'&text
&s       setc  '&text'(2,&n-2)
&mlbl._id dc    c'&mlbl&ver &dt &s'
         ago   .idl
.id      anop
&mlbl._id dc    c'&mlbl&ver &dt'
.idl     anop
&mlbl._idl equ   *-&mlbl._id
&l.idn   ds    0a
.*-
.* get working storage
.*-
         aif   ('&worksz' eq '').workn
&workloc setc  '31'
         aif   (k'&work24 eq 0).wrklocn
&workloc setc  '24'
.wrklocn anop
         mnote *,'obtain storage,len=&worksz,loc=&workloc,sp=&sp'
         Storage OBTAIN,length=&worksz,loc=&workloc,sp=&sp,bndry=DBLWD
         aif   (k'&workrg eq 0).workn
         lr    &workrg,r1
.* clear storage
.*       aif   ('&workclr' ne 'C').clrstrn
         mnote *,'clear storage'
         lr    r0,r1                   target
         lgfi  r1,&worksz              target length
         la    r14,=al1(0)             source
         la    r15,1                   source length
         mvcl  r0,r14                  clear storage
.clrstrn anop
.*
         aif   (k'&worklb eq 0).workn
         using &worklb,&workrg
.workn   anop
.*-
.* setup save area
.*-
         aif   (k'&sa eq 0).saven
*setup save area
         aif   ('&sa '(1,1) eq '*').saveint
         laey  r13,&sa
         ago  .saven
.saveint cnop  0,4
&s       setc  '1'
&n       seta  k'&sa
         aif   (&n eq 1).savein2
&s       setc  '&sa'(2,&n-1)
.savein2 jas   r13,*+(&s*72)+4         address internal save area
         ds    (&s*18)a                internal save area
.saven   anop
.*-
.* setup prolog
.*-
         aif   (k'&prolog ne 0).prologl
         aif   (k'&xprolog ne 0).prologv
         ago   .prologn
.prologl larl  r15,&prolog             prolog address
         ago   .prologc
.prologv l     r15,=v(&xprolog)        prolog address
.prologc basr  r14,r15                 call prolog
.prologn anop
         j     &l.X
.*-
.* setup termination
.*-
* module termination
&mlbl._X cnop  0,4
.*-
.* setup epilog
.*-
         aif   (k'&epilog eq 0 and k'&xepilog eq 0).epilogn
         lr    r2,r15                  copy rc
         aif   (k'&epilog ne 0).epilogl
         aif   (k'&epilog ne 0).epilogl
         aif   (k'&xepilog ne 0).epilogv
         ago   .epilogn
.epilogl larl  r15,&epilog             epilog address
         ago   .epilogc
.epilogv l     r15,=v(&xepilog)        epilog address
.epilogc basr  r14,r15                 call epilog
.epilogn anop
         aif   ('&worksz' eq '').xworkn
         mnote *,'release storage,length=&worksz,addr=&workrg'
         lr    r2,r15
         Storage RELEASE,length=&worksz,addr=(&workrg),                c
               sp=&#module_sp
         lr    r15,r2
.xworkn  pr    ,
* end of termination
&l.X     ereg  0,1                     reload regs 0 and 1
*-
* End of module start
*-
         pop   print
         Mexit
.*-
.* return
.*-
.end     anop
.exit    anop
&s       setc  '&syslist(2)'
&mlbl    SetReg r15,&rc,&s,0
         j     &#modname._X
         Mend
         Macro
.*-
.* Subroutine infrastructure
.*
.* Syntax
.*   label #SUBR    action,parameters
.*   label #SUBREND ÝRC=n¨
.*
.*   Action description
.*     CSECT  ÝBASE=¨ ÝPROLOG= | XPROLOG=¨ ÝEPILOG= | XEPILOG=¨
.*           Generates a CSECT and basereg(s). Target for CALL.
.*     LABEL  ÝPROLOG= | XPROLOG=¨ ÝEPILOG= | XEPILOG=¨
.*           Generates an ENTRY statement. Target for CALL.
.*     LBL    ÝPROLOG= | XPROLOG=¨ ÝEPILOG= | XEPILOG=¨
.*           Generates a label. Target for JUMP.
.*     EXIT | END Ý,RC=n¨     Subroutine return
.*     DROP                   Drop registers, do ltorg
.*     CALL,name Ý,PARM=(parm),PL=label¨
.*           Calls a CSECT or LABEL subroutine.
.*     JUMP,name,ÝPARM=(parm),PL=label¨
.*           Calls a LBL subroutine.
.*     SET                    Set defaults for action, base, sa, saend,
.*                            using and rcfield. Using must be two
.*                            operands, i.e. USING=(MainMod,r12).
.*     EREG                   Restore regs 0 and 1
.*
.* Parameter description
.*
.*   BASE          Generates base register(s). Default is 12.
.*   PROLOG        Jumps to named routine immediately after entry.
.*   XPROLOG       Calls named routine immediately after entry.
.*   EPILOG        Jumps to named routine immediately before exit.
.*   XEPILOG       Calls named routine immediately before exit.
.*   USING         Used with the SET command to have a generated USING
.*                 for CSECT invocations. Syntax is USING=(name,reg).
.*
.* Notes
.* - For each CSECT there must be a DROP later
.* - Some defaults can be changed by the #SUBR SET invocation:
.*     base sa saend rcfield entry
.* - CALL and JUMP branches using R14, so not using r15.
.* - Uses external macros SETREG and WSAOPLST.
.*
.* History..
.* 2018-10-27  Rc value for end can be syslist(2) i.e #subr end,123
.* 2018-10-30  Add DROP
.* 2019-10-02  Restructure the handling of multiple base regs
.*             Add PUSH using and POP USING, making DROP neccessary.
.* 2020-11-01  rewrite the basereg setup section
.* 2020-11-17  reload r15 after sanum check
.* 2020-11-23  use LAEY to address save area and savearea end
.* 2021-08-26  Call using r14, fix missing mexit in .call
.* 2021-10-04  Add PARM and PL to CALL.
.* 2022-03-04  change BAS to JAS
.* 2022-04-16  New cmds JUMP and LBL.
.*             Include previous external macro #SUBREND.
.* 2024-06-22  New cmd CHAINSA
.* 2024-07-14  New parameter USING=
.*
.* Sample
.*
.*           #subr jump,lcl1
.*           #subr call,sub1
.*           #subr call,sub1,parm=(dsn1,l'dsn1),pl=subpl
.*           . . .
.*  sub1     #subr csect,sa=sa2,xprolog=sub1pro,xepilog=sub1epi
.*           . . .
.*           open  (dcb1,(OUTPUT))
.*           . . .
.*           #subr end,rc=1
.*           . . .
.*           #subr end,rc=2
.*           . . .
.*  lcl1     #subr lbl
.*           #subr end
.*           #subr drop
.*           . . .
.*  sub1pro  #subr csect,base=r6,sa=sa3
.*           . . .
.*           #subr exit
.*           #subr drop
.*           . . .
.*  sub1epi  #subr csect,base=r6,sa=sa3
.*           close dcb1
.*           #subr exit
.*           #subr drop
.*           . . .
.*  sub2     #subr csect,base=r6,sa=sa4
.*           . . .
.*           #subr exit
.*           #subr drop
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : https://harders-jensen.com/
.*-
&mname   #SUBR &p1,&print=,&base=,                                     c
               &sa=,&saend=,&drop=,&using=,                            c
               &prolog=,&epilog=,&xprolog=,&xepilog=,                  c
               &rcfield=,&rc=,&entry=,&upcase=,&parm=,&pl=,&vl=
.*-
         gblb  &#subr
         aif   (&#subr).done1
         mnote *,'Generate #SUBREND macro'
         push  print
         print off
         Macro
.* companion to #SUBR, set rc and execute #SUBR termination
&mlbl    #SUBREND &rc=
&mlbl    #SUBR END,RC=&rc&syslist(1)
         Mend
&#subr   setb  1
         pop   print
.done1   anop
.*-
         gblc  &#subrname,&#subrsaend,&#subrbase(4),&#subrrcfld
         gblc  &#subrentry,&#subrsa,&gblsetp,&#subrusingn,&#subrusingr
         gblc  &#modrmod
         gblb  &subrexit
         lclc  &name,&what,&r,&s,&l,&mcsect,&msaend,&mbase(4)
         lcla  &n,&m,&o
&l       setc  'sx&sysndx'
&name    setc  (UPPER '&mname')
.*-
         GblSetP &p1,&#subrentry,LABEL,upcase=YES,no=NULL
&what    setc  '&gblsetp'
         aif   ('&what' eq 'LABEL').label
         aif   ('&what' eq 'ENTRY').csect
         aif   ('&what' eq 'CSECT').csect
         aif   ('&what' eq 'EXIT').exit
         aif   ('&what' eq 'END').exit
         aif   ('&what' eq 'CALL').call
         aif   ('&what' eq 'JUMP').jump
         aif   ('&what' eq 'LBL').lbl
         aif   ('&what' eq 'EREG').ereg
         aif   ('&what' eq 'DROP').drop
         aif   ('&what' eq 'PARM').parm
         aif   ('&what' eq 'SET').set
         aif   ('&what' eq 'CHAINSA').chainsa
         mnote  8,'**Invalid entry type'
         mexit
.*-
.* Entry label
.*-
.label   anop
         Entry &mname
.lbl     anop
&mname   ds    0d
         stm   14,12,12(r13)
         ago   .start
.*-
.* Entry csect
.*-
.csect   anop
         aif   (k'&print eq 0).csectp1n
         push  print
         print &print
.csectp1n anop
         Push  Using
&name    Amode 31
&name    Rmode any
.csect2  anop
&name    Csect
         stm   14,12,12(r13)
.* set base(s)
&r       setc  ''
         aif   (k'&base gt 0).base100
         mnote *,'Using stored basedef'
&mbase(1) setc '&#subrbase(1)'
&mbase(2) setc '&#subrbase(2)'
&mbase(3) setc '&#subrbase(3)'
&mbase(4) setc '&#subrbase(4)'
         ago   .base110
.base100 anop
&mbase(1) setc '&base(1)'
&mbase(2) setc '&base(2)'
&mbase(3) setc '&base(3)'
&mbase(4) setc '&base(4)'
.base110 balr  &mbase(1),0
         ahi   &mbase(1),&name-*
&r       setc  '&mbase(1)'
&n       seta  2
.base200 aif   (k'&mbase(&n) eq 0).base400
         lr    &mbase(&n),&mbase(&n-1)
         ahi   &mbase(&n),4096
&r       setc  '&r,&mbase(&n)'
&n       seta  &n+1
         ago   .base200
.base400 using &name,&r
.*-
         aif   (k'&#subrusingn eq 0).usingn
         using &#subrusingn,&#subrusingr gend by global using
.usingn  anop
.*-
.start   anop
&#subrname setc '&name'
         j     *+12
&name._id dc    cl8'&name'
&subrexit setb 0
.*-
.* setup save area
.*-
.sa      anop
         GblSetP &sa,&#subrsa,next,upcase=yes,no=NULL
         aif   (k'&gblsetp eq 0).san
         aif   ('&gblsetp' eq 'NEXT').sanxt
         aif   ('&gblsetp' eq '*').sainl
         laey  r14,&gblsetp
         ago   .sachn
.sanxt   anop
         la    r14,72(,r13)            -> next sa slot
.* save area check
         GblSetP &saend,&#subrsaend,no=NULL
         aif   (k'&gblsetp eq 0).saendn
         laey  r15,&gblsetp            check
         cr    r14,r15                  inside
         jl    *+10                      save
         la    r1,888                     arealist
         svc   13                      or else..
.saendn  anop
         l     r15,16(,r13)            reload r15
         ago   .sachn
.sainl   anop
         cnop  0,4
         jas   r13,*+76
         ds    18a
         ago   .sachn
.* save area chaining
.sachn   anop
         st    r14,8(,r13)             ->
         st    r13,4(,r14)             <-
         lr    r13,r14
.san     anop
.* call prolog
         aif   (k'&prolog ne 0).prologl
         aif   (k'&xprolog ne 0).prologv
         ago   .prologn
.prologl larl  r15,&prolog             prolog address
         ago   .prologc
.prologv l     r15,=v(&xprolog)        prolog address
.prologc basr  r14,r15                 call prolog
.prologn anop
.* end of start
         j     &l.N
.* setup return
&name._X equ  *
.* update rc field
         GblSetP &rcfield,&#subrrcfld,no=NULL
         aif   (k'&gblsetp eq 0).rcfldn
         c     r15,&gblsetp            if rc gt stored
         jl    *+8                      then
         st    r15,&gblsetp              replace stored
.rcfldn  anop
.* call epilog
         aif   (k'&epilog eq 0 and k'&xepilog eq 0).epilogn
         lr    r2,r15                  copy rc
         aif   (k'&xepilog ne 0).epilogv
.epilogl larl  r15,&epilog             epilog address
         ago   .epilogc
.epilogv l     r15,=v(&xepilog)        epilog address
.epilogc basr  r14,r15                 call epilog
.epilogn anop
.* unchain sa and return
         l     r13,4(,r13)             <- prev save
         l     r14,12(r13)             return addr
         lm    2,12,28(r13)
.*       br    r14
         bsm   0,r14                   return
.* continue mainline
&l.N     equ  *
         aif   (k'&print eq 0).csectp2n
         pop   print
.csectp2n anop
         Mexit
.*-
.* Exit
.*-
.Exit    anop
&s       setc  '&syslist(2)'
&name    SetReg r15,&rc,&s,0
         j     &#subrname._X
&s       setc  '&drop '(1,1)
         aif   ('&s' ne 'Y').x
         #subr drop
         Mexit
.*-
.* Call
.*-
.Call    anop
         aif   (n'&syslist gt 2).calle1
&name    setc  '&syslist(2)'
         aif   (k'&parm eq 0).call2
         aif   (k'&pl eq 0).calle2
&mname   WSAOPLST &parm,pl=&pl
.Call2   l     r14,=V(&name)
         basr  r14,r14
         ltr   r15,r15
         Mexit
.calle1  mnote 8,'**Too many positional parms'
         Mexit
.calle2  mnote 8,'**Missing PL parm'
         Mexit
.*-
.* Jump
.*-
.Jump    anop
         aif   (n'&syslist gt 2).calle1
&name    setc  '&syslist(2)'
         aif   (k'&parm eq 0).jump2
         aif   (k'&pl eq 0).calle2
&mname   WSAOPLST &parm,pl=&pl
.Jump2   larl  r14,&name
         basr  r14,r14
         ltr   r15,r15
         Mexit
.*-
.* Ereg - restore regs 0 and 1 (simulate EREG instr)
.*-
.Ereg    anop
         l     r1,4(,r13)              <- old sa
         lm    r0,r1,20(r1)            reload
         Mexit
.*-
.* Drop #subr basereg
.*-
.Drop    anop
         ltorg
         Pop   Using
         Mexit
.*-
.* Set globals
.* note - base= max 4 registers
.*-
.Set     anop
&#subrbase(1) setc '&base(1)'
&#subrbase(2) setc '&base(2)'
&#subrbase(3) setc '&base(3)'
&#subrbase(4) setc '&base(4)'
&#subrsa      setc '&sa'
&#subrsaend   setc '&saend'
&#subrrcfld   setc '&rcfield'
&#subrentry   setc '&entry'
&#subrusingn  setc '&using(1)'
&#subrusingr  setc '&using(2)'
         Mexit
.*-
.* save area chaining
.*-
.Chainsa anop
         laey  r14,&sa
         st    r14,8(,r13)             ->
         st    r13,4(,r14)             <-
         lr    r13,r14
.*-
.x       Mend
         Macro
.*
.* Bump program use count (IHACDE CDUSE) to keep program in JPAQ.
.* This will improve performance of an often loaded program
.* significantly.
.* For reentrant and optionally serially reusable programs.
.*
.* Syntax
.*
.*  label  CDEUCTZ2 ÝBASE=reg¨Ý,SER=Y¨Ý,DSECT=N¨Ý,PRINT=OFF|NOGEN¨
.*         reg       Basereg for main module. Default is determined
.*                   basereg when macro is expanded.
.*         SER=Y     Change uct for serially reusable module too.
.*         DESCT=N   Do not include DSESCTs in the macro expansion.
.*                   The DSECTs are
.*                      IKJTCB DSECT=YES
.*                      IHAPSA DSECT=YES
.*                      IHACDE
.*         PRINT=    Print option for DSECT expansions.
.*                   Default is NOGEN.
.*
.* Sample
.*
.*         YREGS
.*   A     Csect
.*         bakr  r14,r0
.*         lr    r9,r15
.*         Using A,r9
.*         CDEUCTZ2
.*
.* Performance
.*
.*  A small performance  test when CDEUCTZ2 is used in  a program run
.*  in  an REXX  exec  to scan  36  records 100  times  for a  match.
.*   The  program is  RXPATTRN  and  can be  found  at  the web  site
.*  mentioned below.
.*
.*                        EXCP   CONN    TCB
.*  CDEUCTZ2 disabled     7284      0   1.35
.*  CDEUCTZ2 enabled        90      0    .09
.*  Running from LPA        51      0    .14
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com
.*-
&ml      CDEUCTZ2 &base=*,&wto=N,&ser=N,&dsect=Y,&print=NOGEN
         lclc  &l,&s,&br
&l       setc  'CT&sysndx'
         using tcb,r14
         using cdentry,r15
&ml      l     r14,psatold-psa(0,0)    -> my tcb
         l     r14,tcbjstcb            job-step tcb
         l     r15,tcbjpq              my cde
         drop  r14                     TCB
         cli   cduse+1,1               first time through?
         jne   &l.999                  no, jump
&s       setc  Upper('&ser')
         aif   ('&s '(1,1) ne 'Y').cdattrr
         tm    cdattr,cdren+cdser      reentrant or reuseable ??
         ago   .cdattrn
.cdattrr tm    cdattr,cdren            reentrant ??
.cdattrn anop
         jz    &l.999                  no, jump
.* do basereg test
         aif   ('&base' ne '*').base2  specific base (we hope)
         j     &l.e
&l.C     c     r0,cdentpt              executed, check cde
&l.D     dc    sl2(*)                  basereg + offsett
&l.E     sr    r1,r1
         ic    r1,&l.d                 load basereg+offsett
         srl   r1,4                    leave basereg
         sll   r1,4                    for execute
         ex    r1,&l.c                 check base against cdentpt
         ago   .base3
.base2   c     &base,cdentpt           my cde?
.base3   jne   &l.999                  no, jump
.* all seems ok, do load
         load  eploc=cdname            bump my own use count
         drop  r15                     CDE
&s       setc  Upper('&wto')
         aif   ('&s' ne 'Y').wton
         wto   'use count bumped'      for debugging
.wton    anop
&l.999   equ   *
.* dsects
&s       setc  Upper('&dsect')
         aif   ('&s' ne 'Y').dsectn
*dsects
&s       setc  '&sysect'
         Push  print
         Print &print
         gblb  &$DSCT_IKJTCB,&$DSCT_IHAPSA,&$DSCT_IHACDE
         aif   (&$DSCT_ikjtcb).dsect2
         IKJTCB DSECT=YES
&$DSCT_IKJTCB setb 1
.dsect2  aif   (&$DSCT_IHAPSA).dsect3
         IHAPSA DSECT=YES
&$DSCT_IHAPSA setb 1
.dsect3  aif   (&$DSCT_IHACDE).dsect4
         IHACDE
&$DSCT_IHACDE setb 1
.dsect4  Pop  print
*dsects end
&s       Csect
.dsectn  anop
.*-
.x       Mend
         MACRO
.* Clear field
.* Syntax
.*     CLEAR A=address,L=length
.* or  CLEAR address,length
.* or  a mixture thereoff
&LBL     CLEAR &A=,&C=C' ',&L=
         LCLC  &LEN,&ADDR
&ADDR    SETC  '&A'
         AIF   (K'&A GT 0).SETL
&ADDR    SETC  '&SYSLIST(1)'
.SETL    ANOP
&LEN     SETC  '&SYSLIST(2)'
         AIF   (K'&LEN GT 0).L0900
&LEN     SETC  'L''&ADDR.-1'
         AIF   (K'&L EQ 0).L0900
&LEN     SETC  '&L-1'
.L0900   ANOP
&LBL     MVI   &ADDR,&C
         MVC   &ADDR+1(&LEN),&ADDR
         MEND
         Macro
         CONDSECT
.*-
.* Hide instructions if parm is 'Hide'. Instructions are resumed at
.* the next CONDSECT macro.
.* Parm 2 is alternate end-of-sect text, i.e. CONDSECT ,altend
.* I.e
.*          lclc  &cndsct
.* &cndsct  setc  'HIDE'
.*          CondSect &cndsct
.*  . . . conditionally suppressed section . . .
.*          CondSect ,              resume
.*
.* You can also set the global variable &$condsect to HIDE to
.* hide globally, no matter what the CONDSECT parameter is.
.* i.e.
.*           gblc  &$condsect
.* &$condsect setc 'Hide'
.*-
         lcla  &a
         lclc  &p,&s,&s1,&end
         gblc  &$condsect
&p       setc  Upper('&syslist(1)&$condsect ')
&end     setc  'CONDSECT'
         aif   (k'&syslist(2) eq 0).endn
&end     setc  Upper('&syslist(2)')
.endn    anop
         aif   ('&p '(1,1) ne 'H').x
.hide    anop
&s       AREAD
         aif   ('&s '(1,1) eq '*').hide      comment
&s       setc  Upper('&s')
&a       seta  Index('&s',' &end ')          haystack,needle
         aif   (&a eq 0).hide                not found
.x       Mend
         MACRO
.* count up or down a field of 1 byte, halfword or fullword
         Counter &field,&val,&reg=r0
         lclc  &l,&s
&l       setc  'l'
&s       setc  'st'
         aif   (l'&field eq 4).load
&l       setc  'llh'
&s       setc  'sth'
         aif   (l'&field eq 2).load
&l       setc  'llc'
&s       setc  'stc'
         aif   (l'&field eq 1).load
         mnote 8,'** bad field length'
         mexit
.load    &l    &reg,&field
         ahi   &reg,&val
         &s    &reg,&field
.x       MEND
         MACRO
&NAME    EQUATE &PRINT=
.*--------------------------------------------------------------------*
.*                                                                    *
.*   LIB : SYS2.MACLIB(EQUATE)                                        *
.*   DOC : GENERATE EQUATES FOR SYMBOLS                               *
.*   REF : CCS/CS - WJ                                                *
.*                                                                    *
.*   SYNTAX :                                                         *
.*     LABEL  EQUATE GR     => GR0 -> GR15                            *
.*     LABEL  EQUATE GR,CR  => GR0 -> GR15 AND CR0 -> CR15            *
.*     LABEL  EQUATE        => R0 -> R15 AND BIT0 -> BIT7 (DEFAULT)   *
.*     LABEL  SA/SAVEAREA   => SAR0 -> SAR15                          *
.*     LABEL  EQUATE PRINT=NOGEN => DON'T SHOW MACRO EXPANSION        *
.*                                                                    *
.*--------------------------------------------------------------------*
         LCLA  &INDX,&INCR,&HIGH
         LCLC  &P
         GBLA  &IEZBITS
         GBLB  &EQUATEREGS,&EQUATEBITS,&EQUATESA
.*
         AIF   (K'&NAME EQ 0).LBL099
&NAME    CNOP  0,4
.LBL099  ANOP
         MPRINT PUSH,&PRINT
         AIF   (N'&SYSLIST GT 0).INIT
         MNOTE *,'*** DEFAULT EQUATES REGS, BITS ASSUMED'
         EQUATE R,B                    EQUATE REGS AND BITS
         AGO    .END                   AND TERMINATE
.*
.INIT    ANOP
&INDX    SETA  1
&HIGH    SETA  15
&INCR    SETA  0                       INIT COUNTER
.*
.SETC    ANOP
&P       SETC  UPPER('&SYSLIST(&INDX)')
         AIF   ('&P' EQ 'SA' OR '&P' EQ 'SAVE').SA
         AIF   ('&P' EQ 'B' OR '&P' EQ 'BITS' ).BITS
.*
         AIF   (&EQUATEREGS NE 0).REGS99  BITS ALLREADY SET
&EQUATEREGS SETB 1
.EQU     ANOP
&P.&INCR EQU   &INCR
         AIF   (&INCR GE &HIGH).NEXT
&INCR    SETA  &INCR+1
         AGO   .EQU
.REGS99  ANOP
.*
.NEXT    ANOP
         AIF   (&INDX GE N'&SYSLIST).END
&INCR    SETA  0                       INIT COUNTER
&HIGH    SETA  15                      DEFAULT HIGH-RANGE
&INDX    SETA  &INDX+1
         AGO  .SETC
.*
.*----
.BITS    ANOP
         AIF   (&EQUATEBITS NE 0).BITS99  BITS ALLREADY SET
&EQUATEBITS SETB 1
         AIF   (&IEZBITS NE 0).BITS99  BITS ALLREADY SET
         IEZBITS
.BITS99  AGO   .NEXT
.*----
.SA      ANOP
         AIF   (&EQUATESA NE 0).SA99   ALREDY DONE?
&EQUATESA SETB 1
&P.WD1   EQU   0                       PL/1 ONLY
&P.HSA   EQU   4                       BACK CHAIN
&P.LSA   EQU   8                       FWD    -
&P.RET   EQU   12                      RETURN ADDRESS (R14)
&P.R14   EQU   SARET
&P.EPA   EQU   16                      ENTRY POINT ADDRESS (R15)
&P.R15   EQU   SAEPA
&P.R0    EQU   20                      REGISTER 0
&P.R1    EQU   24                      REGISTER 1
&P.R2    EQU   28                      REGISTER 2
&P.R3    EQU   32                      REGISTER 3
&P.R4    EQU   36                      REGISTER 4
&P.R5    EQU   40                      REGISTER 5
&P.R6    EQU   44                      REGISTER 6
&P.R7    EQU   48                      REGISTER 7
&P.R8    EQU   52                      REGISTER 8
&P.R9    EQU   56                      REGISTER 9
&P.R10   EQU   60                      REGISTER 10
&P.R11   EQU   64                      REGISTER 11
&P.R12   EQU   68                      REGISTER 12
         AGO   .NEXT
.*----
.END     ANOP
         MPRINT POP
         MEND
         Macro
.*-
.*
.* Extended ESTAE - recover system and user abends
.*
.* Syntax
.*   ESTAEXX action,ADDR=reta
.*    action  A | ACTVATE  Activate intercept, SETADDR required
.*            C | CANCEL   Stop intercept
.*            S | SET      Set retaddr
.*            DS           Data area
.*          ( R | RESET    Reset retaddr and regs to initial - future)
.*    reta    address of where to continue after intercept
.*
.*    Note, ACTIVATE, SET and RESET will save all registers, they
.*    are restored to this value when the recovery routine is
.*    invoked.
.*
.*  Sample
.*
.*             Estaexx activate,retaddr=recover
.*             . . .
.*             Estaexx set,retaddr=rcv0c1
.*             . . .
.*             dc    X'0000'
.*    rcv0c1   ds    0a                  estae re
.*             ESTAEXX cancel
.*             . . .
.*    recover  ds    0h                  estae retry routine
.*             ESTAEXX cancel
.*             . . .
.*             Estaexx ds
.*
.* History
.* 2019-10-07  Initial
.* 2019-10-13  Add field estxtext for formatted abend info
.*-
&mlbl    ESTAEXX &addr=,&retaddr=,&print=nogen,&dsect=Y
         lclc  &c,&p,&s,&l,&lbl,&csct,&addrp
&addrp   setc  '&addr&retaddr'     allow both operands
         gblb  &estaexx
&l       setc  'ZE&sysndx'
&p       setc  Upper('&syslist(1)')
         aif   ('&p' eq 'DS').ds
         aif   (&estaexx).modtn
&estaexx setb  1
         j     &l.md
         ago   .mod
.moddone anop
&l.md    cnop  0,4
.modtn   anop
&p       setc  Upper('&syslist(1)')
         aif   ('&p' eq 'A' or '&p' eq 'ACTIVATE').act
         aif   ('&p' eq 'C' or '&p' eq 'CANCEL').can
.*       aif   ('&p' eq 'R' or '&p' eq 'RESET').res
         aif   ('&p' eq 'S' or '&p' eq 'SET').set
         mnote 8,'**Invalid or missing action'
         mexit
.*- Activate
.act     anop
&mlbl    mvc   estxeye,=c'ESTX'
         mvi   estxdone,c'N'
         la    r15,&addrp
         st    r15,estxreta        current return address
         stm   r0,r15,estxregs     save all registers
.*       st    r15,estxreto        original return address
.*       stm   r0,r15,estxrego     save all registers
         l     r15,=v(zEstxmod)
         ESTAEX (r15),CT,param=estxblk,mf=(E,estxmfl)
         mexit
.*- Cancel
.can     anop
&mlbl    lt    r15,estxreta
         jz    &l.b
         ESTAEX 0
&l.b     xc    estxreta,estxreta
         mexit
.*- Set return address
.set     anop
&mlbl    la    r15,&addrp
         st    r15,estxreta        current return address
         stm   r0,r15,estxregs     save all registers
         mexit
.*- Reset return address
.res     anop
&mlbl    mvc   estxreta,estxreto   restore retry addr
         mvc   estxregs,estxrego   restore registers
         mexit
.*- Data area
.ds      anop
estxblk  ds    0a
estxeye  ds    cl4                 'ESTX'
estxdone ds    c                   prevent loop
estxmfl  ESTAEX ,MF=L              data list
estxmfll equ   *-estxmfl
estxcode ds    a
estxsys  equ   estxcode,2          system abend
estxusr  equ   estxcode+2,2        user abend
estxrsn  ds    a
estxname ds    cl8                 pgm name
estxpsw  ds    xl8                 ec mode psw
estxreta ds    a                   current return address
estxregs ds    16a                 save registers
.*txreto ds    a                   return address at activate
.*txrego ds    16a                 save registers
estxtext ds    cl16                formatted abend info
.* test model
.* ----+----1----+----2----+----3----+----4----+----5----+
.* S0C1 00CF6618    GO       078D00009E80025A
         mexit
.*- Recovery routine
.mod     anop
         ltorg
*-
*  ESTAEXX recovery routine
*-
&sect    setc  '&sysloc'
 mnote *,'ESTAEXX mod - sysloc: &sect'
         push  using
         drop  ,
zEstxmod amode 31
zEstxmod rmode any
zEstxmod Csect
         push  print
         print &print
         using zEstxmod,r15        map code page for estxe recrtn
         cfi   r0,12               sdwa exist ?
         jne   zEstxmgo            yes, go on
         wto   'no SDWA'
         sr    r15,r15             rc=0 => continue with error
         bsm   0,r14
* SDWA provided
zEstxmgo save (14,12)
         lr    r5,r15              copy estae rec rtn epa to base
         drop  r15
         using zEstxmod,r5         map code page for estxe recrtn
         lr    r3,r1               copy sdwa ptr
         using SDWA,r3             map sdwa
.*       wto   'Estx-recov'
         using estxblk,r2
         clc   =c'ESTX',estxeye
         jne   zEstxmne
         cli   estxdone,c'Y'
         je    zEstxm2t
.*       mvi   estxdone,c'Y'
* save abend and reason codes and info
         l     r15,SDWAABCC
         sll   r15,8
         srl   r15,20
         sth   r15,estxsys
         l     r15,SDWAABCC
         sll   r15,20
         srl   r15,20
         sth   r15,estxusr
         l     r1,SDWAXPAD         -> SDWAPTRS
         l     r1,0(,r1)           -> SDWARC1
         mvc   estxrsn,SDWACRC-SDWARC1(r1) copy reason code
         lt    r1,estxrsn          was there a code?
         jnz   *+10                yes
         mvc   estxrsn,SDWAGR15    else use r15
         mvc   estxname,=cl8' '
         cli   SDWANAME,x'00'
         je    *+10                not a valid name
         mvc   estxname,SDWANAME   pgm name
         mvc   estxpsw,SDWAEC1     extended mode psw
* build readable abend text
         mvi   estxtext,c' '
         mvc   estxtext+1(l'estxtext-1),estxtext
         la    r7,c'S'
         la    r14,estxsys
         icm   r1,3,estxusr            user abend?
         jz    *+12                    yes
         la    r7,c'U'
         la    r14,estxusr
         la    r15,2                   input length
         la    r1,estxtext
         bas   r9,zEstxmxd
         stc   r7,estxtext
* build readable reason code
         la    r14,estxrsn
         la    r15,4
         la    r1,estxtext+5
         bas   r9,zEstxmxd
.* * get name and psw
.*          mvc   estxtext+17(8),estxname
.*          la    r14,estxpsw
.*          la    r15,8                   input length
.*          la    r1,estxtext+26
.*          bas   r9,zEstxmxd
* recover/retry
         mvc   SDWASRSV,estxregs   restore regs 0-15
         lr    r1,r3               -> SDWA
         l     r4,estxreta
         SETRP RETADDR=(r4),       retry routine                       c
               RC=4,               request retry                       c
               REMREC=NO,          remove this intercept YES/NO        c
               FRESDWA=YES,        free the sdwa storage               c
               WKAREA=(r3),        sdwa                                c
               RECORD=YES,DUMP=NO, record error to logrec              c
               RETREGS=YES
         j     zEstxmx
* do not recover
zEstxmne wto   'eye not found'
         j     zEstxmsr
zEstxm2t wto   '2nd time around'
zEstxmsr lr    r1,r3               -> SDWA
         SETRP RC=0,               do not retry                        c
               WKAREA=(r3),        sdwa                                c
               RECORD=NO,DUMP=NO,  no recording                        c
               RETREGS=NO
zEstxmx  l     r14,12(,r13)
         sr    r15,r15             request no-retry
         return (2,12)             return from recovery rtn
         ltorg
* subroutine, convert binary to printable. return via r9
zEstxmxd ds    0h
         sr    r0,r0
.* upper nibble
         ic    r0,0(r14)               insert into workreg one byte
         srl   r0,4                    shift last four bit away
         ahi   r0,240
         cfi   r0,x'fa'                nibble gt 9?
         jl    *+8
         ahi   r0,-57                  then use C'A'-C'F'
         stc   r0,0(r1)
.* lower nibble
         ic    r0,0(r14)               insert into workreg one byte
         sll   r0,28                   leave
         srl   r0,28                     lower nibble
         ahi   r0,240
         cfi   r0,x'fa'                nibble gt 9?
         jl    *+8
         ahi   r0,-57                  then use C'A'-C'F'
         stc   r0,1(r1)
.* next
         la    r1,2(,r1)
         la    r14,1(,r14)
         bct   r15,zEstxmxd+2
         bsm   0,r9
         pop   using
.*
&s       setc  Upper('&dsect')
         aif   ('&s' ne 'Y').dsctn
         IHASDWA
.dsctn   anop
         pop   print
&sect    loctr
         ago   .moddone
.*- End
.x       Mend
         Macro
.*
.* Returns local date as yyyy-mm-dd
.* Returns local time as hh.mm.ss
.*
         EURDATE
         gblc  &eurdate,&eurtime,&eurclock
         lclc  &y,&m,&d
&y        setc  '&sysdate'(7,2)
&m        setc  '&sysdate'(1,2)
&d        setc  '&sysdate'(4,2)
&eurdate  setc  '20&y-&m-&d'
&d        setc  '&sysclock'(18,2)
&eurtime  setc  '&systime..&d'
&eurclock setc  '&eurdate &eurtime'
         Mend
         Macro
         GblSetP &no=,&upcase=,&listval=
.* Set a global variable to the first non-blank parameter
.* This is an called macro (subroutine).
.* syntax: parm1,parm2,..,parmn
.*
.* Sample:
.*         Macro
.*         TestSetP &anchor=
.*         gblc  &gblsetp
.*         lclc  &lanchr
.*         GblSetp &anchor,&anchor,*
.*         Mend
.*         TestSetP     -> &gblsetp='*'
.*         TestSetP f1  -> &gblsetp='f1'
.*
         gblc  &gblsetp
         lcla  &n
         lclc  &p,&s
&pupper  setc  Upper('&upcase')
&n       seta  1
.gblset1 anop
&gblsetp setc  '&syslist(&n)'
         aif   (k'&gblsetp ne 0).gblset2
&n       seta  &n+1
         aif   (&n le n'&syslist).gblset1
         mexit
.gblset2 anop
&s       setc  Upper('&upcase')
         aif   ('&s '(1,1) ne 'Y').gblset3
&gblsetp setc  Upper('&gblsetp')
.gblset3 anop
&s       setc  Upper('&no')
&p       setc  Upper('&gblsetp')
         aif   ('&p' ne 'NO' or '&s' ne 'NULL').gblset4
&gblsetp setc  ''
.gblset4 anop
         aif   ('&listval' ne 'y' and '&listval' ne 'Y').gblset5
         mnote *,'gblsetp value=&gblsetp'
.gblset5 anop
         mexit
.*-
.x       Mend
         MACRO
&LBL     GETPARM &AREADEF=,&MAXLEN=,&NOPARM=,&REG=R1,&CLEAR=YES,       +
               &TSO=YES,               BEWARE OF TSO CALL              +
               &PRINT=GEN
.*
.*  MOVE PARAMETER FIELD FROM THE 'EXEC' JCL STATEMENT TO AN
.*  INTERNAL AREA.
.*
.*  OPERANDS :
.*      AREADEF A-TYPE ADDRESS OF RECEIVING AREA.
.*              MAY ALSO BE SYSLIST(1).
.*      MAXLEN  MAXIMUM LENGTH OF PARAMETER. DEFAULT IS LENGTH
.*              OF RECEIVING FIELD.
.*      NOPARM  A-TYPE ADDRESS. CONTINUE HERE IF THERE ARE
.*              NO PARAMETER FIELD SPECIFIED.
.*      REG     DEFINES TO WHICH R1 HAS BEEN COPIED.
.*      CLEAR   SET RECEIVE AREA TO BALNKS BEFORE RETREIVE.
.*      PRINT   GEN/NOGEN - USED TO SUPPRESS PRINT OF MACRO
.*              EXPANSION.
.*
.*  THE MACRO USES R0 AND R15 AS WORK REGISTERS.
.*
.*  R15 CONTAINS THE PARM LENGTH AFTER COPY
.*
         LCLA  &N,&M
         LCLC  &L,&NOPA,&AL
         LCLC  &AREA
&AREA    SETC  '&AREADEF&SYSLIST(1)'
.*
&L       SETC  'Z&SYSNDX'
&NOPA    SETC  '&L.X'                  DEFAULT
         AIF   (K'&NOPARM EQ 0).ZP99
&NOPA    SETC  '&NOPARM'               ADDRESS WHEN NO PARMS
.ZP99    ANOP
&AL      SETC  'L''&AREA'
         AIF   (K'&MAXLEN EQ 0).MAXL99
&AL      SETC  '&MAXLEN'
.MAXL99  ANOP
         PUSH  PRINT
         PRINT &PRINT
*---------------------------------------------------------------------*
*   OBTAIN PARAMETER STRING IF PRESENT                                *
*---------------------------------------------------------------------*
         AIF   ('&CLEAR' NE 'YES').CLRN
&N       SETA  (L'&AREA)-1
         AIF   (&N LT 254).CLR200
&N       SETA  254
.CLR200  ANOP
         MVI   &AREA,C' '              INITIALIZE FIRST BYTE
         MVC   &AREA+1(&N),&AREA       FORCE THROUGH REST
.CLRN    ANOP
         SR    R15,R15                 INITIAL LENGTH = 0
         ICM   &REG,15,0(&REG)
         BZ    &NOPA                   NO PARMS IF ZERO
         SLR   R15,R15
         ICM   R15,3,0(&REG)           LOAD LENGTH
         BZ    &NOPA                   NO PARMS IF ZERO
         LA    R0,&AL
         CR    R15,R0                  CHECK MAX LENGTH
         BNH   *+6
         LR    R15,R0                  TRUNCATE
.*--------------------------------------------------------------------*
.*   TSO PARM : BEWARE OF PREFIX AND SUFFIX                           *
.*--------------------------------------------------------------------*
.TSO     AIF   ('&TSO' NE 'YES').TSON
         CLI   2(&REG),X'00'           INDICATE TSO ??
         BNE   &L.TN                   NOPE
         SH    R15,2(,&REG)            SUBTRACT PREFIX LENGTH
         BCTR  R15,0                   SUBTRACT PREFIX 1ST BYTE
         BCTR  R15,0                               -   2ND BYTE
         BCTR  R15,0                   SUBTRACT SUFFIX 1ST BYTE
         BCTR  R15,0                               -   2ND BYTE
         AH    &REG,2(&REG)            BUMP POINTER
         LA    &REG,2(,&REG)                -
&L.TN    EQU   *
.TSON    ANOP
.*--------------------------------------------------------------------*
.*   MOVE TO RECEIVING AREA                                           *
.*--------------------------------------------------------------------*
         BCTR  R15,0                   GET MACHINE LENGTH
         EX    R15,*+8
         B     *+10
         MVC   &AREA.(*-*),2(&REG)     COPY TO OWN AREA
         LA    R15,1(,R15)             REINSTATE REAL LENGTH
&L.X     EQU   *
.MEXIT   ANOP
         POP   PRINT
         MEND
         MACRO
         MPRINT
         GBLA  &MPRINTN
         GBLC  &MPRINT
.*
         AIF   ('&SYSLIST(1)' EQ 'PUSH' OR                             +
               '&SYSLIST(1)'(1,2) EQ 'SA').SA
         AIF   ('&SYSLIST(1)' EQ 'POP' OR                              +
               '&SYSLIST(1)'(1,2) EQ 'RE').RS
         MNOTE 12,'***ERROR - INVALID FUNCTION &SYSLIST(1)'
         MEXIT
.*
.SA      ANOP
&MPRINT  SETC  '&SYSLIST(2)'           USE IF SPECIFIED
         AIF   (K'&SYSLIST(2) EQ 0 AND K'&SYSLIST(3) EQ 0).SA900
         AIF   (K'&SYSLIST(2) EQ 0).SA030
.SA020   ANOP
&MPRINT  SETC  '&SYSLIST(2)'           USE SPECIFIED
         AGO   .SA100
.SA030   ANOP
&MPRINT  SETC  '&SYSLIST(3)'           USE DEFAULT
.*
.SA100   PUSH  PRINT
&MPRINTN SETA  &MPRINTN+1
         PRINT &MPRINT
.SA900   ANOP
         MEXIT
.*
.RS      ANOP
         AIF   (K'&MPRINT EQ 0).RS999
         AIF   (&MPRINTN EQ 0).RS0800
         AIF   (N'&SYSLIST EQ 1).RS0100
         AGO   .RS0200
.*--------------------------------------------------------------------*
.*  POP SINGLE STACK                                                  *
.*--------------------------------------------------------------------*
.RS0100  ANOP
         POP   PRINT
&MPRINTN SETA  &MPRINTN-1
         MEXIT
.*--------------------------------------------------------------------*
.*  POP ENTIRE STACK                                                  *
.*--------------------------------------------------------------------*
.RS0200  ANOP
         AIF   ('&SYSLIST(2)' NE 'ALL').RS02E1
.RS0210  ANOP
         POP   PRINT
&MPRINTN SETA  &MPRINTN-1
         AIF   (&MPRINTN GT 0).RS0210
         MNOTE *,'*** ENTIRE STACK CLEARED'
         MEXIT
.RS02E1  ANOP
         MNOTE 8,'*** ERROR - INVALID SECOND OPERAND - &SYSLIST(2)'
         MEXIT
.*--------------------------------------------------------------------*
.*  EMPTY STACK                                                       *
.*--------------------------------------------------------------------*
.RS0800  ANOP
         MNOTE *,'*** PUSH STACK EMPTY'
.RS999   MEXIT
         MEND
         MACRO
&lbl     MVLIT &A,&T,&LR=,&lenreg=,&LA=
.* move literal to area
.*  lr : load text length to register
.*  la : load register with address of end of text
         aif   (k'&t eq 0).nullp
         lcla  &tl
&tl      seta  (k'&t)-2
&lbl     mvc   &a.(&tl),=c&t
         aif   (k'&lr eq 0 and k'&lenreg eq 0).lrn
         la    &lr&lenreg,&tl
.lrn     anop
         aif   (k'&la eq 0).lan
         la    &la,&a+&tl
.lan     mexit
.nullp   anop
         aif   (k'&lbl eq 0).x
&lbl     ds    0h
.x       MEND
         Macro
&mlbl    NTSERVX &what,&pl=,&rc=,                                      c
               &level=,&l=,&persist=,&p=,&name=,&n=,&token=,&t=
.*  see MVS Programming: Authorized Assembler Services Reference,
.*  volume 2 - (EDTINFO-IXGWRITE) for details of the IEANTxx i/f.
.*  Amode 31 is required for the call method used in this macro.
.*
.*  Retrieve may  use the  caller's save  area as  work area,  see the
.*  retrieve  section  for details.  The  token  is then  returned  in
.*  registers 1-4.
.*   Note that this  is only valid if caller's registers  5-9 have not
.*  yet been modified.
.*
.*  IEANT_NOPERSIST         EQU     0
.*  IEANT_PERSIST           EQU     1
.*  IEANT_TASK_LEVEL        EQU     1
.*  IEANT_HOME_LEVEL        EQU     2
.*  IEANT_PRIMARY_LEVEL     EQU     3
.*  IEANT_SYSTEM_LEVEL      EQU     4
.*  IEANT_TASKAUTH_LEVEL    EQU    11
.*  IEANT_HOMEAUTH_LEVEL    EQU    12
.*  IEANT_PRIMARYAUTH_LEVEL EQU    13
.*
.* Syntax:
.*
.* Sample:
.*  * retrieve using part of the savearea as work area
.*           NTServx rt,name=ntname,pl=SA
.*  * if not found then create data block and n/t entry
.*           if    (nz)
.*             getmain R,lv=2048
.*             st    r1,nttoken
.*             NTServx cr,n=ntname,t=NtToken,pl=ntpl,rc=ntrc
.*             if    (nz)
.*               abend 1
.*             endif
.*           endif
.*           l     r9,nttoken            -> data block
.*          . . . .
.*  * delete
.*           NTServx dl,name=ntname,pl=ntpl,rc=ntrc
.*          . . . .
.*  * data aras
.*  ntname   ds    cl16
.*  nttoken  ds    cl16
.*  ntrc     ds    a
.*  ntpl     NtServx pl
.*
.* Changelog
.*  2018-10-25 change PL=SA to use SA+40 (r5-r9) and return token
.*             in r1-r4.
.*  2019-10-22 short forms of name, level, token and persist parms
.*  2022-06-27 change $LA to SETREG
.*  2024-07-12 change point-to-cvt for FLAG(PAGE0).
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*
         lclc  &u,&lbl,&ofs,&$csect,&$pl,&$token,&$rc,&$what
         lclc  &$level,&$pers,&$plsave
&lbl     setc  'NTX&sysndx'
&$csect  setc  '&sysect'
&u       setc  Upper('&what')
         aif   ('&u' eq 'PL').pl
&$token  setc  '&token.&t'
&$rc     setc  '&rc'
.*
.*- level
&u       setc  Upper('&level.&l.H '(1,1))
&$level  setc  '1'
         aif   ('&u' eq 'T').lvlok
&$level  setc  '2'
         aif   ('&u' eq 'H').lvlok
&$level  setc  '3'
         aif   ('&u' eq 'P').lvlok
&$level  setc  '4'
         aif   ('&u' eq 'S').lvlok
         mnote '8,'** Invalid level, must be T, H, P or S'
         mexit
.lvlok   anop
.*- persist
&u       setc  Upper('&persist.&p.N '(1,1))
&$pers   setc  '1'
         aif   ('&u' eq 'Y').persok
&$pers   setc  '0'
         aif   ('&u' eq 'N').persok
         mnote  8,'** Invalid persist, must ne Y or N'
         mexit
.persok  anop                          IEANT_PERSIST
.*- what
&$what   setc  Upper('&what')
         aif   ('&$what' eq 'CR').cr
         aif   ('&$what' eq 'RT').rt
         aif   ('&$what' eq 'DL').dl
         mnote 8,'invalid entry: &what'
         mexit
.* -- create
.CR      ANOP
         aif   (k'&$token ne 0).cr2
         mnote 8,'** Token missing'
         mexit
.cr2     anop
         mnote *,'NT create'
         SETREG  r1,&pl
         la    r14,=a(&$level)         level
.*       mnote *,'name:  &name.&n'
         SETREG  r15,&name,&n          name
.*       mnote *,'token: &$token'
         SETREG  r0,&$token            token
         stm   r14,r0,0(r1)
         la    r14,=a(&$pers.)         persist
         SETREG  r15,&rc
         stm   r14,r15,12(r1)
&offs    setc  '04'
         ago   .exec
.* -- retrieve
.*  Retrieve may use the caller's save area as work area as follows
.*  parmlist is  r13+40, length 16, overlaying r5-r8
.*  token    is also r13+40 length 16, overlaying r5-r8
.*  rc       is r13+40+16, length 4, overlaying r9
.*  The token is loaded to r1-4. The original r1-4 can be restored
.*  from the save area if needed.
.RT      ANOP
         mnote 'NT retrieve'
&$pl     setc  Upper('&pl')
&$plsave setc  Upper('&pl')
         aif   ('&$pl' ne 'SA').rt2
&$pl     setc  '40(r13)'
&$token  setc  '40(r13)'
&$rc     setc  '40+16(r13)'
.rt2     anop
.*       mnote 'RT r14 (level)=&$level'
.*       mnote '   r15 (name )=&name.&n'
.*       mnote '   r0  (token)=&$token'
.*       mnote '   r1  (rc   )=&$rc   '
.*       mnote '   r1  (pl   )=&$pl   '
         la    r1,&$pl
         la    r14,=a(&$level.)       level
         SETREG  r15,&name,&n          name
         SETREG  r0,&$token
         stm   r14,r0,0(r1)
         SETREG  r14,&$rc
         st    r14,12(,r1)
&offs    setc  '08'
         ago   .exec
.* -- delete
.DL      ANOP
         mnote 'NT delete'
         la    r1,&pl
         la    r14,=a(&$level.)        level
         SETREG  r15,&name,&n          name
         SETREG  r0,&rc
         stm   r14,r0,0(r1)
&offs    setc  '0C'
         ago   .exec
.* -- exec
.exec    anop
         L     r15,16(0,0)           -> CVT
         L     r15,X'220'(,r15)
         L     r15,X'14'(,r15)
         L     r15,X'&offs'(,r15)
         basr  r14,r15
         l     r15,&$rc
         aif   ('&$what' eq 'RT' and '&$plsave' eq 'SA').exec2
         ltr   r15,r15
         mexit
.* using save area as token output area
.exec2   anop
         mnote 'token is in the SA'
         lm    r1,r4,&$token         load token
         save  (5,9)                 re-save
         ltr   r15,r15
         Mexit
.* -- parmlist
.pl      anop
&mlbl    dc   6a(0)
.x       Mend
         MACRO
.*
.* Get modify/stop console response
.* format of 'marea':
.*   pos  len  desc
.*    1    2   length of text
.*    3    n   text
.*
.* Calls
.*
.* lbl  OPCOMM INIT(,NUM=nnn)
.*    Setup control clocks
.*    NUM=    number of outstanding modifys.
.*
.* lbl  OPCOMM GET,MAREA=addr
.*    Get response to area.
.*    MAREA=  address of communication area defined by DS call.
.*    At exit  set r15=0 if command was obtained.
.*             set r15=4 if no command waiting
.*             r0 -> next CIB if more CIBS in queue. otherwise r0=0.
.*             - requires NUM>1.
.*
.* lbl  OPCOMM GETNEXT,MAREA=addr,CIB=addr
.*    CIB=    address of CIB, returned in r0 from GET/GETNEXT call.
.*    MAREA=  address of communication area defined by DS call.
.*    Get next response to area if r0 from GET/GETNEXT was 1.
.*    At exit sets registers like GET.
.*
.* lbl  OPCOMM WAIT wait for a response
.*
.* lbl  OPCOMM DS
.*    Define required data area. can be in getmained storage.
.*
.* lbl  OPCOMM RESPA,LEN=nnn
.*    Build response area using lbl as prefix with length 'len'.
.*
.* lbl  OPCOMM DSECT define required area mappings.
.*    Build data map.
.*
.* Sample
.*           OPCOMM INIT(,NUM=nnn)
.*           OPCOMM GET,MAREA=comresp
.*           OPCOMM GETNEXT,MAREA=comresp,CIB=(r3)
.*           OPCOMM WAIT,MAREA=comresp
.*  comresp  ds    0CL100
.*  comlen   dc    al2(0)
.*  comtext  dc    cl98' '
.*
.* External references
.*  Macro SETREG.
.*
.* Notes
.*  The QEDIT macro is described in the manual MVS Programming:
.*  AuthorizedAssembler Services Reference, Volume 3(LLA-SDU)
.*
.* History
.*  2021-05-22  New function GETNEXT, set r0 according to more in q.
.*
&NAME    OPCOMM &FUNC,&NUM=1,&MAREA=,&STOP=STOP,&COMBLK=OPCOMM,&CIB=,  c
               &LEN=
 mnote 'New OPCOMM'
         LCLA  &N,&M
         LCLC  &L,&C,&s,&$func
&L       SETC  'OP&SYSNDX'
.*
&$func   SETC  Upper('&func')
         AIF   ('&$func' EQ 'INIT').INIT
         AIF   ('&$func' EQ 'WAIT').WAIT
         AIF   ('&$func' EQ 'GET').GET
         AIF   ('&$func' EQ 'GETNEXT').GETNEXT
         AIF   ('&$func' EQ 'DS').DS
         AIF   ('&$func' EQ 'RESPA').RESPA
         AIF   ('&$func' EQ 'DSECT').DSECT
         MNOTE 8,'*** ERROR - INVALID FUNCTION - &FUNC'
         Mexit
.*
.*--------------------------------------------------------------------*
.INIT    ANOP
*-  Obtain address of cib
&NAME    CNOP  0,4
         xc    &comblk.(&comblk.bl),&comblk
         la    r1,&comblk
         LA    R14,&comblk.ra          -> REPLY AREA
         EXTRACT (R14),FIELDS=COMM,MF=(E,&comblk)
.*--------------------------------------------------------------------*
*-  Free start cib
         L     R14,&comblk.ra          -> COMM AREA
         USING iezcom,R14              COVER
         L     R15,COMCIBPT            -> CIB
         USING iezcib,R15              COVER
         CLI   CIBVERB,CIBSTART        START CIB ??
         BNE   &L.LM                   NOPE - GO SET LIMIT
         QEDIT ORIGIN=COMCIBPT,BLOCK=(R15)
         DROP  R14,R15
         LTR   R15,R15                 OK ??
         BNZ   &L.X4                   ELSE GET OUT NOW
.*--------------------------------------------------------------------*
*-  Set limit of outstanding modifyes
&L.LM    l     r14,&comblk.ra          -> COMM AREA
         la    r14,COMCIBPT-IEZCOM(,r14)  -> COM CIBP
         QEDIT ORIGIN=(R14),CIBCTR=&NUM
&l.x4    cnop  0,4
         ltr   r15,r15                 SET RETURN CODE
         mexit
.*--------------------------------------------------------------------*
.WAIT    ANOP
*-  Wait for operator
         AIF   (K'&MAREA(1) GT 0).WAI0100
         MNOTE 8,'*** ERROR - MISSING OPERAND - MAREA'
         mexit
.WAI0100 ANOP
         xc    &marea.(2),&marea       reset length field
         mvi   &marea+2,c' '           reset 1st text byte
         stm   r2,r3,28(r13)           save
         l     r2,&comblk.ra           -> COMM AREA
         USING iezcom,R2               COVER
         l     r1,COMECBPT             -> ECB
         WAIT  ECB=(R1)
         ago   .GetRply
.*
.*--------------------------------------------------------------------*
.GET     ANOP
*-  Get reply if ecb is posted
         AIF   (K'&MAREA(1) GT 0).GET0100
         MNOTE 8,'*** ERROR - MISSING OPERAND - MAREA'
         MEXIT
.GET0100 ANOP
         xc    &marea.(2),&marea       reset length field
         mvi   &marea+2,c' '           reset 1st text byte
         stm   r2,r3,28(r13)           save
         l     r2,&comblk.ra           -> COMM AREA
         USING iezcom,R2               COVER
         l     r1,COMECBPT             -> ECB
         tm    0(r1),x'40'             (ECBPOST)  Posted?
         jo    *+12                    yup
         la    r15,4
         j     &l.x
         ago   .GetRply
.*
.*--------------------------------------------------------------------*
.GetNext ANOP
*-  Get next in queue
         xc    &marea.(2),&marea       reset length field
         mvi   &marea+2,c' '           reset 1st text byte
         stm   r2,r3,28(r13)           save
         l     r2,&comblk.ra           -> COMM AREA
         USING IEZCOM,R2               COVER
         SETREG r3,&CIB
         ago   .GetR20
.GetRply ANOP
*-  Get first or only
         l     r3,COMCIBPT             -> CIB
.getr20  USING iezcib,R3               COVER CIB
         la    r1,CIBDATLN             -> data in cib
         cli   cibverb,CIBMODFY        modify ??
         be    &l.m1                   yes - move in reply
         cli   cibverb,CIBSTOP         stop ??
         bne   &l.e2                   nope - error
         la    r1,&l.stop              -> stop value
         j     &l.m1                   and move in as reply
&l.e2    la    r15,8                   set bad id                <-
         j     &l.x6
&l.m1    lh    r15,0(,r1)              get length of data
         la    r14,2(,r1)              -> data
         cli   0(r14),c''''            quoted?
         jne   &l.m2
         la    r14,1(,r14)             bump ptr
         ahi   r15,-2                  adjust length
&l.m2    la    r0,l'&marea.-2          set max length
         cr    r15,r0                  check max length
         bnh   &l.m3                   ok then bump
         lr    r15,r0                  else set max
&l.m3    stcm  r15,3,&marea            save in receiving area
         bctr  r15,0                   get mch len
         ex    r15,&l.tx               copy text
         l     r0,cibnext              -> next CIB if any
         st    r0,20(,r13)             save
*-  Free CIB
         QEDIT ORIGIN=COMCIBPT,BLOCK=(R3)
         slr   r15,r15                 set good rc
         l     r0,20(,r13)             -> next CIB if any
         lm    r2,r3,28(r13)           restore regs
*-  Test for more
         j     &l.x6                   and get out
&n       seta  k'&stop
&L.STOP  DC    al2(&N),C'&STOP'        STOP VALUE
&l.tx    mvc   &marea.+2(*-*),0(r14)   get text
&L.X6    CNOP  0,4
.*--------------------------------------------------------------------*
         DROP  R2,R3
         ago   .x
.*--------------------------------------------------------------------*
.DS      ANOP  ,                       BUILD RPL LIST
*-  Data
&s       setc  '&name'
         aif   ('&s' ne '').ds0100
&s       setc  'OPCOMM'
.ds0100  anop
&s       ds    0a
&s.xf    EXTRACT FIELDS=COMM,MF=L
&s.ra    ds    a                       -> QEDIT RESPONSE AREA
&s.bl    equ   *-&s
         Mexit
.*--------------------------------------------------------------------*
.RESPA   ANOP  ,                       BUILD RPL LIST
*-  Response area
&s       setc  '&name'
         aif   ('&s' ne '').rsa100
&s       setc  'OPCOMM'
.rsa100  anop
         ds    0h
&s.a     ds    0cl(&len+2)             area
&s.l     ds    al2                     length field
&s.r     ds    cl&len                  response text
         Mexit
.*--------------------------------------------------------------------*
.DSECT   ANOP  ,                       BUILD RPL LIST
*-  Dsects
         PRINT NOGEN
IEZCOM   DSECT
         IEZCOM
IEZCIB   DSECT
         IEZCIB
         Mexit
.*-- END OF MACRO ----------------------------------------------------*
.x       anop
&l.x     cnop  0,4
         Mexit
.*--
         Mend
         Macro
.*-
.*  Do QSAM i/o using 31-bit buffers and rmode any. The generated
.*  code is fully reentrant.
.*
.* Syntax
.*
.*  label    QSAM31 parameters
.*
.* Parameter description
.*
.*  GEN,DCBA=addr,DDNAME='ddname',ACC=GET|GETD|PUT|PUTD,EOD=eodlbl,
.*    RECFM=F|V,RECLEN=nnnnn,PRINT=NOGEN|gen
.*    recfm and reclen are taken from dataset if not specified.
.*    ddname is right-padded to 8 bytes and uppercased.
.*    'print' handles listing the DCB/DCBE expansions (1st call only).
.*    'print' handles listing the DCB/DCBE expansions (1st call only).
.*    eodlbl = 0 sets R15=2 instead of jumping to a label.
.*  MOD,DCBA=addr,DDNAME='ddname',EOD=addr,RECFM=F|V,RECLEN=nnnnn,
.*      ACC=GET|GETD|PUT|PUTD,EOD=eodlbl
.*  OPEN,DCBA=addr,GEN=N|y
.*    Input or output is determined from the DCB.
.*    if GEN=Y then the GEN function is called before OPEN, add
.*    required GEN parameters to the call.
.*  CLOSE,DCBA=addr,DROP=N|y
.*    If DROP=Y then the DROP function is called internally.
.*  DROP,DCBA=addr
.*  For all of the above you can use dcba-addr instead of DCBA=addr
.*  GET,DCBA=addr,DATA=addr,GEN=N|y,EOD=addr
.*    if GEN=Y and the dcba field is zero, then the GEN and OPEN
.*    functions are run prior to 1st GET.
.*    For GETD a RDW in front of the record is required. The data
.*    length is returned in R0.
.*    If EOD=0 then r15 is set to rc zero/nonzero and no branch done.
.*  PUT,DCBA=addr,DATA=addr | DATA=(addr,length)
.*    If GEN=Y and the dcba field is zero, then the GEN and OPEN
.*    functions are run prior to 1st PUT.
.*    'length' is used for recfm V, it is the length of the data.
.*    For PUTD a RDW in front of the record is required.
.*  EXPOSE,DCBA=addr,FIELD=fieldname,OUT=addr | REG=r
.*    See the QSAM31blk dsect for fieldnames.
.*  ISV,DCBA=addr             sets cond ONE if recfm=V
.*  ISF,DCBA=addr             sets cond ONE if recfm=F
.*  ISOPEN,DCBA=addr          sets cond ONE if DCB is open
.*  DCBA      generate area anchor
.*  DSECTS
.*    Generate dsects DCBD and IHADCBE. Own QSAM31blk is always done.
.*  NODSECTS
.*    Do not Generate dsects DCBD and IHADCBE.
.*  TESTDD,ddname | DDNAME=ddname  ddname may be addr label or (reg)
.*
.* Sample 1 - read from a dataset
.*
.*            QSAM31 gen,dcba=datadcba,acc=get,
.*                   ddname=dataddn,eod=dataeod
.*            QSAM31 open,dcba=datadcba
.*   dataread QSAM31 get,data=iobfr,dcba=datadcba
.*            . . . do something . . .
.*            j     dataread
.*   dataeod  QSAM31 close,dcba=datadcba
.*            QSAM31 drop,dcba=datadcba
.*            . . .
.*   datadcba QSAM31 dcba
.*   iobfr    ds    cl160
.*   dataddn  dc    cl8'DATA'
.*            QSAM31 dsects
.*
.* Sample 2 - write to a dataset, 'gen' is done in the 'open'
.*
.*            QSAM31 open,dcba=listdcba,gen=yes,ddname='list',acc=put,
.*                     recfm=f,reclen=l'iobfr
.*            . . .
.*            QSAM31 put,data=iobfr,dcba=listdcba
.*            . . .
.*            QSAM31 close,dcba=listdcba,drop=yes
.*            . . .
.*   listdcba QSAM31 dcba
.*   iobfr    ds    cl120
.*            QSAM31 dsects
.*
.* Sample 3 - read from a dataset with dependent recfm
.*            data is in label IOFBR no matter if recfm is F or V.
.*
.*            QSAM31 gen,dcba=datadcba,acc=getd,
.*                   ddname='data',eod=dataeod
.*            QSAM31 open,dcba=datadcba
.*   dataread QSAM31 get,data=iordw,dcba=datadcba
.*            lr    r2,r0               r0 = data length
.*            . . . do something . . .
.*            j     dataread
.*   dataeod  QSAM31 close,dcba=datadcba,drop=y
.*            . . .
.*   datadcba QSAM31 dcba
.*   iordw    ds    a
.*   iobfr    ds    cl160
.*            QSAM31 dsects
.*
.* Sample 4 - write to a dataset with dependent recfm
.*            data is in label IOFBR no matter if recfm is F or V.
.*
.*            QSAM31 open,dcba=putddcba,gen=yes,ddname='list',acc=putd
.*            . . .
.*            mvc   iobfr(l'text),text
.*            QSAM31 put,dcba=putddcba,data=(iobfrw,l'text)
.*            . . .
.*            QSAM31 close,dcba=putddcba,drop=yes
.*            . . .
.*   putddcba QSAM31 dcba
.*   iordw    ds    a
.*   iobfr    ds    cl120
.*   text     ds    c'Kilroy was here'
.*            QSAM31 dsects
.*
.* History
.*  2019-10-12  Initial
.*  2019-10-18  New actions ISF and ISV
.*  2019-10-20  Allow action DSECTS at top of program
.*  2019-10-31  GET and PUT are now modules. Add GETD and PUTD calls.
.*              new feature - TESTDD
.*  2019-11-01  TESTDD is now a module.
.*  2021-02-11  Test if DCB is open before doing close
.*  2021-07-21  doc update for GET .. EOD=0
.*  2021-08-25  change LH -> LLH in SETREG
.*  2021-12-21  uppercase ddname
.*  2024-07-11  l r2,16 -> l r2,16(0,0) to support option FLAG(PAGE0)
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*-
&mlbl    QSAM31 &p1,&p2,&p3,&p4,                                       c
               &dcba=,&ddname=,&reclen=,&recfm=,&acc=,&data=,          c
               &eod=,&gen=N,&drop=N,&print=nogen,                      c
               &field=,&out=,&reg=r1,&sa=N
.*
         gblc  &#modrmod,&#modamod,&qs31setrl,&$setreglc
         lcla  &n
         lclc  &que,&dcbap,&accp,&genp,&dropp,&l,&s,&msect,&eodp
         gblb  &QSAM31_init,&QSAM31_dsects,QSAM31_SUBISA
.*
&que     setc  Upper('&p1')
&accp    setc  Upper('&acc')
         aif   ('&accp' ne 'G').accpgn
&accp    setc  'GET'
.accpgn  anop
         aif   ('&accp' ne 'P').accppn
&accp    setc  'PUT'
.accppn  anop
&genp    setc  Upper('&gen '(1,1))             Y or N
&dropp   setc  Upper('&drop '(1,1))            Y or N
&dcbap   setc  '&dcba'
.*
         aif   ('&que' eq 'DSECTS').dsects     may come before init
         aif   ('&que' eq 'NODSECTS').nodsect         -
         aif   ('&que' eq 'INIT').init                -
         aif   ('&que' eq 'SETREG').setreg            -
         aif   ('&que' eq 'TESTDD').testdd            -
         aif   (&QSAM31_init).start
         qsam31 init
.start   anop
         aif   ('&accp' eq 'GET' or '&accp' eq 'GETD'                  c
               or '&accp' eq 'PUT' or '&accp' eq 'PUTD'                c
               or k'&acc eq 0).jump1
         mnote 8,'*Invalid acc &acc'
         mexit
.jump1   anop
         aif   ('&que' eq 'SUBI').subi
         aif   ('&que' eq 'SUBX').subx
         aif   ('&que' eq 'DCBA').dcba   DCB area anchor
         aif   (k'&dcbap eq 0).nodcba
         aif   ('&que' eq 'GEN').gen     make cbs
         aif   ('&que' eq 'MOD').mod     updt cb
         aif   ('&que' eq 'OPEN').open
         aif   ('&que' eq 'CLOSE').close
         aif   ('&que' eq 'DROP').drop
         aif   ('&que' eq 'GET').get
         aif   ('&que' eq 'PUT').put
         aif   ('&que' eq 'EXPOSE').expose
         aif   ('&que' eq 'ISF').isf
         aif   ('&que' eq 'ISV').isv
         aif   ('&que' eq 'ISOPEN').isopen
         mnote 8,'*Invalid option &que'
         mexit
.*-
.* IO blk
.*-
.dcba    anop
&mlbl    dc    a(0)
         Mexit
.*-
.* Generate reentrant control blocks
.*-
.gen     anop
&mlbl    ds    0h
         aif   ('&accp '(1,1) eq 'P').gen120
         sr    r0,r0                    set 'get'
         ago   .gen200
.gen120  la    r0,1                     set 'put'
.gen200  qsam31 setreg,r1,&dcbap
         l     r14,=v(QSAM31M)         -> 'make' routine
         balr  r14,r14
         QSAM31 mod,dcba=&dcbap,ddname=&ddname,reclen=&reclen,         c
               recfm=&recfm,eod=&eod,print=&print,acc=&accp
         Mexit
.*-
.* Modify control blocks
.*-
.mod     anop
&mlbl    qsam31 setreg,r14,&dcbap
         l     r14,0(,r14)
         using QSAM31blk,r14
         aif   (k'&ddname eq 0).modddnn
         aif   ('&ddname'(1,1) eq '''').modddnl
         qsam31 setreg,r1,&ddname
         ago   .modddng
.modddnl anop
&s       setc  upper('&ddname')
         la    r1,=cl8&s
.modddng mvc   QSAM31bdcb+(dcbddnam-ihadcb)(8),0(r1)
         oc    QSAM31bdcb+(dcbddnam-ihadcb)(8),=cl8' '
.modddnn anop
         aif   (k'&reclen eq 0).modrcln
         qsam31 setreg,r1,&reclen
         sth   r1,QSAM31bdcb+(dcblrecl-ihadcb)
.modrcln anop
&s       setc  Upper('&recfm '(1,1))
         aif   ('&s' ne 'F').modrffn
         oi    QSAM31bdcb+(dcbrecfm-ihadcb),DCBRECF
.modrffn anop
         aif   ('&s' ne 'V').modrfvn
         oi    QSAM31bdcb+(dcbrecfm-ihadcb),DCBRECV
.modrfvn anop
         aif   (k'&eod eq 0).modeodn
         qsam31 setreg,r1,&eod
         st    r1,QSAM31beod
.modeodn anop
.* set detect recfm=v option
         aif   ('&accp' ne 'GETD' and '&accp' ne 'PUTD').moddrvn
         oi    QSAM31bopts,QSAM31bopt_v
.moddrvn anop
         drop  r14
         mexit
.*-
.* Open DCB
.*-
.open    anop
&l       setc  'QSO&sysndx'
         aif   (k'&mlbl eq 0).open2
&mlbl    ds    0h
.open2   anop
         aif   ('&genp' ne 'Y').open3
         QSAM31 gen,dcba=&dcbap,ddname=&ddname,acc=&accp,              c
               reclen=&reclen,recfm=&recfm,eod=&eod,print=&print
.open3   anop
         qsam31 setreg,r1,&dcbap
         l     r14,=v(QSAM31O)         -> open routine
         balr  r14,r14
         mexit
.*-
.* Close DCB
.*-
.close   anop
&l       setc  'QSO&sysndx'
&mlbl    qsam31 setreg,r15,&dcbap
         l     r15,0(,r15)             -> DCB
         tm    DCBOFLGS-ihadcb(r15),DCBOFOPN  open ??
         jz    &l.b                    no
         Close ((r15)),mode=31,mf=(E,QSAM31bocb-QSAM31blk(15))
&l.b     ds    0h
         aif   ('&dropp' ne 'Y').close2
         QSAM31 drop,dcba=&dcbap
.close2  anop
         mexit
.*-
.* Read
.*-
.get     anop
&l       setc  'QSG&sysndx'
&eodp    setc  '&eod'
         aif   ('&genp' ne 'Y').get400
.* generate and open before 1st get
         lt    r15,&dcbap
         jnz   &l.g
*-       QSAM31 gen
         QSAM31 gen,dcba=&dcbap,ddname=&ddname,acc=&que,               c
               reclen=&reclen,recfm=&recfm,eod=&eodp,print=&print
*-       QSAM31 open
         QSAM31 open,dcba=&dcbap
&l.G     ds    0h
.get400  anop
*-       QSAM31 get
&mlbl    qsam31 setreg,r1,&dcbap       -> anchor
         qsam31 setreg,r0,&data        -> record
         l     r14,=v(QSAM31G)         -> 'get' routine
         balr  r14,r14
         mexit
.*-
.* Write
.*-
.put     anop
&l       setc  'QSP&sysndx'
         aif   ('&genp' ne 'Y').put400
.* generate and open before 1st get
         lt    r15,&dcbap
         jnz   &l.p
*-       QSAM31 gen
         QSAM31 gen,dcba=&dcbap,ddname=&ddname,acc=&que,               c
               reclen=&reclen,recfm=&recfm,print=&print
*-       QSAM31 open
         QSAM31 open,dcba=&dcbap
&l.P     ds    0h
.put400  anop
*-       QSAM31 put
&mlbl    qsam31 setreg,r1,&dcbap       -> anchor
         qsam31 setreg,r0,&data(1)     -> record
.* handle detected recfm v
.*       l     r14,&dcbap
.*       tm    QSAM31bopts-QSAM31blk(r14),QSAM31bopt_v
.*       jz    &l.PP
.*       qsam31 setreg,r14,&data(2),l'&data(1) data size
.*       la    r14,4(,r14)             add l'RDW
.*       sll   r14,16
.*       st    r14,&data(1)            store RDW
         qsam31 setreg,r15,&data(2),l'&data(1) data size
&l.PP    ds    0h
         l     r14,=v(QSAM31P)         -> 'write' routine
         balr  r14,r14
         mexit
.*-
.* Drop resources
.*-
.drop    anop
         qsam31 setreg,r1,&dcbap
         l     r14,=v(QSAM31D)         -> 'drop' routine
         balr  r14,r14
         mexit
.*-
.* Expose fields
.*-
.expose  anop
&mlbl    qsam31 setreg,&reg,&dcbap
         l     &reg,0(,&reg)
&s       setc  Upper('&field')
         aif   ('&s     '(1,7) eq 'QSAM31B').expose2
&s       setc  'QSAM31b&field'
.expose2 anop
         aif   (k'&out ne 0).exposef
         la    &reg,&s.-QSAM31blk(,&reg) dont copy, just get address
         ago   .exposex
.exposef qsam31 setreg,r14,&out
         mvc   0(l'&s,r14),&s.-QSAM31blk(&reg)
.exposex mexit
.*-
.* Test recfm F or V
.*-
.isf     anop
         l     r14,&dcba
         tm    dcbrecfm-ihadcb(r14),DCBRECF
         mexit
.isv     anop
         l     r14,&dcba
         tm    dcbrecfm-ihadcb(r14),DCBRECV
         mexit
.*-
.* Test if the DCB is open, cc=ONE if true
.*-
.isopen  anop
         l     r14,&dcba
         tm    DCBOFLGS-ihadcb(r14),DCBOFOPN
         mexit
.*-
.* Test DD present
.*-
.TestDD  anop
&s       setc  upper('&p2&ddname')
         aif   ('&s'(1,1) eq '''').testddl  literal
         qsam31 setreg,r1,&s
         ago   .testddg
.testddl la    r1,=cl8&s
.testddg anop
         l     r14,=v(QSAM31DD)        -> 'testdd' routine
         balr  r14,r14
         ltr   r15,r15
         mexit
.*-
.* Build internal modules
.*-
.*-
* Subroutine entry
.*-
.subi    anop
&QSAM31_subisa setb 0
.* amode
         aif   ('&#modamod' ne '').#modam2
&mlbl    Amode 31
         ago   .#modamn
.#modam2 anop
&mlbl    Amode &#modamod
.#modamn anop
.* rmode
         aif   ('&#modrmod' ne '').#modrm2
&mlbl    Rmode ANY
         ago   .#modrmn
.#modrm2 anop
&mlbl    rmode &#modrmod
.#modrmn anop
&mlbl    Csect
         Save  (14,12)
.*       lr    r11,r15
         balr  r11,0
         ahi   r11,&mlbl-*
         Using &mlbl,r11
&s       setc  Upper('&sa')
         aif   ('&s '(1,1) ne 'Y').x
.* chain save areas
&QSAM31_subisa setb 1
         l     r14,0(,r1)          -> cb
         la    r14,QSAM31bsa-QSAM31blk(,r14)
         st    r14,8(,r13)
         st    r13,4(,r14)
         lr    r13,r14
         mexit
.*-
* Subroutine exit
.*-
.subx    anop
         aif   (&QSAM31_subisa eq 0).subx2
         l     r13,4(,r13)
.subx2   l     r14,12(,r13)
         Return (2,12)
         mexit
.*-
.* Module init
.*-
.init    anop
         aif   (&QSAM31_init).x          just in case
&QSAM31_init setb 1
&l       setc  'QSI&sysndx'
         j     &l.b
         ltorg
&l.b     ds    0h
&msect   setc  '&sysloc'
         push using
QSAM31blk    Dsect
QSAM31bdcb   ds    xl(QSAM31gdl)
QSAM31bdcblr equ   QSAM31blk+(dcblrecl-ihadcb),2
QSAM31brecl  equ   QSAM31blk+(dcblrecl-ihadcb),2
QSAM31bdcbrf equ   QSAM31blk+(dcbrecfm-ihadcb),1
QSAM31bdcbe  ds    xl(QSAM31gel)
QSAM31bocb   ds    2a              open/close list
QSAM31bdlen  ds    h               data length
QSAM31brecf  ds    c               F or V
QSAM31bopts  ds    x
QSAM31bopt_v  equ  x'80'           pseudo vaiable access
QSAM31beod   ds    a               'get' eod
QSAM31bsa    ds    18a             subroutine save area
QSAM31blkl   equ   *-QSAM31blk
.*
* Generate 24-bit area holding DCB and DCBE
* at entry
* r1 -> dcb anchor
* r0 = 0 => Get, r0 = 1 => Put
.*
QSAM31M  Qsam31 subi
         lr    r2,r1
         lr    r3,r0
         Getmain R,lv=QSAM31blkl,loc=BELOW
         st    r1,0(,r2)                 save ptr
         xc    0(QSAM31blkl,r1),0(r1)
         lr    r2,r1
         using QSAM31blk,r2
         ltr   r3,r3
         jnz   QSAM31M_put
         mvc   QSAM31bdcb(QSAM31gdl),QSAM31gd
         mvc   QSAM31bdcbe(QSAM31gel),QSAM31ge
         j     QSAM31M_set
QSAM31M_put    equ   *
         mvc   QSAM31bdcb(QSAM31pdl),QSAM31pd
         mvc   QSAM31bdcbe(QSAM31pel),QSAM31pe
QSAM31M_set    equ   *
         la    r14,QSAM31bdcbe                -> DECB
         st    r14,QSAM31bdcb+(dcbdcbe-ihadcb) store in DCB
         xc    QSAM31bocb(8),QSAM31bocb      prep open/close list
         mvi   QSAM31bocb,x'80'            prep open/close list
         sr    r15,r15
         Qsam31 subx
* cb models
          push  print
          print &print
QSAM31gd  DCB   ddname=Z,macrf=GM,dsorg=PS,eodad=0,dcbe=*
QSAM31gdl equ     *-QSAM31gd
QSAM31ge  DCBE  RMODE31=BUFF,EODAD=*
QSAM31gel equ     *-QSAM31ge
QSAM31pd  DCB   ddname=Z,macrf=PM,dsorg=PS,eodad=0,dcbe=*
QSAM31pdl equ     *-QSAM31pd
QSAM31pe  DCBE  RMODE31=BUFF
QSAM31pel equ     *-QSAM31pe
          pop   print
          ds    0a
         pop  using
.*
* Open DCB after determining input or output
* at entry
*  r1 -> dcb anchor
.*
&l       setc  'QSO&sysndx'
         push using
QSAM31O  Qsam31 subi
         l     r2,0(,r1)                   -> DCB blk
         using QSAM31blk,r2
.* go
         cli   DCBMACR1-ihadcb(r2),0       z=output, nz=input
         je    &l.o                        output
* input
         OPEN  ((r2)),mode=31,mf=(E,QSAM31bocb)
         j     &l.s
* output
&l.o     equ   *
         OPEN  ((r2),(OUTPUT)),mode=31,                                c
               mf=(E,QSAM31bocb)
.* store some info
.*.s     mvc   QSAM31brecl,QSAM31bdcb+(dcblrecl-ihadcb)
&l.s     mvi   QSAM31brecf,c'F'
         tm    QSAM31bdcb+(dcbrecfm-ihadcb),DCBRECV
         jz    *+8
         mvi   QSAM31brecf,c'V'
.* back
&l.n     sr    r15,r15
         Qsam31 subx
         pop  using
.*
* Read record
* at entry
*  r1 -> dcb anchor
*  r0 -> record area
*  return eodaddr in r0 if end-of-data
*  return r15=1 if end-of-data
.*
         push using
QSAM31G  Qsam31 subi,sa=y
         l     r2,0(,r1)                   -> DCB blk
         lr    r3,r0                       -> record
         using QSAM31blk,r2
.* get
         la    r14,QSAM31Geod
         st    r14,QSAM31bdcbe+(dcbeeoda-dcbe)
* detected recfm V handler
         tm    QSAM31bopts,QSAM31bopt_v option set?
         jz    QSAM31GG                 nope
         tm    QSAM31bdcbrf,DCBRECV     real recfm=V ?
         jo    QSAM31GG                 yes
*  build RDW
         lh    r14,QSAM31bdcblr         copy lrecl
         la    r14,4(,r14)              add l'RDW
         sll   r14,16                   align in RDW
         st    r14,0(r3)                store updated RDW
         la    r3,4(,r3)                adjust data addr
QSAM31GG get   (2),(3)                  get
.* back
         lh    r0,QSAM31bdcblr          copy lrecl
         tm    QSAM31bdcbrf,DCBRECV     real recfm=V ?
         jz    *+8                      nope
         ahi   r0,-4                    adjust for RDW
         sth   r0,QSAM31bdlen
         sr    r15,r15
QSAM31Grtn ds 0h
         Qsam31 subx
.* end of data
QSAM31Geod ds 0h
         la    r15,1                    rc 2 = EOD
         lt    r14,QSAM31Beod           EOD addr supplied?
         jz    QSAM31Grtn               nope, just return with rc
         l     r13,4(,r13)
         lm    2,12,28(13)
         br    14                       jump to EOD addr
         pop   using
.*
* Write record
* at entry
*  r1 -> dcb anchor
*  r0 -> record area
.*
         push using
QSAM31P  Qsam31 subi,sa=y
         l     r2,0(,r1)                   -> DCB blk
         lr    r3,r0                       -> record
         lr    r4,r15                      data length
         using QSAM31blk,r2
* detected recfm V handler
         tm    QSAM31bopts,QSAM31bopt_v option set?
         jz    QSAM31PP                 nope, just write
         tm    QSAM31bdcbrf,DCBRECV     real recfm=V ?
         jo    QSAM31PP                 yes, go write
* detected recfm V handler, but recfm is fixed
         la    r4,4(,r4)                add l'RDW
         sll   r4,16
         st    r4,0(,r3)                store RDW
&l.PP    ds    0h
         la    r3,4(,r3)                bump RDW
* do write
QSAM31PP ds    0h
         put   (2),(3)                  get
         sr    r0,r0
         sr    r15,r15
         Qsam31 subx
         pop   using
.*
* Free 24-bit area holding DCB and DCBE
* at entry
*  r1 -> dcb anchor
.*
         push using
QSAM31D  Qsam31 subi
         lr    r2,r1
.* go
         l     r3,0(,r2)
         Freemain R,lv=QSAM31blkl,a=(r3)
         xc    0(4,r2),0(r2)
.* back
         sr    r15,r15
         Qsam31 subx
         pop  using
.*-
* Test if ddname is present
* at entry
*  r1 -> cl8'ddname'
* at exit
*  r15=0 if found, 1 if not
.*-
         push using
QSAM31DD Qsam31 subi
&l       setc  'QStd&sysndx'
*-testdd &l
         l     r2,16(0,0)              -> cvt
         l     r2,0(,r2)               -> tcbwords
         l     r2,4(,r2)               -> current tcb
         l     r2,12(,r2)              -> tiot
         la    r2,24(,r2)              jump to 1st dd entry
         slr   r0,r0                   locate dd entry in tiot
&l.l     icm   r0,b'0001',0(r2)        get length of dd-entry
         jz    &l.x4                   out if last entry
         clc   4(8,r2),0(r1)           compare against target
         je    &l.x0
         ar    r2,r0                   chain to next dd entry
         j     &l.l
&l.x0    slr   r15,r15                 set good return
         j     &l.xx                   and continue mainline
&l.x4    la    r15,1                   dd entry not found
&l.xx    ds    0h
         Qsam31 subx
         pop  using
.*-
.* End of modules
.*-
.* resume main
&msect   Loctr ,                       resume
         mexit
.*-
.* Dsects
.*-
.dsects  anop
         aif   (&QSAM31_dsects).x
&QSAM31_dsects setb 1
         Dsect
         Push  print
         Print &print
         DCBD  DSORG=PS                 map DCB
         IHADCBE ,                      map DCBE
         Pop   print
         mexit
.*-
.nodsect anop
&QSAM31_dsects setb 1
         mexit
.*-
.* Subroutine, generate Lx instruction (shortened SETREG)
.*
.* Syntax: SETREG reg,what1,what2,,whatn
.*         what: label or (reg) or 'literal' or f/h/b/c.label
.*               x.label -> reg is cleared and the value is loaded
.*               1st non-null 'what' is used
.*-
.SETREG  anop
         lclc  &xlar,&xlap,&xla,&xlapu
         lcla  &xlapn,&xlan
&qs31setrl setc ''
&xlapn   seta  2
&xlar    setc  '&syslist(&xlapn)'
.xlanext anop
&xlapn   seta  &xlapn+1
         aif   (&xlapn gt n'&syslist).x
&xlap    setc  '&syslist(&xlapn)'
&xlapu   setc  Upper('&xlap')
         aif   (k'&xlap eq 0 or '&xlap' eq '''''').xlanext
         aif   ('&xlap '(1,1) eq '(').xlareg
         aif   ('&xlap '(1,1) eq '''').xlalit
         aif   ('&xlap '(2,1) eq '.').xlafld
&xla     setc  t'&xlap
         aif   ('&xla' eq 'N').xlanum
&mlbl    la    &xlar,&xlap
         aif   ('&xlapu  '(1,2) eq 'L''').x
&qs31setrl setc 'l''&xlap'
         mexit
.xlanum  anop
&mlbl    lgfi  &xlar,&xlap
         mexit
.xlareg  anop
&xlan    seta  k'&xlap-2
&xlap    setc  '&xlap'(2,&xlan)
&mlbl    lr    &xlar,&xlap
         mexit
.xlalit  anop
&mlbl    la    &xlar,=c&xlap
&xlan    seta k'&xlap-2
         mexit
.xlafld  anop
&xlan    seta  k'&xlap-2
&xlapu   setc  Upper('&xlap'(1,1))
&xlap    setc  '&xlap'(3,&xlan)
&qs31setrl setc '&xlan'
         aif   ('&xlapu' eq 'F').xlaflf
         aif   ('&xlapu' eq 'H').xlaflh
         aif   ('&xlapu' eq 'B' or '&xlapu' eq 'C').xlaflb
         mnote 8,'* Invalid load parm'
         mexit
.xlaflf  anop
&mlbl    l     &xlar,&xlap
         mexit
.xlaflh  anop
&mlbl    llh   &xlar,&xlap
         mexit
.xlaflb  anop
&mlbl    llc   &xlar,&xlap
         mexit
.*-
.* Macro end
.*-
.nodcba  mnote 8,'**Missing DCBA'
.x       MEND
         Macro
.*-
.* Macro subroutine - return address parm in global variable
.*
.* General information
.*  The macro will pick the first non-null parameter and use that.
.*  The parameter is then tested for being either a literal, a
.*  register or an address. The resulting address is returned in the
.*  $SETMADDR variable, the length is returned in the $SETMADDRL
.*  variable if possible and the type (A address L literal or R
.*  register) is returned in the $SETMADDRT variable.
.*
.* Notes
.*  -  An literal without text ('') is considered a null parameter and
.*     is ignored.
.*  -  An unknown address will be interpreted as a unquoted literal,
.*     thus allowing for something like SETMADDR B to return =C'B'.
.*
.* Address types
.*  literal    text in quotes i.e. 'Just kidding', or unknown address,
.*             see notes above. The macro returns =C'text'.
.*  register   text in paranthesis, i.e. (r2). The macro returns
.*             0(text) to allow for the use of LA instruction.
.*  address    valid and known address, i.e. field1. The macro returns
.*             the text.
.*
.* Sample
.*  SETMADDR ,(r2)
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com
.*-
         SETMADDR
         lcla  &n
         lclc  &a,&p,&t
         gblc  &$setmaddr,&$setmaddrl,&$setmaddrt
&$setmaddr  setc ''
&$setmaddrl setc '0'
&$setmaddrt setc ''
.*
.next    anop
&n       seta  &n+1
         aif   (&n gt n'&syslist).null
&p       setc  '&syslist(&n)'
         aif   (k'&p eq 0).next                  null string
         aif   ('&p' eq '''''').next             null quoted string
         aif   ('&p'(1,1) eq '(').reg
         aif   ('&p'(1,1) eq '''').lit
&t       setc  t'&p
         aif   ('&t' eq 'U').utype
&n       seta  l'&p
&$setmaddrl setc '&n'
&$setmaddrt setc 'A'
&$setmaddr  setc '&p'
         mexit
.*
.utype   anop
&p       setc  '''&p'''
.*
.lit     anop
&n       seta  (k'&p)-2
&$setmaddrt setc 'L'
&$setmaddrl setc '&n'
&$setmaddr  setc '=c&p'
         mexit
.reg     anop
&$setmaddrt setc 'R'
&$setmaddr  setc '0&p'
         mexit
.null    anop
         mexit
.*
         mend
         Macro
.*-
.* SETREG - build Lx instruction (inner macro)
.*
.* Returns length in a global variable, length either defined by the
.* 2rd operand, or computed from the 2nd operand.
.* Syntax:
.*   SETREG r1,label    -> laey  r1,label
.*   SETREG r1,,label   -> laey  r1,label
.*   SETREG r1,number   -> iilf  r1,nnn
.*   SETREG r1,4(,r3)   -> la    r1,4(,r3)                 -> length=0
.*   SETREG r1,(r2)     -> lr    r1,r2                     -> length=0
.*   SETREG r1,'kilroy' -> la    r1,=c'kilroy'
.*   SETREG r1,0        -> slr   r1,r1                     -> length=0
.*   SETREG r1,x.label  -> lx    r1,label  (x: B,C,F or H) -> length=0
.* The length is returned in global variables &$SETREGL (numeric) and
.* &$SETREGLC (character). Be careful as i.e. equated number will set
.* length=1.
.* The type LBL, TXT etc is returned in global variable &$SETREGT.
.* Note that label B.xx  expands into a LLC instruction which loads
.* the entre byte, whereas the LB instruction uses bit 0 as a sign.
.*
.* History
.*  2017-14-03  numeric value now different from label.
.*  2018-06-16  2rd operand is now alternate src, not global length.
.*  2019-01-11  change global $SETREGLC.
.*  2020-11-11  add global $SETREGT.
.*  2020-12-01  change 'la label' to laey label', sr+ic to llc.
.*  2021-06-03  update set of &$SETREGL and &$SETREGLC.
.*              fix handling of source like 1(,r1) - new type REGO.
.*  2021-07-21  change t'&src eq 'U' to t'&src ne 'C'
.*  2021-08-22  new type *.address, macro determines field len
.*  2021-08-23  change LH to LLH
.*  2024-04-12  new loadopt - FF
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*-
&mlbl    SETREG &reg,&psrc,&pasrc,&pasrc2,&glen=,&src2=
         lcla  &n,&l
         lclc  &s,&c,&r,&srct,&srcl,&src,&li(4)
         gbla  &$SETREGL
         gblc  &$SETREGLC
         gblc  &$SETREGT
&$SETREGL  seta 0
&$SETREGLC setc ''
.* select source
         aif   (k'&psrc   gt 0).setsrc1
         aif   (k'&pasrc  gt 0).setsrc2
         aif   (k'&pasrc2 gt 0).setsrc3
         aif   (k'&src2   gt 0).setsrc4
         mnote  8,'** SETREG mising source'
.setsrc1 anop
&src     setc  '&psrc'
         ago   .setsrcn
.setsrc2 anop
&src     setc  '&pasrc'
         ago   .setsrcn
.setsrc3 anop
&src     setc  '&pasrc2'
         ago   .setsrcn
.setsrc4 anop
&src     setc  '&src2'
.setsrcn anop
.*
&s       setc  Upper('&src')
         aif   ('&s   '(1,3) eq 'L''''').litlen
&srct    setc  t'&src
&srcl    setc  Lower('&src')
.* mnote *,'type &srct'
.*-
.* what kind of 1st operand do we have?
.*-
         aif   (k'&src gt 0).cp1
         mnote 8,'src operand missing'
         mexit
.cp1     anop
&n       seta  k'&src
         aif   ('&s  '(1,3) eq 'FF.').loadff load+load
         aif   ('&src '(2,1) eq '.').load
         aif   ('&src' eq '0').clr          clear register
         aif   ('&src'(1,1) eq '(').reg     register
         aif   ('&src'(1,1) eq '''').txt    text
         aif   ('&srct' eq 'N').num         number
         aif   ('&src'(&n,1) eq ')').rego   register + number '4(r13)'
         ago   .lbl                         assume label
.*- src is 0, means clear reg
.clr     anop  ,
&$SETREGT setc 'CLR'
&mlbl    slr   &reg,&reg
         mexit
.*- src is a number
.num     anop  ,
&$SETREGT setc 'NUM'
&mlbl    iilf  &reg,&src
&$SETREGL seta &src
         mexit
.*- src is a label or address or n(reg)
.lbl     anop  ,                           label
&$SETREGT setc 'LBL'
&mlbl    laey  &reg,&src
&s       setc  t'&src
.* mnote *,'LBL t=&s'
&s       setc  Upper('&src')
         aif   ('&s'(1,2) eq 'L''').lbll
         aif   (t'&src ne 'C').lblu        was eq c'U'  2021-07-21
&$SETREGL  seta l'&src
&$SETREGLC setc '&$SETREGL'
         mexit
.lblu    anop
&$SETREGLC setc 'l''&src'
         mexit
.lbll    anop
&$SETREGLC setc '&src'
         mexit
.*- src is a register
.reg     anop  ,                           register
&$SETREGT setc 'REG'
&n       seta  (k'&src)-2
&s       setc  '&src'(2,&n)
&mlbl    lr    &reg,&s
         mexit
.*- src is a register + number , i.e. 4(,r13)
.rego    anop  ,                           register
&$SETREGT  setc 'REGO'
&mlbl    la    &reg,&s
         mexit
.*- src is text
.txt     anop  ,
&$SETREGT setc 'TXT'
&s       setc  '=c&src'
&mlbl    laey  &reg,&s
&n       seta  (k'&src)-2
&$SETREGL seta &n
&$SETREGLC setc '&n'
         mexit
.*- load from storage
.load    anop  ,
.* mnote *,'load'
&c       setc  Upper('&srcl'(1,1))
&n       seta  (k'&src)-2
&s       setc  '&src'(3,&n)
&$SETREGT setc 'LFS'
         aif   ('&c' eq 'F' or '&c' eq 'A').loadf
         aif   ('&c' eq 'B' or '&c' eq 'C').loadb
         aif   ('&c' eq 'H').loadh
         aif   ('&c' eq '*').loadQ
         mnote 8,*** invalid load parm &c'
         mexit
.loadf   anop  ,
&mlbl    l     &reg,&s                     load from fullword
         mexit
.loadff  anop  ,
&n       seta  (k'&src)-3
&s       setc  '&src'(4,&n)
&mlbl    l     &reg,&s                     load address of data
         l     &reg,0(,&reg)               load from fullword
         mexit
.loadh   anop  ,
&mlbl    llh   &reg,&s                     load from halfword
         mexit
.loadb   anop  ,
&mlbl    llc   &reg,&s                     load from byte
         mexit
.loadq   anop  ,
&li(1)   setc  'llc'
&li(2)   setc  'llh'
&li(3)   setc  '???'
&li(4)   setc  'l'
&l       seta  l'&s
&c       setc  '&li(&l)'
&mlbl    &c    &reg,&s
         mexit
*-
.litlen  anop
&n       seta  (k'&src)-4
&$SETREGL  seta &n
&$SETREGLC setc '&$SETREGL'
         la    &reg,&n                     length of literal
         mexit
*-
.x       Mend
         MACRO
.*-
.* Single-linked list
.* Syntax:
.*   label  SLNKLST ADD,SIZE=n,ADDR=addr|0Ý,data=(daddrÝ,dlen¨)¨
.*                  Ý,SP=n|0¨Ý,KEY=n|8¨
.*   label  SLNKLST ANCHOR
.*   label  SLNKLST NEXT,ADDR=addr
.*   label  SLNKLST DROP,ADDR=addr,PREV=addr|0
.*   label  SLNKLST DROPALL,FIRST=first-entry
.*          SLNKLST DSÝ,PREFIX=prefix¨
.*
.* Parameter descriptions
.*   ADD     Add a new entry.
.*   ADDR=   Address of a fullword containing the address of the
.*           current entry, or zero. Could be the anchor block.
.*           Address is label, (reg) or f.label Can be '0' for ADD, in
.*           which case neither forward nor backward pointers are
.*           updated - note that '0' may be a register with zeroes.
.*   ANCHOR  Generate anchor address field.
.*   DROP    Delete entry. If the PREV= parameter is used then the
.*           forward pointer in that is updated.
.*   DS      Generate anchor, last, count and cursor fields.
.*   FIRST=  Address of the first entry for the DROPALL call.
.*   NEXT    Get next entry.
.*   PREV=   Address of the previous entry in the list. Must be 0 if
.*           no previous.
.*   SIZE=   Size value for ADD, n is a number, (reg) or f.label. Must
.*           be ge dlen if data= is used.
.*   SP=     Storage subpool. If used for the ADD function, then it
.*           be also set for the DROP functions.
.*   KEY=    Storage key. Must be 8 for subpools 131 and 132.
.*   daddr   Data address - label, (reg) or f.label
.*   dlen    Data length - value or (reg).
.*
.*   Registers after ADD and NEXT:
.*     r1 -> block, r0 -> data section. r1 is 0 if no next.
.*
.* Samples
.*
.* add first
.*           SLNKLST add,size=textl,addr=0
.*           st    r1,SLNKlsta
.*
.* add 2 entries (first and second)
.*           la    r8,SLNKLSTA
.*           SLNKLST add,size=textl,addr=(r8)
.*           lr    r8,r1
.*           SLNKLST add,size=textl,addr=(r8)
.*           st    r8,SLNKLSTE               save address of last
.* add 1 after last
.*           l     r8,SLNKLSTE
.*           SLNKLST add,size=textl,addr=(r8)
.* drop one
.*           SLNKLST drop,addr=(r2),prev=(r3)
.* drop all
.*           SLNKLST dropall,addr=f.SLNKLSTA
.* scan list
.*           l     r2,SLNKLSTA             -> first
.*  SCAN     equ   *
.*        .. do something ..
.*           SLNKLST next,addr=(r2)
.*           ltr   r2,r1
.*           jnz   SCAN
.*
.*  SLNKLSTA dc   a(0)
.*  SLNKLSTE dc   a(0)
.*
.* Changelog
.*  2019-01-05  Expand dsect at first call, unless DSECT=N
.*  2020-12-04  Getmain loc=31
.*  2024-07-04  Add PREFIX parm and define standard storage areas.
.*  2024-07-15  Add KEY= parm, default=8.
.*
.* By
.*  Willy Jensen
.*     mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*-
&ml      SLNKLST &addr=,&prev=,&first=,&clear=,&size=,&data=,          c
               &dsect=Y,&loc=(RES,31),&sp=0,&key=8,&prefix=SLNKL,      c
               &trace=
         lclc  &que,&s,&l
         lcla  &nexto,&sizeo,&datao,&poolo,&pfxl
         gblc  $xlalen
&nexto   seta  0
&sizeo   seta  4
&poolo   seta  8
&keyo    seta  9
&datao   seta  12
&pfxl    seta  12
&l       setc  'SLL&sysndx'
         gblb  @SLNKlst
&que     setc  Upper('&syslist(1)')
         aif   ('&que' eq 'XLA').xla
         aif   ('&que' eq 'DSECT').dsect
         aif   ('&que' eq 'DS').ds
         aif   ('&que' eq 'ANCHOR').anchr
         aif   (k'&addr eq 0 and k'&first eq 0).err2 ADDR= required
         aif   ('&dsect' ne 'Y' or &@SLNKlst).dsct1n
&s       setc  '&sysect'
         SLNKLST DSECT
&s       Csect
.dsct1n  anop
.*
         aif   ('&que' eq 'ADD').add
         aif   ('&que' eq 'NEXT').next
         aif   ('&que' eq 'DROP').drop
         aif   ('&que' eq 'DROPALL').dropa
.err1    mnote 8,'***Error invalid option'
         mexit
.err2    mnote 8,'***Error ADDR or FIRST parm is required'
         mexit
.err3    mnote 8,'***Error PREV parm is required'
         mexit
.*-
.* add new entry
.*-
.ADD     ANOP
&ml      SLNKLST XLA,r0,&sp
*getmain
         SLNKLST XLA,r14,&size
         la    r14,&pfxl.(,r14)        add prefix
         Getmain RC,lv=(14),bndry=DBLWD,sp=&sp,key=&key,loc=&loc
         xc    0(&pfxl,r1),0(r1)
         st    r14,&sizeo.(,r1)        save size
.* forced write of storage pool and key
         SLNKLST XLA,r0,&sp
         stc   r0,&poolo.(,r1)         save subpool
         SLNKLST XLA,r0,&key
         stc   r0,&keyo.(,r1)          save key
.* chain
*chain
         SLNKLST XLA,r15,&addr
         ltr   r15,r15                 any current
         jz    &l.b                    else bypass chaining
         l     r14,&nexto.(r15)        -> next
         st    r1,&nexto.(r15)         set next in current
         st    r14,&nexto.(,r1)        set next in new
&l.b     equ   *
.* clear
&s       setc  Upper('&clear')
         aif   ('&s '(1,1) ne 'Y').addcn
*clear
         st    r1,24(,r13)
         la    r0,&datao.(,r1)         set target addr
         SLNKLST XLA,r1,&size
         sr    r14,r14
         sr    r15,r15
         mvcl  r0,r14
         l     r1,24(,r13)
.addcn   anop
         aif   (n'&data eq 0).adddn
*get data
         SLNKLST XLA,r14,&data(1)
         SLNKLST XLA,r15,&data(2),&$xlalen
         st    r1,24(,r13)
         la    r0,&datao.(,r1)
         SLNKLST XLA,r1,&size
         cr    r1,r15                  test l'target gt l'data
         jh    *+6
         lr    r15,r1                  else use l'target
         mvcl  r0,r14
         l     r1,24(,r13)
.adddn   anop
.* setup pointers for caller
*data ptr
         la    r0,&datao.(r1)          -> data section
*end
         mexit
.*-
.* address next entry
.*-
.NEXT    ANOP
&ml      SLNKLST XLA,r1,&addr
         ltr   r1,r1
         jz    &l.x                    no current
         l     r1,&nexto.(,r1)         -> next
         la    r0,&datao.(r1)          -> data section
&l.x     equ   *
         mexit
.*-
.* drop one
.*-
.DROP    ANOP
         aif   (k'&prev eq 0).err3     PREV= required for rest
*unchain
&ml      SLNKLST XLA,r1,&addr
         SLNKLST XLA,r14,&prev         -> previous
         ltr   r14,r14
         jz    &l.a
         l     r15,&nexto.(,r1)        -> next
         st    r15,&nexto.(,r14)       update next in prev
*free
&l.a     l     r0,&sizeo.(,r1)         size
         llc   r14,&poolo.(,r1)        subpool
         llc   r15,&keyo.(,r1)         key
         sll   r15,4                   move to bits 24-27
         Freemain RC,lv=(r0),a=(r1),sp=(r14),key=(r15)
         ltr   r15,r15
*end
         mexit
.*-
.* drop all
.*-
.DROPA   ANOP
         aif   (k'&first gt 0).dropa1
         mnote 4,'*You really should use the FIRST parameter*'
.DROPA1  ANOP
&ml      st    r2,28(,r13)             save
         SLNKLST XLA,r2,&first&addr    -> starting point
&l.a     ltr   r2,r2                   test for address
         jz    &l.x                    no list
         l     r15,&sizeo.(,r2)        size
         lr    r1,r2                   copy address
         l     r2,&nexto.(,r2)         -> next
         aif   (k'&trace eq 0).dropatn
         &trace
.dropatn anop
         l     r0,&sizeo.(,r1)         size
         llc   r14,&poolo.(,r1)        subpool
         llc   r15,&keyo.(,r1)         key
         sll   r15,4                   move to bits 24-27
         Freemain RC,lv=(r0),a=(r1),sp=(r14),key=(r15)
         j     &l.a
&l.x     ds    0h
         l     r2,28(,r13)             restore
         mexit
.*-
.* anchor
.*-
.anchr   anop
&ml      dc    a(0)
         mexit
.*-
.* define standard storage areas
.*-
.ds      anop
&l       setc  Upper('&prefix')
&l.anchr ds    a
&l.first equ   &l.anchr,4
&l.last  ds    a
&l.count ds    a
&l.csr   ds    a
         mexit
.*-
.* dsect
.*-
.dsect   anop
         aif   (&@SLNKlst).mend
&@SLNKlst    setb 1
SLNKLSTBLOK  dsect
SLNKlstnexto equ   &nexto
SLNKlstnext  ds    a                   -> next in queue
SLNKlstsizeo equ   &sizeo
SLNKlstsize  ds    a                   size of block incl pfx
SLNKlstpoolo equ   &poolo
SLNKlstpool  ds    x                   storage subpool #
SLNKlstkey   ds    x                   storage key
             ds    2x                  future
SLNKlstpfxl  equ   &datao              prefix size
SLNKlstdatao equ   &datao
SLNKlstdata  ds    0a
         mexit
.*-
.* XLA - subroutine, generate Lx instruction
.* Syntax: macname XLA,reg,ahat
.*                 what: label, (reg), 'literal', f/h/b.label
.*-
.XLA     anop
         lclc  &xlar,&xlap,&xla
         lcla  &xlapn,&xlan
&$xlalen setc  ''
&xlar    setc  '&syslist(2)'
&xlapn   seta  2
.xlanext anop
&xlapn   seta  &xlapn+1
         aif   (&xlapn gt n'&syslist).xlan
&xlap    setc  '&syslist(&xlapn)'
         aif   (k'&xlap eq 0).xlanext
         aif   ('&xlap '(1,1) eq '(').xlareg
         aif   ('&xlap '(1,1) eq '''').xlalit
         aif   ('&xlap  '(2,1) eq '.').xlafld
&xla     setc  t'&xlap
         aif   ('&xla' eq 'N').xlanum
         la    &xlar,&xlap
&$xlalen setc 'l''&xlap'
         mexit
.xlanum  anop
         lgfi  &xlar,&xlap
         mexit
.xlafld  anop
&xlan    seta  k'&xlap-2
&xla     setc  '&xlap'(1,1)
&xla     setc  Upper('&xla')
         aif   ('&xla' ne 'F').xlafld2
&xla     setc  ''
.xlafld2 anop
&xlap    setc  '&xlap'(3,&xlan)
         l&xla &xlar,&xlap
         mexit
.xlareg  anop
&xlan    seta  k'&xlap-2
&xlap    setc  '&xlap'(2,&xlan)
         lr    &xlar,&xlap
         mexit
.xlalit  anop
         la    &xlar,=c&xlap
&xlan    seta k'&xlap-2
&$xlalen setc '&xlan'
.xlan    mexit
.mend    MEND
         Macro
.*-
.* Generate new string from string using conversion mask.       STRMACS
.*
.* Parm field:
.*  Ýwhat,¨STRING=s,MASK=m,OUT=o,MCHR=c,PL=p
.*  what is an optional directive as follows:
.*   CALL   generate call only, do not generate module. This can be
.*          used if the module is included by lked.
.*   MODULE generate module only, do not generate call. This can be
.*          used to create a module for later inclusion by lked.
.*          You must supply register equates before and END statement.
.*   PL     generate the parameter list area. Label is required.
.*  s, m and o are either an address or an (address,length) pair,
.*  when pair then both operands may be (register). Default length
.*  is the length of the field.
.*  c is the address of a 7-byte optional area, it contains alternate
.*  mask characters. Default is %*>?+'\
.*  p is the address of a 8-word area, it may be (register). It is
.*  recommended that you use STRBYMSK PL to generate the area.
.*
.* Returns
.*  r15 = 0 => all ok
.*        1 => end of string before end of mask
.*        2 => mask error i.e. missing quote
.*        3 => output overflow
.*        4 => text not found in string
.*        5 => mask text overflow (no space in string)
.*  r0  = length of generated output
.*
.* Mask characters operation
.*  %        String character is copied to the output.
.*  +c       Insert character.
.*  +'text'  Insert text. Maximum text length is 254.
.*  -        Delete character.
.*  -'text'  Delete up to, but not including, 'text'. Maximum text
.*           length is 254.
.*  *        Copy remainder to output (position cursor).
.*  *'text'  Copy string characters from the current position to text,
.*           'text' itself is not copied. Maximum text length is 254.
.*  ?text?if-found?not-found?
.*           If text matches string at cursor then use if-found mask,
.*           else use not-found mask. Either mask may be null.
.*  ?>text?if-found?not-found?
.*           If text matches string anywhere at or after cursor then
.*           use if-found mask, else use not-found mask. Either mask
.*           may be null. Maximum text length is 254.
.*  \        The char following in the mask is copied to output, this
.*           allows you to copy a mask character - i.e. \%
.*  other    Mask character is copied.
.*
.* Sample call
.*           la    r2,l'str1
.*           la    r3,l'msk1
.*           StrByMsk string=(str1,(r2)),mask=(msk1,(r3)),
.*                 out=out,pl=sbmpl
.*           lr    r5,r0         copy out length
.*          . . .
.*  str1     dc    c'SYS1.ASM.MACLIB'
.*  msk1     dc    c'SYS2.-''MAC''*' -> SYS2.MACLIB
.*  out      dc    cl100' '
.*  sbmpl    StrByMsk pl
.*
.* Some samples
.*  Text               Mask                   Result
.*  ASM.MACLIB         +'B.'*                 B.ASM.MACLIB
.*  ASM.MACLIB         *'.M'.TEST             ASM.TEST
.*  SYS1.ASM.MACLIB    SYS2.-'MAC'*           SYS2.MACLIB  0
.*  ASM.MACLIB         +'SYS2'-'.'*           SYS2.MACLIB  0
.*  SYS1.ASM.MACLIB    SYS2.-'MAC'---ASMLIB   SYS2.ASMLIB  0
.*  SYS1.ASM.MACLIB    *'.'--'.'.*            SYS1.MACLIB  0
.*  SYS2.T.ASM.MACLIB  *'.'--'.'--'.'.*       SYS2.MACLIB  0
.*  ABC.T.ASM.MACLIB   SYS3-'.'--'.'.*        SYS3.MACLIB  0
.*  SYS1.ASM.MACLIB    SYS2.*'MAC'TESTLIB     SYS2.ASM.TESTLIB N
.*  Kilroy_was_here    *'was'was+'_never'*    Kilroy_was_never_here
.*
.* History
.*  2021-08-01 Initial
.*  2021-09-18 Add PRINT parameter
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*-
&mlbl    StrByMsk &string=,&mask=,&out=,&pl=,&mchr=0,&print=GEN
         lcla  &n
         lclc  &s,&l,&sl1
         gblb  &#STRBYMSK
         gblc  &$setreglc
&sl1     setc  Upper('&syslist(1)')
         aif   ('&sl1' eq 'PL').pl
         aif   ('&sl1' eq 'MODULE').module
         aif   ('&sl1' eq 'CALL').t01
         aif   ('&sl1' eq 'SETMOD').setmod
         aif   (&#STRBYMSK eq 0).module
.t01     aif   (n'&string gt 0).t02
         mnote 8,'*** missing string'
         mexit
.t02     aif   (n'&mask gt 0).t03
         mnote 8,'*** missing mask'
         mexit
.t03     aif   (n'&out gt 0).t04
         mnote 8,'*** missing out'
         mexit
.t04     aif   (n'&pl eq 1).t05
         mnote 8,'*** missing pl'
         mexit
.t05     anop
         SETREG r1,&pl
         xc    0(8*4,r1),0(r1)
         SETREG r14,&string(1)
         SETREG r15,&string(2),&$setreglc
         SETREG r0,&mask(1)
         stm   r14,r0,0(r1)
         SETREG r14,&mask(2),&$setreglc
         SETREG r15,&out(1)
         SETREG r0,&out(2),&$setreglc
         stm   r14,r0,12(r1)
         SETREG r14,&mchr
         st    r14,24(r1)
         Call  zStrByMs
         ltr   r15,r15
         mexit
.err1    anop
         mexit
.*-
.* Module
.*
.* General register usage
.* r4   -> text
.* r5   -> end of text
.* r6   -> mask
.* r7   -> end of mask
.* r8   -> output
.* r9   -> end of output
.* r10  mask chars 1-4, defaults %*+-
.* r11  some conditions in byte 1
.*      mask chars 5-7, defaults '?\  in bytes 2-4
.* r12  base
.*-
.module  anop
         push  print
         print &print
         gblc  &#module_rmode,&#module_amode
&#STRBYMSK setb 1
&sloc    setc  '&sysloc'
         push  using
&l       setc  'zsbm'
         aif   (k'&#module_rmode eq 0).rmodend
Zstrbyms rmode &#module_rmode
Zstrbyms amode &#module_amode
.rmodend anop
.*       lclc  &pcm,axm,psm,msm,qmm,qtm,&cndsup,&cnds1,&cnds2
* in r10
&pcm     setc  'b''1000'''             PerCentage sign mask
&axm     setc  'b''0100'''             AsteriX mask
&psm     setc  'b''0010'''             Plus Sign mask
&msm     setc  'b''0001'''             Minus sign (-) mask
&pcr     setc  'R10'                   PerCentage sign register
&axr     setc  'R10'                   AsteriX register
&psr     setc  'R10'                   Plus Sign register
&msr     setc  'R10'                   Minus sign (-) register
* in r11
&qtm     setc  'b''0100'''             QuoTe mask
&qmm     setc  'b''0010'''             Question Mark mask
&ecm     setc  'b''0001'''             EsCape mask
&qtr     setc  'R11'                   QuoTe register
&qmr     setc  'R11'                   Question Mark register
&ecr     setc  'R11'                   EsCape register
* flags in storage
&cndsup  setc  'x''80'''               cond-suppress on
&cnds1   setc  'x''40'''               cond-sect 1 in progress
&cnds2   setc  'x''20'''               cond-sect 2 in progress
&cndr    setc  'R11'
* Begin csect
Zstrbyms Csect
         save  (14,12)
         basr  r12,0
         ahi   r12,-6
         using zstrbyms,r12
         xc    8(4,r13),8(r13)         clear flag field
         lm    r4,r10,0(r1)
         ar    r5,r4                   make length
         bctr  r5,0                      to end-of-text pointer
         ar    r7,r6                   make length
         bctr  r7,0                      to end-of-mask pointer
         ar    r9,r8                   make length
         bctr  r9,0                      to end-of-mask pointer
         sr    r11,r11
         ltr   r10,r10                 alternate char list?
         jne   &l.lmc                  nope
         la    r10,&l.mcl              -> default char list
&l.lmc   icm   r11,b'0111',4(r10)      '?\
         icm   r10,b'1111',0(r10)      %*+-
&l.t01   ds    0h
         cr    r8,r9                   test for end of output
         jh    &l.x03
         cr    r6,r7                   test for end of mask
         jh    &l.x00
.*       cr    r4,r5                   test for end of string
.*       jh    &l.x01
.* handle suppression on
.*       tm    8(r13),&cndsup          suppression on?
.*       jz    &l.t02                  nope
         ltr   r11,r11                 suppression on?
         jnm   &l.t02                  nope
         clm   &qmr,&qmm,0(r6)         question mark ?
         je    &l.q01                  then go handle
         la    r6,1(r6)                else bump mask pos
         j     &l.t01                  and try next
.* escape char, copy the following unmodified to output
.* normal mask test
&l.t02   ds    0h
         clm   &pcr,&pcm,0(r6)         % -> copy string char
         je    &l.c01
         clm   &psr,&psm,0(r6)         + -> insert text
         je    &l.i01
.*       clm   &qtr,&qtm,0(r6)         ' -> insert text (old style)
.*       je    &l.i21
         clm   &msr,&msm,0(r6)         - -> drop string char
         je    &l.d01
         clm   &axr,&axm,0(r6)         * -> copy string block
         je    &l.b01
         clm   &ecr,&ecm,0(r6)         \ -> escape char (special ops)
         je    &l.e01
         clm   &qmr,&qmm,0(r6)         ? -> question if continue
         je    &l.q01
         j     &l.o01
&l.e01   ds    0h                      copy following
         cr    r6,r7                   is there a following?
         je    &l.x02                  no, error
         mvc   0(1,r8),1(r6)
         la    r4,1(,r4)               bump string pos
         la    r6,2(,r6)               bump mask pos
         la    r8,1(,r8)               bump output pos
         j     &l.t01
.* copy mask char to output
&l.o01   ds    0h                      overlay with mask char
         mvc   0(1,r8),0(r6)
         la    r4,1(,r4)               bump string pos
         la    r6,1(,r6)               bump mask pos
         la    r8,1(,r8)               bump output pos
         j     &l.t01
.* copy string char to output
&l.c01   ds    0h                      copy string char
         cr    r4,r5                   test for end of string
         jh    &l.x01
         mvc   0(1,r8),0(r4)
         la    r4,1(,r4)               bump string pos
         la    r6,1(,r6)               bump mask pos
         la    r8,1(,r8)               bump output pos
         j     &l.t01
.* insert mask text
&l.i01   ds    0h
         la    r6,1(,r6)               -> after +
         clm   &qtr,&qtm,0(r6)         ' -> insert text
         je    &l.i21
         mvc   0(1,r8),0(r6)           insert char
         la    r6,1(,r6)               bump char
         la    r8,1(,r8)               bump output ptr
         j     &l.t01
&l.i21   ds    0h
         llc   r0,0(,r6)               load quote
         la    r1,1(,r6)               -> after '
         bal   r14,&l.msd              get text length in r15
         ar    r15,r8                  test
         cr    r15,r9                   sufficient
         jh    &l.x03                    space
         sr    r15,r8                  restore r15
         bctr  r15,0
         ex    r15,&l.ix1
         la    r6,3(r15,r6)            -> past 'text'
         la    r8,1(r15,r8)            bump output ptr
         j     &l.t01
&l.ix1   mvc   0(*-*,r8),1(r6)         copy mask text to output
.* drop string char
&l.d01   ds    0h                      drop string char
         clm   &qtr,&qtm,1(r6)         insert text?
         je    &l.d02
         la    r6,1(r6)                bump mask pos
         la    r4,1(r4)                bump string pos
         j     &l.t01
&l.d02   ds    0h                      drop till text
         llc   r0,1(,r6)               load quote
         la    r1,2(,r6)               -> after >'
         bal   r14,&l.msd              get text length in r15
         la    r1,2(,r6)               -> text (after >')
         la    r6,3(15,r6)             -> after >'text'
         bal   r14,&l.lst              locate text
         jne   &l.x04                  not found
         lr    r4,r1                   set string ptr
         j     &l.t01
.* copy block from string, char = *'text'
&l.b01   ds    0h                      copy block
         clm   &qtr,&qtm,1(r6)         quote?   (*')
         je    &l.b06
         cr    r4,r5                   anything in string left?
         jh    &l.x00                  nope                  2021-07-24
         sr    r5,r4                   remaining string
         ar    r5,r8                   test
         cr    r5,r9                   sufficient space?
         jh    &l.x03                  else quit
         sr    r5,r8                   restore r5
         cfi   r5,250
         jh    &l.b02                  large remaining
         ex    r5,&l.bx1               copy rest of string
         la    r8,1(r5,r8)             bump output ptr
         la    r6,1(,r6)               bump mask ptr
         j     &l.t01
&l.b02   ds    0h                      copy large block
         la    r5,1(,r5)               make real length
         lr    r2,r8                   -> output
         lr    r3,r5                   copy length
         lr    r14,r4                  -> input
         lr    r15,r5                  copy length
         mvcl  r2,r14                  do copy
         ar    r4,r5                   bump string ptr
         la    r6,1(,r6)               bump mask ptr
         ar    r8,r5                   adjust outupt cursor
         j     &l.t01
&l.b06   ds    0h                      copy block
         llc   r0,1(,r6)               load quote
         la    r1,2(,r6)               -> after *'
         bal   r14,&l.msd              get text length in r15
         bal   r14,&l.lst              locate text
         jne   &l.x04                  not found
         sr    r1,r4                   length of block before text
         ar    r1,r8                   test
         cr    r1,r9                    sufficient
         jh    &l.x03                     space
         sr    r1,r8                   restore r1
         bctr  r1,0
         ex    r1,&l.bx1
         la    r6,3(15,r6)             bump mask ptr after *'text'
         la    r4,1(r1,r4)             bump string ptr
         la    r8,1(r1,r8)             bump output ptr
         j     &l.t01
&l.bx1   mvc   0(*-*,r8),0(r4)         copy string block
.* questionmark, conditional blocks
&l.q01   ds    0h                      question if continue
         tm    8(r13),&cnds1           in section 1?
         jo    &l.q10                  go handle
         tm    8(r13),&cnds2           in section 2?
         jo    &l.q20                  go handle
.*       first question mark
.*       ni    8(r13),255-&cndsup      set suppression off
         sll   r11,1                   set suppression
         srl   r11,1                     off
         oi    8(r13),&cnds1           set section 1
         llc   r0,0(,r6)               load question mark
         clm   &msr,&msm,1(r6)         is it ?>text?
         jne   *+8                     nope
         la    r6,1(,r6)               yes, bump cursor -> >
         la    r1,1(,r6)               -> text
         bal   r14,&l.msd              get text length
         clm   &msr,&msm,0(r6)         is it >text?
         je    &l.q04                  yes, go locate
.*       test text at cursor
         la    r14,1(r15,r4)           space in
         cr    r14,r5                    in string
         jh    &l.x05                      for text?
         bctr  r15,0
         ex    r15,&l.qc1
         la    r6,3(r15,r6)            bump mask ptr
         je    &l.t01                  match
         o     r11,&l.zuo              set suppression on for sect1
         j     &l.t01                  not matched
&l.q04   ds    0h                      not found
.*       la    r1,1(,r6)               -> text?
         bal   r14,&l.lst              locate text in string
         la    r6,2(r15,r6)            bump mask ptr
         je    &l.t01                  found
.*       oi    8(r13),&cndsup          set suppression on for sect1
         o     r11,&l.zuo              set suppression on for sect1
         j     &l.t01
&l.qc1   clc   1(*-*,r6),0(r4)         compare text to string
&l.q10   ds    0h                      conditional section 1 end
         la    r6,1(,r6)               bump mask ptr
         ni    8(r13),255-&cnds1       switch to
         oi    8(r13),&cnds2             section 2
.*       tm    8(r13),&cndsup          is suppression on?
.*       jo    &l.q11                  yes
         ltr   r11,r11                 is suppression on?
         jm    &l.q11                  yes
.*       oi    8(r13),&cndsup          else set on
         o     r11,&l.zuo              else set suppression on
         j     &l.t01
&l.q11   sll   r11,1                   set suppression
         srl   r11,1                     off
         j     &l.t01
&l.q20   ds    0h                      conditional sections end
         la    r6,1(,r6)               bump mask ptr
         ni    8(r13),255-&cnds2       clear section id
.*       ni    8(r13),255-&cndsup      clear suppresssion flag
         sll   r11,1                   set suppression
         srl   r11,1                     off
         j     &l.t01
.* Describe mask text address and length
.* at entry: r1->text, r0 contains char in low-order byte
.* at exit : r1->text, r15=text length
&l.msd   ds    0h                      mask string describe
         lr    r15,r1
.* msd1  clm   &qtr,&qtm,0(r15)
&l.msd1  clm   r0,1,0(r15)
         je    &l.msd2
         la    r15,1(,r15)
         cr    r15,r7                  test for end of mask
         jnh   &l.msd1                 continue test
         j     &l.x02                  not good
&l.msd2  sr    r15,r1                  compute text length
         br    r14
.* Locate mask text in string
.* at entry: r1 -> mask text, r15 = text length, r4 -> string
.* returns: cc=eq / ne,  r1 -> text in string
.* note - uses r2 as work reg (r3 too, but that is saved in r0)
&l.lst   ds    0h
         lr    r0,r3
.*       la    r3,1(,r5)               -> string end
         la    r3,2(,r5)               -> string end
         sr    r3,r4                   remaining string
         sr    r3,r15                  minus text length
         bctr  r15,0                   machine length
         lr    r2,r1                   -> text
         lr    r1,r4                   -> string
&l.lst1  ex    r15,&l.lstx
         je    &l.lst2
         la    r1,1(,r1)               bump string ptr
         bct   r3,&l.lst1
         cli   &l.zuo,255              set 'ne'
&l.lst2  lr    r3,r0                   restore r3
         la    r15,1(,r15)             reinstate text length
         br    r14
&l.lstx  clc   0(*-*,r1),0(r2)         compare text to string
&l.mcl   dc    cl8'%*+-''?\'
&l.zuo   dc    a(x'80000000')          set upper to one
.* end
&l.rtn   br    r14
&l.x00   sr    r15,r15                 end of mask
         j     &l.xx
&l.x01   la    r15,1                   end of string
         j     &l.xx
&l.x02   la    r15,2                   mask error, i.e. missing quote
         j     &l.xx
&l.x03   la    r15,3                   output overflow
         j     &l.xx
&l.x04   la    r15,4                   text not found in string
         j     &l.xx
&l.x05   la    r15,5                   mask text overrun
         j     &l.xx
&l.xx    ds    0h                      end of string
         xc    8(4,r13),8(r13)         reset flag field
.*
         lr    r0,r8                   -> past end of output
         l     r1,24(,r13)             reload r1
         s     r0,16(,r1)              output length
         l     r14,12(,r13)
         return (2,12)
         drop  r12
         pop   using
         pop   print
         aif   ('&sl1' eq 'MODULE').x
&sloc    Loctr                         resume main
         ago   .t01                    continue macro
.* parmlist
.pl      anop
&mlbl    ds    8a
         mexit
.setmod  anop
&#STRBYMSK setb 1
         mexit
.x       Mend
         Macro
.*-
.* Compare 2 strings of possible unequal length using CLCL      STRMACS
.* instruction.
.*
.* Syntax
.*  STRCOMP (addr1,len1),(addr2,len2)
.*        addr      label, (reg), F.label
.*        len       value, (reg), F.label, default is len of addr
.*
.* Notes
.*  registes 0,1,14,15 are used by the macro
.*  if equal then compare lengths, the shorter is 'low'
.*-
&ml      StrComp
         gblc  &$setreglc
*strcomp
&ml      SETREG r14,&syslist(1,1)            address of string 1
         SETREG r15,&syslist(1,2),&$setreglc length of string 1
         SETREG r0,&syslist(2,1)             address of string 2
         SETREG r1,&syslist(2,2),&$setreglc  length of string 2
         clcl  r14,r0
         Mend
         Macro
.*-
.* Copy string                                                  STRMACS
.*
.* The generated code determines if the length is le or gt 255
.* and does MVC or MVCL accordingly.
.*
.* Syntax
.*  STRCOPY FROM=(addr,len),TO=(addr,len) Ý,LENREG|LR=lr¨
.*          ÝTESTTRUNC|TT=tt¨ ÝCM=copymode¨
.*   addr      label, (reg), F.label
.*   len       value, (reg), F.label, default is len of addr
.*   lr        register to save the length.
.*   tt        Y : test for truncation, see R15 setting below.
.*   copymode  L forces MVCL, trades a bit of speed for a shorter
.*             path length.
.*
.* Len values are optional, they defaults to the with of addr.
.* The smallet value will be used.
.*
.* Registers 14, 15, 0 and 1 are all used internally.
.*
.* Uses macro setreg to set values.
.*
.* R15
.*  0   normal rc
.*  1   truncation done if TESTTRUNC=Y
.*
.* Samples
.*     STRCOPY  from=target,to=(source,(r3))
.*
.* History
.*  2021-10-17 Add truncation check and copymode
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*-
&mlbl    StrCopy  &from=,&to=,&lenreg=,&lr=,&testtrunc=,&tt=,&cm=
         lclc  &l,&s,&lenr,&ttrunc,&fsz,&cmode
         gblc  &$setreglc
&l       setc  'zsc&sysndx'
&lenr    setc  '&lenreg.&lr'
&ttrunc  setc  Upper('&testtrunc.&tt '(1,1))
&cmode   setc  Upper('&cm')
.* setup address and length info
&mlbl    setreg r14,&from(1)
&fsz     setc  '&$setreglc'
         setreg r15,&from(2),&$setreglc
         aif   ('&ttrunc' ne 'Y').tt1n
         st    r15,20(,r13)         save source lenth
.tt1n    anop
         setreg r0,&to(1)
         setreg r1,&to(2),&$setreglc
.* beware of overflow
         cr    r1,r15               check target big enough
         jnl   *+6                  target size ok
         lr    r15,r1               overflow, use target length
         lr    r1,r15               eventually use the smaller value
         aif   (k'&lenr eq 0 and '&ttrunc' ne 'Y').lr1n
         st    r1,24(,r13)          save adjusted target length
.lr1n    anop
.* beware of zero length
         ltr   r15,r15              beware of zero length
         jz    &l.q
.* select method
         aif   ('&cmode' eq 'L').cml
         clfi  r15,256              if source length
         jh    &l.ml                  gt 256 then use movelong
         bctr  r15,0
         lr    r1,r0                copy target address
         ex    r15,&l.ms
         j     &l.q
&l.ms    mvc   0(*-*,r1),0(r14)
.cml     anop
&l.ml    mvcl  r0,r14
&l.q     ds    0h
.* test for trunctation, when final length lt l'source
         aif   ('&ttrunc' ne 'Y').tt2n
         sr    r15,r15              prep rc before trunc test
         clc   24(4,r13),20(r13)
         jnl   *+8
         la    r15,1
.tt2n    anop
.* copy length
         aif   (k'&lenr eq 0).lr2n
         l     &lenr,24(,r13)
.lr2n    anop
.* all done
.x       anop
         Mend
         Macro
.*-
.* STRC2D - convert hex value to readable (decimal)             STRMACS
.*
.* Syntax
.*  STRC2D FROM=(addr,len),TO=(addr,len)
.*        addr      label, (reg), F.label
.*        from-len  value 1-4, can be in (reg) or f.label
.*        to-len    value, (reg) or f.label. Default is from-len*3
.*
.* The  macro calls  an internally  generated subroutine.  This
.* shortens the code length  for multiple executions of STRC2D,
.* though adds a bit to the program complexity.
.*
.* Returns
.*  r0  = length of output if r15=0
.*  r15 = 0 if all ok, else 4
.*
.* Notes
.*  registes 0,1,14,15 are used by the macro
.*
.* History
.*  2022-06-19  Change $LA external macro call to SETREG.
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com
.*-
&mlbl    StrC2d &from=,&to=,&print=nogen
         gblb  &$strc2d
         gblc  &$SETREGLC
         lclc  &s,&l,&froml,&tol
&l       setc  'CD&sysndx'
.* call
         SETREG  r15,&from(1)
&froml   setc  '&$SETREGLC'
         SETREG  r0,&to(1)
&tol     setc  '&$SETREGLC'
         SETREG  r1,&from(2),&froml
         SETREG  r14,&to(2),0
         sll   r1,16
         ar    r1,r14
         l     r14,=v(zstrc2d)
         basr  r14,r14
         aif   (&$strc2d).x
&$strc2d setb  1
* module
         push  print
         print &print
&s       setc  '&sysloc'
ZSTRC2D  Amode 31
ZSTRC2D  Rmode any
ZSTRC2D  Csect
         stm   r14,r2,12(r13)
         basr  r2,0
         ahi   r2,-6
         push  using
         using zstrc2d,r2
.* get length mask
         l     r14,16(,r13)            from addr
         lh    r15,24(,r13)            from len
         cfi   r15,4
         jh    &l.e1
         sr    r1,r1                   not really necessary, but...
         ic    r1,&l.m-1(r15)          load mask
.* load source
         sr    r15,r15
         ex    r1,&l.i
         cvd   r15,60(,r13)
.* make decimal
         l     r14,20(,r13)            to addr
         lh    r15,26(,r13)            to len
         ltr   r15,r15                 to-len given?
         jnz   &l.b                    yes
         lh    r15,24(,r13)            use from-length
         mhi   r15,3                   *3
&l.b     lr    r0,r15                  save target size
         bctr  r15,0
         sll   r15,4
         ex    r15,&l.u
         srl   r15,4
         la    r15,0(r14,r15)
         oi    0(r15),x'f0'
         j     &l.x0
&l.m     dc    x'0103070F'             length masks
&l.i     icm   r15,0,0(r14)
&l.u     unpk  0(*-*,r14),60(8,r13)
&l.x0    sr    r15,r15
&l.x1    l     r14,12(,r13)
         l     r2,28(,r13)
         bsm   0,r14
&l.e1    la    r15,4
         j     &l.x1
         drop  r2
         pop   using
         pop   print
.* resume main
&s       Loctr                         resume main
.x       Mend
         Macro
.*-
.* Convert binary to decimal without leading zeros              STRMACS
.*
.* Syntax
.*  STRC2N FROM=(fromaddrÝ,length¨),TO=toaddr
.*        fromaddr  b.label, h.label, f.label or (reg)
.*        toaddr    label, (reg), x.label
.*        length    a number 1-4.
.*        See the SETREG macro for details.
.*
.* The macro calls an internally generated subroutine. This shortens
.* the code length for multiple executions of STRP2D, though adds a bit
.* to the program complexity.
.*
.* Returns
.*  r0  = length of output, either specified or computed
.*
.* Notes
.*  registes 0,1,14,15 are used by the macro.
.*  external macros STRP2N and SETREG are required.
.*
.* History
.*  2021-10-06 Initial
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*-
&mlbl    StrC2N &from=,&to=,&print=off
         lcla  &fl
         lclc  &fa
&fa      setc  '&from(1)'
         aif   ('&from(2)' eq '1').len1
         aif   ('&from(2)' eq '2').len2
         aif   ('&from(2)' eq '3').len3
         aif   ('&from(2)' eq '4').len4
         aif   (k'&from(2) ne 0).e1
         aif   ('&fa  '(2,1) eq '.' or '&fa'(1,1) eq '(').setreg
&fa      setc  '*.&fa'
.setreg  anop
         SETREG r1,&fa                addr
         ago   .cvd
.len1    anop
         llc   r1,&from(1)
         ago   .cvd
.len2    anop
         llh   r1,&from(1)
         ago   .cvd
.len3    anop
         sr    r1,r1
         icm   r1,7,&from(1)
         ago   .cvd
.len4    anop
         l     r1,&from(1)
         ago   .cvd
.cvd     cvd   r1,32(,r13)
         Strp2n from=(36(,r13),4),to=&to,print=&print
         mexit
.e1      mnote 8,'***bad 2nd parm'
.x       Mend
         MACRO
.*-
.* Convert bin to printable hex                                 STRMACS
.*
.* This routine  converts each byte from  an input area to  an output
.* area in dump  format, so that one byte in  input is represented by
.* two bytes in output.
.*
.* ex. input x'C1' output x'C3F1'
.*
.* Syntax
.*   STRC2X FROM=(addrÝ,length¨),TO=addrÝ,LEN=length¨Ý,CSECT=Y|n¨
.*        addr      label, (reg) or F.label
.*        length    value, (reg) or F.label. Default is length of addr
.*        LEN=      is an alternative to using 2nd operand of FROM=
.*        CSECT=N   will generate straight code, no subroutine call
.*        SETLEN=Y  set r0 = output length at termination if CSECT=Y
.*
.* If CSECT=Y then the macro calls an internally generated
.* subroutine. This shortens the code length for multiple
.* executions of STRC2B, though adds a bit to the program
.* complexity.
.*
.* Registers 14, 15, 0 and 1 are used in the macro proper
.*
.* Returns the output length in r0 if CSECT=Y
.*
.* Sample, converting 4 bytes of hex value
.*           StrC2X from=(xvalue,4),to=result
.*  xvalue   dc    x'2cabc1c94298f0f1fa'
.*  result   dc    cl(l'cvalue)' '
.*
.* Note, uses external macro SETREG
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com
.*-
&name    StrC2X &from=,&to=,&len=,&csect=Y,&setlen=Y
         lclc  &l,&s,&csct,&sloc
         gblb  &$STRC2X
         gblc  &$SETREGLC
&l       setc  'C2X&sysndx'
         aif   (k'&from eq 0).parmmiss
         aif   (k'&to eq 0).parmmiss
&csct    setc  upper('&csect')
         aif   ('&csct'(1,1) eq 'Y').csect1
.* setup for direct execution
         setreg r14,&from(1)
         setreg r15,&from(2),&len,&$SETREGLC
         setreg r1,&to
         ago   .go
.* setup for subroutine call
.csect1  anop
.*call
.*- make call to module
         setreg r15,&from(1)
         setreg r0,&from(2),&len,&$SETREGLC
         setreg r1,&to
         l     r14,=v(ZSTRC2X)
         basr  r14,r14
.* StrC2X as module
         aif   (&$STRC2X).x            already done
&$STRC2X setb  1
&sloc    setc  '&sysloc'
ZSTRC2X  Amode 31
ZSTRC2X  Rmode any
ZSTRC2X  CSECT
         stm   r14,r2,12(r13)
         basr  r2,0
         ahi   r2,-6
         push  using
         using ZSTRC2X,r2
.*setup
         lm    r14,r0,16(r13)          from-addr, from-len, to-addr
         lr    r1,r0                   to-addr to r1
.* this is where it happens
.go      anop
.* upper nibble
&l.a     llc   r0,0(r14)               insert byte in workreg
         srl   r0,4                    shift last four bit away
         ahi   r0,240
         cfi   r0,x'fa'                nibble gt 9?
         jl    *+8
         ahi   r0,-57                  then use C'A'-C'F'
         stc   r0,0(r1)
.* lower nibble
         llc   r0,0(r14)               insert byte in workreg
         sll   r0,28                   leave
         srl   r0,28                     lower nibble
         ahi   r0,240
         cfi   r0,x'fa'                nibble gt 9?
         jl    *+8
         ahi   r0,-57                  then use C'A'-C'F'
         stc   r0,1(r1)
.* next
         la    r1,2(,r1)
         la    r14,1(,r14)
         bct   r15,&l.a
         aif   ('&csct'(1,1) ne 'Y').x
.* end
         l     r0,20(,r13)
         sll   r0,1
         l     r14,12(r13)
         l     r2,28(r13)
         bsm   0,r14
         drop  r2
         pop   using
&sloc    Loctr                         resume main
         Mexit
.PARMMIS ANOP
         mnote 12,'Error, parameter(s) missing.'
         Mexit
.x       MEND
         Macro
         StrD2C &from=,&to=,&reg=
.*-
.* Convert decimal to binary                                    STRMACS
.*
.* Dynamic pack of zoned dec to packed dec.
.*  FROM may be a label or (address,length) dublet, both
.*  address and length can be a value or (reg).
.*  TO= and REG= are mutually exclusive.
.*  TO is a fullword.
.* Registers 14, 15 and 1 are used internally.
.* The active savearea is used as workarea.
.* Note, external macro SETREG is required.
.* Sample: StrD2C from=(num2+3,3),to=fw
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*-
         gblc  &$SETREGLC
         SETREG r14,&from(1)           address
         SETREG r15,&from(2),&$SETREGLC length
         la    r1,35(,r13)             ensure
         srl   r1,3                     doubleword
         sll   r1,3                      boundary
         bctr  r15,0
         ex    r15,*+8
         j     *+10
         pack  0(8,r1),0(*-*,r14)
         aif   (k'&reg gt 0).reg
         SETREG r14,&to                address
         cvb   r15,0(r1)
         stcm  r15,15,0(r14)
         mexit
.reg     cvb   &reg,0(r1)
         Mend
         Macro
         StrD2P &from=,&to=
.*-
.* Convert decimal to packed-dec                                STRMACS
.*
.* Dynamic pack of zoned dec to packed dec.
.*  Both from and TO may be a label or (address,length) dublet.
.*  Both address and length can be a value or (reg).
.* Note, external macro SETREG is required.
.* Sample: StrD2P from=(num2+3,3),to=(dw+3,5)
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*-
         gblc  &$SETREGLC
         SETREG r14,&to(1)             address
         SETREG r1,&to(2),&$SETREGLC   length
         SETREG r15,&from(1)           address
         SETREG r0,&from(2),&$SETREGLC length
         bctr  r0,0
         bctr  r1,0
         sll   r1,4
         ar    r1,r0
         ex    r1,*+8
         j     *+10
         pack  0(*-*,r14),0(*-*,r15)
         Mend
         Macro
.*-
.* Return length of string in r15                               STRMACS
.*
.* Syntax
.*  STRLEN DATA=(addr,len),LR=reg
.*  STRLEN STR=(addr,len),LR=reg
.*   reg  register to return length, default is R15
.*   len  default is length of addr
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com
.*-
&ml      StrLen &data=,&str=,&pad=c' ',&lr=r15
         gblc  &$setreglc
         SetReg r14,&data(1),&str(1)
         SetReg &lr,&data(2),&str(2),&$setreglc
         ar    &lr,r14
         bctr  &lr,0
         cli   0(&lr),&pad
         je    *-6
         cr    &lr,r14
.*       jh    *+10    changed 2019-11-07 to handle 1-byte string
         jnl   *+10
         sr    &lr,&lr                 null string
         j     *+10
         sr    &lr,r14
         la    &lr,1(,&lr)
         ltr   &lr,&lr
         Mend
         Macro
.*-
.* Locate character in string, or character not in string       STRMACS
.* Returns position in r1, r1=0 if not found
.*
.* Syntax
.*   STRLOCCH (addr,length),c1(,c2..,cn)
.*   STRLOCCH STR=(addr,length),RCHR=(rchlist),c1(,c2..,cn)
.*     length default is length of string.
.*     rchlist  a list of 1-4 characters, which can be indirectly
.*              located.
.*     see the SETREG macro for details of allowed formats.
.*
.* Sample
.*       la    r2,ch3
.*       StrLocCh str=str1,rchr=(ch1,(r2),=x'4b'),c'/'
.*       . . .
.*  ch1      ds    cl1
.*  ch2      ds    cl2
.*  ch3      ds    cl3
.*  ch4      ds    cl4
.*  str1     ds    cl50
.*
.* History
.*  2020-12-01  Created
.*  2021-12-20  Add STR=
.*  2024-08-09  Add RCHR=
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*-
&mlbl    STRLOCCH &r0=r0,&r1=r1,&check=y,&str=,&rchr=
         lcla  &pn
         lclb  &hasstr,&haschr
         lclc  &l,&s
         gblc  &$setreglc
&pn      seta  1
         aif   (n'&str gt 0).pnn
&pn      seta  2
.pnn     anop
         aif   (n'&syslist eq 0 and n'&str eq 0).err1
         aif   (n'&rchr gt 4).err2
&mlbl    ds    0h
.* setup r15 with relative dlms
         aif   (n'&rchr eq 0).rchr1n
&haschr  setb  1
         setreg r1,&rchr(1)
         icm   r15,1,0(r1)
         aif   (n'&rchr eq 1).rchr1n
         setreg r1,&rchr(2)
         icm   r15,2,0(r1)
         aif   (n'&rchr eq 2).rchr1n
         setreg r1,&rchr(3)
         icm   r15,4,0(r1)
         aif   (n'&rchr eq 3).rchr1n
         setreg r1,&rchr(4)
         icm   r15,8,0(r1)
.rchr1n  anop
.* end of relative dlms setup
         SETREG &r1,&str(1),&syslist(1,1)
         SETREG &r0,&str(2),&syslist(1,2),&$setreglc
&l       setc  'ZLC&sysndx'
&s       setc  Upper('&check ')
         aif   ('&s'(1,1) eq 'N').nxtlst
         clfi  &r0,1
         jl    &l.n
&l.g     ds    0h
         aif   (n'&syslist eq &pn-1).rchr2
&haschr  setb  1
.nxtlst  anop
         cli   0(&r1),&syslist(&pn)
         je    &l.x
&pn      seta  &pn+1
         aif   (&pn le n'&syslist).nxtlst
.* do relative dlms
.rchr2   anop
         aif   (n'&rchr eq 0).rchr2n
         clm   r15,1,0(&r1)
         je    &l.x
         aif   (n'&rchr eq 1).rchr2n
         clm   r15,2,0(&r1)
         je    &l.x
         aif   (n'&rchr eq 2).rchr2n
         clm   r15,4,0(&r1)
         je    &l.x
         aif   (n'&rchr eq 3).rchr2n
         clm   r15,8,0(&r1)
         je    &l.x
.rchr2n  anop
.* end of relative dlms setup
         la    &r1,1(,&r1)             bump ptr
         bct   &r0,&l.g                continue test
&l.n     sr    &r1,&r1                 no success
&l.x     ltr   r1,r1
         aif   (&haschr eq 0).err3
         mexit
.err1    mnote 8,'***Error missing parameter(s)'
         mexit
.err2    mnote 8,'***Error too many rchr operands'
         mexit
.err3    mnote 8,'***Error missing chrs'
         mexit
         Mend
         Macro
.*-
.* STRMAKE
.*
.* Build a string from literals, fields and conversions.        STRMACS
.*
.* Specific position and skips are also possible.
.*
.* Syntax
.*
.*  STRMAKE fld,.,pos,.,fld,REG=R14|posreg,LR=lenreg,PRINT=print
.*
.*    fld   (field,length,conversion,out-length)
.*          length, conversion and out-length are optional.
.*
.*          field          label, (reg), literal, f.address
.*          length         value, (reg), f|h|b.address
.*          conversion
.*            C2B          storage -> binary c'0' and c'1'
.*            CVD  | C2D   storage -> dec
.*                         in-length and out-length are reqd
.*            C2N          binary i.e. a(0023) -> c'23'
.*            CVDR | C2DR  register -> dec
.*                         out-length is required
.*            CVXD | C2X   hex-> dec, i.e. x'1A' -> c'F1C1'
.*            UNPK | P2D   packed dec i.e. x'0123C' -> c'0123'
.*            P2N          packed dec i.e. x'0023C' -> c'23'
.*            ST           store register asis (using STCM)
.*            STH          store half of register asis (using STCM)
.*                         out-length is required
.*          out-length     value, (reg), f|h|b.address
.*          pos            position in string
.*                         +n  skip n positions forward
.*                         -n  skip n positions backward
.*                         =n  position at n
.*                         =B  position at next blank
.*          .supported externals
.*           GETTIME external macro
.*            .DATEd     Date, d=Long or Short
.*            .TIMEt     Time, t=Long, Medium or Short
.*            .DTdt      d=f=Long or Short - default is S
.*                       T=f=Long, Medium or Short - default is M
.*
.*          :usersupplied externals
.*           you supply the macro, see the label .EXTRNL2 for details
.*
.*    posreg        register pointing to the end of the
.*                  generated string. Default is R14.
.*    lenreg        register set to length of string
.*    print         print macro option OFF or NOGEN.
.*
.* Registers 14, 15, 0 and 1 may be used internally as work regs, so
.* the 'reg' value should not be any of those.
.*
.* Conversion sub-functions typically uses the save are for storing
.* intermediate values, so a save area must be available.
.* History
.* 2020-12-06 change $LA to SETREG
.* 2022-05-13 add externals .DATEf, .TIMEf, .DTdt
.* 2022-05-16 add usersupplied externals support
.* 2022-05-25 use new STRC2B macro call
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*-
&mlbl    StrMake &reg=R14,&print=,&lenck=N,&lenreg=,&lr=
         aif   (k'&mlbl eq 0).mlbl2
&mlbl    ds    0h
.mlbl2   anop
         aif   (k'&print eq 0).pr1n
         push  print
         print &print
.pr1n    anop
         lcla  &pix,&litl,&incr,&n,&mvcn
         lclc  &str,&fld,&srcl,&cnv,&src,&srcu,&tgt,&tgtl,&s,&lbl,&outl
         lclc  &mask,&lb1,&r,&lm(4),&unpkadr,&strl
         gblc  strmakea,strmakel,&strp2dl,&$setreglc
&lm(1)   setc  '1'
&lm(2)   setc  '3'
&lm(3)   setc  '7'
&lm(4)   setc  '15'
.*
.* output string address
.*
&str     setc  '&syslist(1,1)'
         aif   ('&str' eq '*').setstrn
         aif   (k'&str eq 0).setstrn
         setreg &reg,&str              ->str
&strl    setc  '&syslist(1,2)'
         aif   (k'&strl ne 0).strl2
&strl    setc  'l''&str'
.strl2   anop
&strmakea setc '&str'                  remember address
&strmakel setc '&strl'                 remember length
.setstrn anop
.*-
.* do over parmlist
.*-
&pix     seta  1
.scan    anop
&lbl     setc  'SM&sysndx.#&pix'
&pix     seta  &pix+1
         aif   (&pix gt n'&syslist).quit
&src     setc  '&syslist(&pix,1)'
&srcu    setc  (UPPER '&src')
&srcl    setc  '&syslist(&pix,2)'
         aif   (k'&srcl ne 0).srcl2
&srcl    setc  'l''&src'
.srcl2   anop
&cnv     setc  (UPPER '&syslist(&pix,3)')
&outl    setc  '&syslist(&pix,4)'
.* junction 1
         aif   ('&src '(1,1) eq '.').extrnl1
         aif   ('&src '(1,1) eq ':').extrnl2
         aif   ('&src '(1,1) ne '=').tpositn
         aif   ('&src '(2,1) eq '(').posit     position in register
&n       seta  k'&src
&s       setc  '&src'(2,&n-1)
         aif   (t'&s eq 'N').posit
.tpositn anop
         aif   ('&srcu'(1,2) eq '=B').posbl
         aif   (T'&src eq 'N').posit
         aif   ('&src'(1,1) eq '+').skip
         aif   ('&src'(1,1) eq '-').skipb
.* the width check is not very good, but better than nothing
&s       setc  Upper('&lenck ')
         aif   ('&s'(1,1) ne 'Y' and n'&syslist(1) lt 2).lenckn
         setreg r15,&strmakea
         setreg r0,&strmakel
         ar    r15,r0
         setreg r0,&outl,&srcl
         ar    r0,&reg                    -> after insert
         cr    r0,r15
         jl    &lbl.s
         mvi   0(r14),c'+'
&s       setc  'SM&sysndx.Q'
         j     &s
&lbl.s   equ   *
.lenckn  anop
.* width check end
.* junction 2
         aif   ('&src '(1,1) eq '''').lit
         aif   (k'&cnv eq 0).mvc
         aif   ('&cnv' eq 'CVD').c2d      binary to decimal
         aif   ('&cnv' eq 'C2D').c2d              -
         aif   ('&cnv' eq 'C2N').c2n              -
         aif   ('&cnv' eq 'CVDR').cvdr    binary in reg to decimal
         aif   ('&cnv' eq 'C2DR').cvdr    binary in reg to decimal
         aif   ('&cnv' eq 'P2D').p2d      packed dec -> zoned
         aif   ('&cnv' eq 'P2N').p2n      packed dec -> zoned - zeros
         aif   ('&cnv' eq 'UNPK').p2d             -
         aif   ('&cnv' eq 'C2B').c2b      byte to readable bits
         aif   ('&cnv' eq 'C2X').c2x      hex to readable hex
         aif   ('&cnv' eq 'CVX').c2x              -
         aif   ('&cnv' eq 'CVXD').c2x             -
         aif   ('&cnv' eq 'ST').st        store register
         aif   ('&cnv' eq 'STH').sth      store register halfword
         mnote 8,'invalid format: &cnv'
         ago   .quit
.*-
.* src is a field
.* 'outl' is max length
.*-
.mvc     anop
         setreg r15,&srcl
         ltr   r15,r15
         jz    &lbl.N                        no data
         aif   (k'&outl eq 0).mvc2
         setreg r0,&outl
         ltr   r0,r0                         zsro => no check
         jz    &lbl.cf1
         cr    r15,r0
         jnh   &lbl.cf1
         lr    r15,r0
.mvc2    anop
&lbl.cf1 cfi   r15,256
         jh    &lbl.l                        long string
         bctr  r15,0
         setreg r1,&src
         mvc   0(*-*,&reg),0(r1)
         ex    r15,*-6
         la    &reg,1(r15,&reg)
         j     &lbl.n
&lbl.l   equ   *
         stm   r14,r15,12(r13)
         lr    r0,&reg                       -> target
         setreg r14,&src                     -> source
         lr    r1,r15                        copy length
         mvcl  r0,r14
         lm    r14,r15,12(r13)
         ar    &reg,r15
&lbl.n   equ   *
         ago   .scan
.*-
.* Convert hex value in register to decimal
.*-
.cvdr    anop                               source is register
         cvd   &src,16(r13)
         unpk  0(&outl,&reg),16(8,r13)
         oi    &outl-1(&reg),x'f0'
         la    &reg,&outl.(,&reg)
         ago   .scan
.*-
.* Convert hex in string to decimal
.*-
.c2d     anop
         st    &reg,68(,r13)               save pos
         lr    r0,&reg                     preserve r14
         StrC2d call,from=(&src,&srcl),to=((r0),&outl)
         l     &reg,68(,r13)               load pos
         ar    &reg,r0
         ago   .scan
.*-
.* Convert hex in string to decimal without leading zeros
.*-
.c2n     anop
         st    &reg,68(,r13)               save pos
         StrC2N from=&src,to=((&reg))
         l     &reg,68(,r13)               load pos
         ar    &reg,r0
         ago   .scan
.*-
.* packed dec field
.*-
.p2d     anop                              packed dec
         st    &reg,68(,r13)               save pos
         lr    r0,&reg
         StrP2D call,from=(&src,&srcl),to=((r0),&outl)
         l     &reg,68(,r13)               load pos
         ar    &reg,r0
         ago   .scan
.*-
.* packed dec field to zoned minus leading blanks
.*-
.p2n     anop                              packed dec
         st    &reg,68(,r13)               save pos
         StrP2N from=(&src,&srcl),to=((&reg))
         l     &reg,68(,r13)               load pos
         ar    &reg,r0
         ago   .scan
.*-
.* hex-to-char
.*-
.c2x     anop
         st    &reg,68(,r13)               save pos
.* preserve r14
         lr    r1,&reg                     to addr
.*  r14=from,r15=to,r0=len
         StrC2X call,from=(&src,&srcl),to=(r1),setlen=Y
         l     &reg,68(,r13)               load pos
         ar    &reg,r0                     update pos
         ago   .scan
.*-
.* byte to bits
.*-
.c2b     anop
         st    &reg,68(,r13)               save pos
.*       StrC2B call,from=&src,to=(&reg)
         StrC2B from=(&src,&srcl),to=(&reg),dlm=c'.'
         l     &reg,68(,r13)               load pos
.*       la    &reg,8(,&reg)
         ar    &reg,r0
         ago   .scan
.*-
.* literal
.*-
.lit     anop
         aif   (k'&src eq 3).lit100        one char
&litl    seta  k'&src-2
         mvc   0(&litl,&reg),=c&src
         la    &reg,&litl.(,&reg)
         ago   .scan
.lit100  anop
         mvi   0(&reg),c&src
         la    &reg,1(,&reg)
         ago   .scan
.*-
.* store register
.*-
.st      anop
         stcm  &src,15,0(&reg)
         la    &reg,4(,&reg)
         ago   .scan
.*-
.* store lower half of register
.*-
.sth     anop
         stcm  &src,3,0(&reg)
         la    &reg,2(,&reg)
         ago   .scan
.*-
.* skip
.*-
.skip    anop
&s       setc  '&src'(2,k'&src-1)
         ahi   &reg,&s
         ago   .scan
.skipb   anop
&s       setc  '&src'(2,k'&src-1)
         ahi   &reg,-&s
         ago   .scan
.*-
.* position pointer in string
.*-
.posit   anop
&c       setc  '&src'(2,k'&src-1)
.*       la    &reg,&strmakea+&c-1
         setreg &reg,&strmakea
         setreg r15,&c
         bctr  r15,0
         ar    &reg,r15
         ago   .scan
.*-
.* position at next blank
.*-
.posbl   anop
         cli   0(&reg.),c' '
         bne   *+8
         bct   &reg.,*-8
         la    &reg.,1(,&reg.)
         ago   .scan
.*-
.* known externals
.*-
.extrnl1 anop
         aif   ('&srcu     '(2,4) eq 'DATE').x1date
         aif   ('&srcu     '(2,4) eq 'TIME').x1time
         aif   ('&srcu     '(2,2) eq 'DT').x1dt
         mnote 8,'Invalid builtin &srcu'
         ago   .x
.x1date  anop
&p1      setc  '&srcu       '(6,1)
&p2      setc  'N'
         ago   .x1dt3
.x1time  anop
&p1      setc  'N'
&p2      setc  '&srcu       '(6,1)
         ago   .x1dt3
.x1dt    anop
&p1      setc  '&srcu       '(4,1)
&p2      setc  '&srcu       '(5,1)
.x1dt1   aif   ('&p1' ne ' ').x1dt2
&p1      setc  'S'
.x1dt2   aif   ('&p2' ne ' ').x1dt3
&p2      setc  'M'
.x1dt3   GetTime (&reg),date=&p1,time=&p2
         lr    &reg.,r1
         ar    &reg.,r0
         ago   .scan
.*-
.* user supplied externals
.* before call
.*  r1  string address
.* after call
.*  r1  updated string address
.*-
.extrnl2 anop
         lr    r1,&reg
&n       seta  k'&srcu-1
&s       setc  '&srcu'(2,&n)
         &s    &syslist(&pix,2),&syslist(&pix,3),&syslist(&pix,4)
         lr    &reg.,r1
         ago   .scan
.*-
.* end of macro
.*-
.quit    anop
&r       setc  '&lenreg&lr'
         aif   (k'&r eq 0).lenregn
         setreg r0,&strmakea
.*       sr    r14,r0
.*       lr    r0,r14                    copy gend length
         lr    &r,r14
         sr    &r,r0                     set length
.lenregn anop
         aif   (k'&print eq 0).pr2n
         pop  print
.pr2n    anop
&s       setc  'SM&sysndx.Q'
&s       ds    0h
         Mend
         Macro
.*-
.*
.*  Parse a string into separate fields.
.*
.*  Syntax
.*    StrParse (stringaddr,stringlength),
.*             (keyword,area,F=format-verify,C=convert,A=abbrev,
.*             I=init-value,q=quote),
.*             INIT=i,PP=pp,LINK=llll
.*          keyword: verb, will be capped internally
.*          area   : address of a StrParse DC/DS macro
.*          verify : A alphanum, letters and numbers
.*                   C char, only letters
.*                   N only numbers
.*          format : B convert to binary, forces length=4
.*                   P packed binary
.*                   U uppercase string
.*          'verify' and 'format' can be entered in any case
.*          'verify' and 'format' are only honored if INIT=Y
.*          quote    K keep. default is to drop quotes.
.*      . . .
.*      BUILD=Y      Stack internal list for 'AREA' call.
.*      INIT=Y       Initialize area covered by a
.*                   StrParse DC/DS macro. only the first byte
.*                   of the area is initialized.
.*      PP=cc        positional value prefix
.*      link=CALL|link   'call' generates internal
.*      AREA         Build 'DS' list from internal stack.
.*                   Must be the only parameter, otherwise assumed
.*                   to be string name.
.*
.* Define area
.* areaname StrParse DC|ds,size,format=.convert=
.*          verify and format see above. Only honored for DC.
.*          if size F then force full-word, format N and convert B
.*
.*          StrParse area expansion:
.*             areaname_fl ds  al1  field length
.*             areaname_dl ds  al1  data length
.*             areaname dc|ds  &type&value
.*
.* Notes:
.*  If the same parameter is entered multiple times then the last
.*  entry is use.
.*  An entry can be use multiple times, i.e.:
.*               StrParse (workrec,l'workrec),
.*    -  -  -  -  -  -  -  -  -  -  -  -  -  -
.*                   (msg,msg1),
.*                   (msg,msg2),
.*    -  -  -  -  -  -  -  -  -  -  -  -  -  -
.*    msg1     StrParse dc,12,v=z,c=z
.*    msg2     StrParse dc,12,v=z,c=z
.*  if msg(something) is entered more than twice, then the 'msg2'
.*  field is overwritten.
.*  If a field may be quoted then the field length must include those,
.*  i.e. use l=3 for a field like DLM(',') - even though only the value
.*  is stored and the length is set to 1.
.*
.* Updates
.*  2019-09-05 Add Q= option, include XLA subroutine
.*  2019-09-30 Add amode and rmode to all internal csects
.*  2020-10-27 Fix v=n validation issue (not called)
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*
.*-
&lbl     StrParse &value=,&init=N,&link=CALL,&trace=,&msg=0,           c
               &v=Z,&c=Z,&l=N,&i=,&q=z,&pp=--,&area=N,&build=N,&align=
         gblb  &strparsmodule,&strparsdsect
         gbla  &strparsn
         gblc  &strparsl(100),&strparsk(100),&strparst(100)
         gblc  &strparsf(100),&strparsc(100),&strparsq(100)
         gblc  &strparsalign
         lcla  &n,&l1,&l2,&flgs,&sln,&ofs,&oln,&setinil
         lclc  &name,&data,&type,&req,&opt,&optu,&optd,&lb1
         lclc  &thissect,&sect,&s,&s1,&s2,&s3
         lclc  &pl,&pvfy,&pcnv,&pabr,&plst
         lclc  &plen,&pinit,&trn,&setini,&palign,&pqopt
.* xla sub
         gblc  &xlalen
&s       setc  Upper('&syslist(1)')
         aif   ('&s' eq 'XLA').xla
.*
         aif   (k'&align eq 0).palignn
&strparsalign  setc  (UPPER '&align')
.palignn anop
.*       mnote *,'align=&strparsalign'

&pinit   setc  (UPPER '&init')
&s3      setc  (UPPER '&build')
         aif   ('&s3' ne 'Y').pbuildn
&pinit   setc  'Y'
.pbuildn anop
&s3      setc  (UPPER '&syslist(1)')
         aif   ('&s3' eq 'AREA' and n'&syslist eq 1).area
         aif   ('&s3' eq 'DS').ds
         aif   ('&s3' eq 'DC').dc
&thissect setc '&sysect'
.*       mnote *,'thissect: &thissect'
.* preserve ltorg'd fields
&lb1     setc  'zps&sysndx.a'
         b     &lb1
         ltorg
&lb1     ds    0h
         call  ZPS&sysndx.M
.*
*----------- build keyword table --------------
         aif   (&strparsdsect ne 0).dsectn
*PS2D1 keyword list area
PS2D1    Dsect
PS2D1eye ds    cl8                    eyecatcher
PS2D1siz ds    a                      total size of obtained area
PS2D1sa1 ds    18a                    save area
PS2D1sa2 ds    18a                    save area
PS2D1bln ds    cl120                  blank area
PS2D1fw  ds    f                      work area
PS2D1dw  ds    d                      work area
PS2D1wrk ds    xl256                  work area
PS2D1sta ds    a                      string address
PS2D1stl ds    a                      string length
PS2D1stp ds    a                      string position
PS2D1vpb ds    a                      verb portion begin
PS2D1vpe ds    a                      verb portion end
PS2D1dpb ds    a                      data portion begin
PS2D1dpe ds    a                      data portion end
PS2D1msg ds    a                      -> message buffer (cl100)
PS2D1num ds    a                      number of named operands in list
PS2D1d2a ds    a                      -> data (work)
PS2D1pp  ds    cl2                    Positional prefix
PS2D1pn  ds    al1                    Positional count
         ds    xl1                    future use
PS2D1lst ds    0x                     start of named operand list
PS2D1pfl equ   *-PS2D1                size of area prefix
.*
*PS2D2 keyword list entry
PS2D2    Dsect ,                      keyword list
PS2D2nam ds    a                      address of name
PS2D2opt ds    x                      options
PS2D2use equ   x'80'                  in use
         ds    x                      future
PS2D2len ds    al1                    verb length
PS2D2abr ds    al1                    verb abbreviation
PS2D2d3a ds    a                      address of data definition
PS2D2nxt ds    0x                     next entry
.*
*PS2D3 data entry
PS2D3    Dsect ,                      data entry
PS2D3opt ds    x                      future
.*2D3use equ   x'80'                  in use
PS2D3vfc equ   128                    verify is char
PS2D3vfn equ   64                     verify is num
PS2D3vfa equ   128+64                 verify is alpha-num
PS2D3vfz equ   0                      null
PS2D3qok equ   32                     quote opt - keep quotes
PS2D3qoz equ   0                                - drop quotes
PS2D3cvu equ   8                      convert to upcase chars
PS2D3cvp equ   4                      convert to packed decimal
PS2D3cvb equ   2                      convert to binary
PS2D3lst equ   1                      data is a list
PS2D3cvz equ   0                      null
PS2D3fl  ds    x                      field length
PS2D3dl  ds    x                      data length
PS2D3dat ds    0c                     data
.dsectn  anop
&sect    setc  'ZPS&sysndx.M'
.* &sect $$modes
&sect    amode 31
&sect    rmode any
&sect    csect
         bakr  14,0
         lr    r5,r15
         using &sect,r5
         using PS2D1,r6
&sln     seta  12*n'&syslist
 mnote *,'storage obtain sz &sln'
         STORAGE OBTAIN,LENGTH=PS2D1pfl+&sln,LOC=31
         lr    r6,r1
         mvc   PS2D1eye,=cl8'&sect'    eyecatcher
         mvc   PS2D1siz,=a(PS2D1pfl+&sln) obtained area size
         STRPARSE XLA,r1,&msg
         st    r1,PS2D1msg
.*       STRPARSE XLA,r1,&unsol
.*       st    r1,PS2D1uos
&s       setc  (Upper '&pp')
         mvc   PS2D1pp,=cl2'&s'        positional var prefix
         mvi   PS2D1pn,0               positional number
         aif   (n'&syslist(1) ne 2).strerr1
         STRPARSE XLA,r14,&syslist(1,1) string address
         STRPARSE XLA,r15,&syslist(1,2) string length
         stm   r14,r15,PS2D1sta
         st    r14,PS2D1stp            save start pos
&sln     seta  n'&syslist-1
         mvc   PS2D1num,=a(&sln)       number of named operands
.*
&sln     seta 2
         la    r7,PS2D1lst
         la    r13,PS2D1sa1
.*--
.pars100 anop
&name    setc  Upper('&syslist(&sln,1)')
&data    setc  'name'
         aif   (n'&syslist(&sln) eq 1).pars200
&data    setc  '&syslist(&sln,2)'
.pars200 anop
&trn     setc  'CALL'
&oln     seta  2                     past name and dataaddres
         ago   .opt2
.callopt anop
&l1      seta  k'&name
         la    r2,=c'&name'
         lh    r3,=y((256*&l1)+&pabr) verb length, abbrev
         la    r4,&data._op
         stm   r2,r4,0(r7)
         aif   ('&pinit' ne 'Y').pars300
         mnote *,'do init'
         aif   ('&plst' eq 'Y').pars220
         aif   ('&plen' eq '?').pars210
&s3      setc  '&plen'
         aif   ('&plen' eq 'F').pars205
&s1      setc  'PS2D3vf&pvfy+PS2D3cv&pcnv+PS2D3qo&pqopt'
         mvc   &data._op(4),=al1(&s1,&s3,0,c' ')
         ago   .pars206
.pars205 mvc   &data._op(4),=al1(PS2D3vf&pvfy+PS2D3cv&pcnv,4,0,0)
.pars206 anop
&strparsn seta &strparsn+1
&strparsl(&strparsn) setc '&data'
&strparst(&strparsn) setc 'C'
&strparsk(&strparsn) setc '&plen'
&strparsf(&strparsn) setc '&pvfy'
&strparsc(&strparsn) setc '&pcnv'
&strparsq(&strparsn) setc '&pqopt'
         ago   .pars300
.pars210 anop
&s1      setc  'PS2D3vf&pvfy+PS2D3cv&pcnv+PS2D3qo&pqopt'
         mvc   &data._op(4),=al1(&s1,l'&data,0,c' ')
         ago   .pars300
.pars220 anop  ,                       list
&s1      setc  'PS2D3vf&pvfy+PS2D3cv&pcnv+PS2D3lst+PS2D3qo&pqopt'
         mvc   &data._op(4),=al1(&s1,0),y(l'&data)
.pars300 anop
         aif   (&setinil eq 0).pars400
         aif   ('&pcnv' eq 'P').pars310
         aif   ('&pcnv' eq 'B').pars320
&setinil seta  &setinil-2
         mvi   &data._dl,&setinil
         mvc   &data.(&setinil),=c&setini
         ago   .pars400
.pars310 anop  ,                       packed dec
         mvi   &data._dl,l'&data       full field
         zap   &data,=p'&setini'       set value
         ago   .pars400
.pars320 anop  ,                       binary
         mvi   &data._dl,4
         mvc   &data,=al4(&setini)
.pars400 anop
         la    r7,PS2D2nxt-PS2D2(,r7)
&sln     seta  &sln+1
         aif   (&sln le n'&syslist).pars100
* Call parser
         lr    r1,r6
         Call  STRPARS2
         lr    r2,r15                 save rc
         l     r3,PS2D1siz
         STORAGE RELEASE,LENGTH=(3),ADDR=(6)
         lr    r15,r2
         pr
         ltorg
         drop  r5,r6
.*-
         aif   (&strparsmodule).modulen
         push  using
.*-
.*       Module
.*-
&strparsmodule setb 1
*
*-
*        Parser
*-
         USING PS2D1,r10
         USING STRPARS2,r11        ESTABLISH ADDRESSABILITY
 aif ('&trace' eq '').trc0n
         USING &thissect,r12
.trc0n anop
.* SCN02 $$modes
STRPARS2 amode 31
STRPARS2 rmode any
STRPARS2 Csect
         save  (14,12)             save caller's status on stack
         lr    r11,r15             set up a base register
         lr    r10,r1              -> Keylist setup dynamic area
         la    r14,PS2D1sa2
         st    r14,8(,r13)
         st    r13,4(,r14)
         lr    r13,r14
         l     r7,PS2D1sta         string address
         l     r6,PS2D1stl         string length
         xc    PS2D1wrk,PS2D1wrk
         clear PS2D1bln
         ar    r6,r7               -> 1 past string
         bctr  r6,0                -> last byte of string
         la    r9,PS2D1lst         -> keyword table

 aif ('&trace' eq '').trc1n
      lr    r14,r6
      sr    r14,r7
      bctr  r14,0
      sh    r14,=h'18'
      mvc   logr+18(*-*),0(r7)
      ex    r14,*-6
      la    r14,1(,r14)
      $cvd  r14,logr+12,len=4
      log   'str:'
.trc1n anop

*locate start of kw (1st non-blank)
ps2slkw0 equ   *
         l     r7,PS2D1stp           load position
ps2slkw1 equ   *
         cr    r7,r6                 end of string?
         bh    ps2send               yes, end
         cli   0(r7),c' '            look for non-blank
         bne   ps2slkw2              got it
         la    r7,1(,r7)
         b     ps2slkw1
*locate end of keyword
ps2slkw2 equ   *
         st    r7,PS2D1vpb           save verb start
         la    r4,1(r7)
ps2slkw3 equ   *                     look for '('
         cli   0(r4),c'('            look for '('
         be    ps2slkwend            got it
         cli   0(r4),c' '            positional
         be    ps2slkwend            got it
         la    r4,1(,r4)
         cr    r4,r6                 end of string?
         bnh   ps2slkw3
ps2slkwend equ *                     start and end of kw found
         st    r4,PS2D1vpe           save verb end
         st    r4,PS2D1stp           update position
         sr    r4,r7                 length of keyword
.*       lr    r15,r5                copy length dropped 2017-02-25
         lr    r15,r4                copy length
         bctr  r15,0                 mch length
         mvc   PS2D1wrk+2(*-*),0(r7)   copy verb
         ex    r15,*-6
         oc    PS2D1wrk+2(l'PS2D1bln),PS2D1bln  uppercase
         xc    PS2D1d2a,PS2D1d2a
 aif ('&trace' eq '').trc2n
      mvlit logr,'kw:'
      lr    r14,r4
      bctr  r14,0
      mvc   logr+12(*-*),0(r7)
      ex    r14,*-6
      log
.trc2n anop

*find the entry in the keyword table
*r7 ->start of keyword, r4=length
         Using PS2D2,r5
         la    r5,PS2D1lst           ->table
         l     r8,PS2D1num           number of entries
         sr    r2,r2
ps2slkwt1 equ *
         lb    r2,PS2D2len           load length
         l     r3,PS2D2nam           ->keyword
 aif ('&trace' eq '').trc3n
     lb    r14,PS2D2len
     bctr  r14,0
     mvc   logr+12(*-*),0(r3)
     ex    r14,*-6
     log   'kwt entry:'
.trc3n anop
         cli   PS2D2abr,0            abbreviation allowed?
         be    ps2snabr              nope
 aif ('&trace' eq '').trc31n
     log   'test abr'
.trc31n anop
         clm   r4,1,PS2D2len         check length
         bh    ps2slkwt2             verb len gt max
         clm   r4,1,PS2D2abr         check abbrev length
         bl    ps2slkwt2             verb len lt abbrev
         lr    r2,r4                 copy verb
ps2snabr equ   *
         cr    r4,r2                 check length
         bne   ps2slkwt2             no, try next
ps2stvrb equ   *
         bctr  r2,0
.*       clc   0(*-*,r7),0(r3)
         clc   PS2D1wrk+2(*-*),0(r3)
         ex    r2,*-6
         be    ps2slkwt3             gotit
ps2slkwt2 equ *
         la    r5,PS2D2nxt           ->next entry
         bct   r8,ps2slkwt1          if any left
         icm   r14,15,PS2D1d2a       is
         bz    ps2slkwt2a              there
         lr    r5,r14                    a previous
         b     ps2slkwt3a                  entry we can use?
ps2slkwt2a equ *
         l     r1,PS2D1vpe
         cli   0(r1),c'('            has data?
         be    ps2serr2              yup, not positional
         cli   PS2D1pp,c'-'          positional ?
         bne   ps2spp                yes, go check
         b     ps2serr2              else not found
ps2slkwt3 equ *
         st    r5,PS2D1d2a           save
.* if entry has been used already then ignore
         l     r14,PS2D2d3a          -> data
         cli   PS2D3dl-PS2D3(r14),0  test data length
         bne   ps2slkwt2             not zero, then already used
.* -
ps2slkwt3a equ *
 aif ('&trace' eq '').trc4n
     mvc   logr+12(*-*),0(r3)
     ex    r2,*-6
     log   'kw valid:'
.trc4n anop
.*       oi    PS2D2opt,PS2D2use     set 'keyword found'
.*       l     r15,PS2D2d3a          ->data section
.*       using PS2D3,r15
.*       tm    PS2D3opt,PS2D3use     already used?
.*       bo    ps2serr3              yep, error
.*       oi    PS2D3opt,PS2D3use     mark it in use
.*       drop  r15

*-------------describe parmdata---------------------------
         la    r7,0(r4,r7)           -> past kw
         cli   0(r7),c'('            type of delimiter
         be    ps2sld1               go get data
 aif ('&trace' eq '').trc51n
      log   'no data'
.trc51n anop
         l     r14,PS2D2d3a          -> data
         mvi   PS2D3dl-PS2D3(r14),1  set data length
         mvi   PS2D3dat-PS2D3(r14),c'Y' default value
         b     ps2slkw0              next
ps2sld1  equ    *
         sr    r8,r8                 keep count of sub-parms
*find start of data
.*       cli   pskdmaxl,0            keyword only?
.*       be    ps2serr4              then error
 aif ('&trace' eq '').trc5n
      log   'has data'
.trc5n anop
         la    r7,1(,r7)             bump ptr
         cr    r7,r6                 past end of string?
         bh    ps2serr1              end-of-data missing
         cli   0(r7),c' '
         be    ps2sld1
         st    r7,PS2D1dpb           save address of data

*find end of data
 aif ('&trace' eq '').trc6n
      mvc   logr+12(8),0(r7)
      log   'data start:'
.trc6n anop
         lr    r4,r7                 ->data
ps2sld2 equ    *
         cr    r4,r6                 past end of string?
         bh    ps2serr1              error
         cli   0(r4),c')'            end of parm?
         be    ps2sld3
         cli   0(r4),c'('            start of sub-parm?
         bne   *+8                   nope
         la    r8,1(,r8)             indicate
         la    r4,1(,r4)
         b     ps2sld2
ps2sld3 equ    *
         ltr   r8,r8                 end of all (sub-)parms?
         bz    ps2sld3a              yes
         bctr  r8,0                  else subtract one
         la    r4,1(,r4)
         b     ps2sld2               and continue
ps2sld3a equ   *
         st    r4,PS2D1dpe           save address of data end
 aif ('&trace' eq '').trc7n
      mvc   logr+12(8),0(r4)
      log   'data end:'
.trc7n anop
         la    r14,1(,r4)
         st    r14,PS2D1stp          update position
*locate last non-blank of data
         lr    r2,r4
ps2sld4 equ    *
         bctr  r2,0
         cli   0(r2),c' '
         be    ps2sld4
ps2sld5  equ    *
         cr    r2,r7                null string?
         bl    ps2sldend            yes
         la    r2,1(,r2)            past end
         sr    r2,r7                length of data
 aif ('&trace' eq '').trc81n
      mvlit logr,'datalen:'
      $cvd  r2,logr+12,len=4
      mvlit logr+18,'fldl'
      l     r14,PS2D2d3a         -> data structure
      sr    r14,r14
      ic    r14,PS2D3fl-PS2D3(,r14) field length
      $cvd  r14,logr+24,len=4
      log   ,
.trc81n anop
         l     r14,PS2D2d3a         -> data
         tm    PS2D3opt-PS2D3(r14),PS2D3cvb  if convert to bin
         bo    ps2scfl9             then bypass this check
         lr    r1,r14
         sr    r14,r14
         ic    r14,PS2D3fl-PS2D3(,r1)  load field length
         cr    r2,r14               test size, r2=dl r14=fl
         bnh   ps2scfl9             ok
* error 5 : data too wide
* dc h'0'
         la    r15,5                set rc
         icm   r1,15,PS2D1msg
         bz    ps2sendx             no message area
*                             ----+----1----+----2----+----3----+----4
         mvc   0(20,r1),=cl20'0005 Datalength at'
         mvc   20(8,r1),0(r7)
         la    r1,30(,r1)
.*       $cvd  r2,19(r1),len=4
         mvc   0(2,r1),=c'dl'
         cvd   r2,PS2D1dw
         unpk  3(8,r1),PS2D1dw+4(4)
         oi    3+8-1(r1),x'f0'
         la    r1,12(,r1)
.*       $cvd  r14,27(r1),len=4
         mvc   0(2,r1),=c'fl'
         cvd   r14,PS2D1dw
         unpk  3(8,r1),PS2D1dw+4(4)
         oi    3+8-1(r1),x'f0'
         b     ps2sendx             too big
ps2scfl9 equ   *
         l     r4,PS2D2d3a
         using PS2D3,r4
         stc   r2,PS2D3dl           save data length
         bctr  r2,0
* verify data contents ?
         tm    PS2D3opt,x'f0'      test format?
         bz    ps2svf9             nope
         tm    PS2D3opt,PS2D3vfa   test for alphanum?
         bno   ps2svfa9            else go check next
         la    r3,=c'A'
         ex    r2,ps2svfax
         bz    ps2svf9             ok
         b     ps2serr6
ps2svfax trt   0(*-*,r7),ps2svfat
ps2svfa9 equ   *
         tm    PS2D3opt,PS2D3vfc   test for char
         bno   ps2svfc9            else go check num
         la    r3,=c'C'
         ex    r2,ps2svfcx
         bz    ps2svf9             ok
         b     ps2serr6
ps2svfcx trt   0(*-*,r7),ps2svfct
ps2svfc9 equ   *
         tm    PS2D3opt,PS2D3vfn   test for numerics
         bno   ps2svfn9            nope
         la    r3,=c'N'
         ex    r2,ps2svfnx
         bz    ps2svfn9             ok
         b     ps2serr6
ps2svfnx trt   0(*-*,r7),ps2svfnt
ps2svfn9 equ   *
ps2svf9  equ   *
* convert data ?
         lm    r14,r15,PS2D1dpb    start and end of data
         sr    r15,r14             length
         bctr  r15,0               machine length
         l     r2,PS2D2d3a         -> target structure
         tm    PS2D3opt,PS2D3cvp   packed decimal ?
         bo    ps2scvp             go do
         tm    PS2D3opt,PS2D3cvb   binary ?
         bo    ps2scvb             go do
.* convert: move
         tm    PS2D3opt,PS2D3qok   keep quotes?
         jo    ps2scpy             yes
         cli   0(r14),c''''        quoted??
         bne   ps2scpy
         llc   r0,PS2D3dl          adjust
         ahi   r0,-2                 data
         stc   r0,PS2D3dl              length
         la    r14,1(,r14)
         bctr  r15,0
         bctr  r15,0
ps2scpy  ex    r15,ps2scvmx        else just move
         tm    PS2D3opt,PS2D3cvu   uppercase?
         bz    ps2scv9             nope
         ex    r15,ps2scvux        then upcase
         b     ps2scv9             and exit
ps2scvmx mvc   PS2D3dat(*-*),0(r14)
ps2scvux oc    PS2D3dat(*-*),PS2D1bln
ps2scvm9 equ   *
.* convert: binary
ps2scvb  cli   PS2D3fl,4           target better be ge 4
         bl    ps2serr7
         ex    r15,ps2scvbx        pack to work area
         cvb   r1,PS2D1dw          to binary
         stcm  r1,15,PS2D3dat      and store
         mvi   PS2D3dl,4           force length 4
 aif ('&trace' eq '').trccvbn
         mvc   PS2D1wrk(4),PS2D3dat
         cvxd  in=PS2D1wrk,out=logr+12,len=4
         log   'bindata:'
.trccvbn anop
         b     ps2scv9
ps2scvbx pack  PS2D1dw,0(*-*,r14)
.* convert: packed decimal
ps2scvp  lr    r3,r15              copy mch length
         sll   r3,4                move up one nibble
         or    r3,r15              copy mch length to low nibble
         ex    r3,ps2scvpx         pack to work area
         b     ps2scv9
ps2scvpx pack  PS2D3dat(*-*),0(*-*,r14)
ps2scvp9 equ   *
.*
ps2scv9  equ   *
ps2svcn  equ   *
 aif ('&trace' eq '').trc8n
      tm    PS2D3opt,PS2D3cvb   binary ?
      bo    trc8n               already done
      mvc   logr+18(*-*),PS2D3dat
      ex    r2,*-6
      la    r15,1(,r2)
      $cvd  r15,logr+12,len=4
      log   'data:'
trc8n equ   *
.trc8n anop
         drop  r4

ps2sldend equ *
         l     r1,PS2D1stp          load last pos
         la    r1,1(,r1)            bump ')'
         l     r1,PS2D1stp          update last pos
         b     ps2slkw0             get next
*-
* positional value support
*-
ps2spp   cnop  0,4
 aif ('&trace' eq '').trcpp1n
      mvlit logr,'positional value support'
      lr    r14,r4
      bctr  r14,0
      mvc   logr+26(2),PS2D1pp
      mvc   logr+30(*-*),0(r7)
      ex    r14,*-6
      log   ,
.trcpp1n anop
*find the entry in the keyword table
*r7 ->start of keyword, r4=length
         la    r5,PS2D1lst           ->table
         l     r8,PS2D1num           number of entries
ps2spptn equ   *
         l     r3,PS2D2nam           -> name
 aif ('&trace' eq '').trcpp2n
      mvlit logr,'name'
      lb    r14,PS2D2len
      bctr  r14,0
      mvc   logr+6(*-*),0(r3)
      ex    r14,*-6
      log   ,
.trcpp2n anop
         clc   PS2D1pp,0(r3)
         bne   ps2sppnx              not positional
         l     r14,PS2D2d3a          -> data area
         Using PS2D3,r14
         cli   PS2D3dl,0
         bne   ps2sppnx              occupied
         sr    r2,r2
         ic    r2,PS2D3fl
         cr    r4,r2
         bh    ps2spper
         stc   r4,PS2D3dl            save length
         bctr  r4,0
         mvc   PS2D3dat(*-*),0(r7)
         ex    r4,*-6
.* upcase positional parm
         tm    PS2D3opt,PS2D3cvu     uppercase?
         bz    *+14                  nope
         oc    PS2D3dat(*-*),PS2D1bln
         ex    r4,*-6                then upcase
 aif ('&trace' eq '').trcpp3n
      log   'positional value added'
.trcpp3n anop
         la    r7,2(r4,r7)
         st    r7,PS2D1stp           save position
         b     ps2slkw0
         drop  r14
ps2sppnx la    r5,PS2D2nxt           -> next entry
         bct   r8,ps2spptn           if any left
.* no free entries
ps2spper la    r15,8
         icm   r14,15,PS2D1msg
         bz    ps2sendx             no message area
         mvc   0(30,r14),=cl30'Positional values exhausted'
         b     ps2sendx             get back

         Macro
&lbl     PS2MSG &rc,&txt
         lcla  &l
&l       seta  (k'&txt)-2
&lbl     la    r15,&rc
         icm   r14,15,PS2D1msg
         bz    ps2sendx             no message area
         mvc   0(&l,r14),=c&txt
         b     ps2sendx             get back
         Mend

         Macro
         ISMSG &rc
         la    r15,&rc
         icm   r14,15,PS2D1msg
         bz    ps2sendx             no message area
         Mend

         Macro
&lbl     PS2MSGKW &rc,&txt
         lcla  &l
&l       seta  (k'&txt)-2
&lbl     la    r15,&rc
         icm   r14,15,PS2D1msg
         bz    ps2sendx             no message area
         mvc   0(&l,r14),=c&txt
         bctr  r4,0
         mvc   &l+1(*-*,r14),0(r7)
         ex    r4,*-6
         b     ps2sendx             get back
         Mend

ps2serr1 ds    0h
 aif ('&trace' eq '').trc9n
        log   'missing end-of-data'
.trc9n anop
         PS2MSG 1,'missing end-of-data'
ps2serr2 ds    0h
 aif ('&trace' eq '').trc10n
        log   'kw not in table'
.trc10n anop
         PS2MSGKW 2,'Keyword not in table:'
ps2serr3 ds    0h
 aif ('&trace' eq '').trc11n
        log   'keyword already found'
.trc11n anop
         PS2MSGKW 3,'Keyword already used:'
ps2serr4 ds    0h
 aif ('&trace' eq '').trc12n
        log   'keyword already found'
.trc12n anop
         PS2MSGKW 4,'Keyword cant have data'
ps2serr6 ds    0h
         icm   r14,15,PS2D1msg
         bz    ps2sendx             no message area
         mvc   0(12,r14),=c'Format error'
         mvc   13(1,r14),0(r3)
         mvc   15(8,r14),0(r7)
         la    r15,6
         b     ps2sendx             get back
ps2serr7 ds    0h
         icm   r1,15,PS2D1msg
         bz    ps2sendx             no message area
         mvc   0(20,r1),=cl20'Field length error'
         lm    r14,r15,PS2D1vpb
         sr    r15,r14
         bctr  r15,0
         mvc   21(*-*,r1),0(r14)
         ex    r15,*-6
         la    r15,7
         b     ps2sendx             get back
.*
ps2send ds     0h
 aif ('&trace' eq '').trc14n
        log   'string end'
.trc14n anop
         sr    r15,r15
         b     ps2sendx
         drop  r5
ps2send8 equ   *
         lr    r0,r7
         la    r15,8
ps2sendx equ   *
         l     r13,4(,r13)
         l     r14,12(,r13)
         lm    r2,r12,28(r13)
         br    r14
         ltorg
ps2svfat dc    256al1(*-ps2svfat)     verify alpha-num
         org   ps2svfat+c'A'
         dc    9x'00'                 ABCDEFGHI
         org   ps2svfat+c'J'
         dc    9x'00'                 JKLMNOPQR
         org   ps2svfat+c'S'
         dc    8x'00'                 STUVWXYZ
         org   ps2svfat+c'a'
         dc    9x'00'                 abcdefghi
         org   ps2svfat+c'j'
         dc    9x'00'                 jklmnopqr
         org   ps2svfat+c's'
         dc    8x'00'                 stuvwxyz
         org   ps2svfat+c'$'
         dc    x'00'
         org   ps2svfat+c'.'
         dc    x'00'
         org   ps2svfat+c'@'
         dc    x'00'
         org   ps2svfat+c'#'
         dc    x'00'
         org   ps2svfat+c'0'
         dc    10x'00'                0123456789
         org
ps2svfct dc    256al1(*-ps2svfct)     verify char
         org   ps2svfat+c'A'
         dc    9x'00'                 ABCDEFGHI
         org   ps2svfat+c'J'
         dc    9x'00'                 JKLMNOPQR
         org   ps2svfat+c'S'
         dc    8x'00'                 STUVWXYZ
         org   ps2svfat+c'a'
         dc    9x'00'                 abcdefghi
         org   ps2svfat+c'j'
         dc    9x'00'                 jklmnopqr
         org   ps2svfat+c'$'
         dc    x'00'
         org   ps2svfat+c'@'
         dc    x'00'
         org   ps2svfat+c'#'
         dc    x'00'
         org
ps2svfnt dc    256al1(*-ps2svfnt)     verify numerics
         org   ps2svfnt+c'0'
         dc    10x'00'
         org
         drop  r10,r11
         pop   using
.modulen anop
         mnote *,'#parm: &strparsn'
&thissect csect
.*-
.*       inline area
.*-
&s3      setc  (Upper '&area')
         aif   ('&s3' ne 'Y').x
* inline area
&s3      setc  'p&sysndx.arean'
         b     &s3
         mnote *,'StrParse Inline area'
         mnote *,'#parm: &strparsn'
         StrParse AREA
&s3      ds    0a
.*
         Mexit
.*-
.*       area definitions
.*- ds
.ds      anop
&s2      setc  (Upper '&syslist(2)')
         aif   ('&s2' eq 'F').dsf
         aif   ('&strparsalign' ne 'F').ds1an
&lbl._pfx  ds    0f                      align=F
&lbl._z  ds    x
.ds1an   anop
&plst    setc  (Upper '&l')
         aif   ('&plst' eq 'Z').dsl
&lbl._op ds    x
&lbl._fl ds    x
&lbl._dl ds    x
&lbl        ds    cl&s2
         mexit
.dsf     ds    0a,1x
&lbl._op ds    x
&lbl._fl ds    x
&lbl._dl ds    x
&lbl        ds    f
         mexit
.dsl     anop
&lbl._op ds    al1                    options
&lbl._cn ds    al1                    count
&lbl._fl ds    al2                    field length
&lbl        ds    0x                     start of list
         mexit
.*- dc
.dc      anop
         aif   ('&SYSSTYP' eq 'CSECT').dcopt
         mnote 4,'Section type should be CSECT, not &sysstyp'
.*       mexit
.*   &sln     seta  3                      past 'dc,len,'
.*   &oln     seta  0                      first inside
.*   &rtn     setc  'DC'
.*            ago   .opt2
.dcopt   anop
&qopt    setc  (Upper '&q')
&pvfy    setc  (Upper '&v')
&pcnv    setc  (Upper '&c')
         aif   ('&pcnv' ne 'P').dcoptpn   if packed
&pvfy    setc  'N'                        then must be numeric
.dcoptpn anop
 mnote *,'showit pvfy=&pvfy pcnv=&pcnv'
&plst    setc  (Upper '&l')
         aif   ('&plst' eq 'Y').dc2l
&s2      setc  (Upper '&syslist(2)')  length
         aif   ('&s2' eq 'F').dc2f    full-word
         aif   ('&strparsalign' ne 'F').dc1an
&lbl._pfx  ds    0f                      align=F
&lbl._z  ds    x
.dc1an   anop
&lbl._op dc    al1(PS2D3vf&pvfy+PS2D3cv&pcnv+PS2D3qo&pqopt)
&lbl._fl dc    al1(&s2)
&lbl._dl dc    al1(0)
&lbl        dc    cl&s2.' '
         Mexit
.dc2f    ds    0a,1x
&lbl._op dc    al1(PS2D3vfN+PS2D3cvB)
&lbl._fl dc    al1(4)
&lbl._dl dc    al1(0)
&lbl        dc    f'0'
         Mexit
.dc2l    ds    0a
&lbl._op dc    al1(PS2D3vf&pvfy+PS2D3cv&pcnv+PS2D3lst+PS2D3qo&pqopt)
&lbl._cn dc    al1(0)                 count
&lbl._fl dc    al2(&syslist(2))
&lbl        ds    0x                     start of list
         Mexit
.*
.strerr1 mnote 8,'Number of string parms ne 2'
         Mexit
.*== do over optlist
.opt2    anop
&pvfy    setc  'Z'
&pcnv    setc  'Z'
&pqopt   setc  'Z'
&plst    setc  'N'
&pabr    setc  '0'
&plen    setc  '?'
&setini  setc  '?'
&setinil seta  0
.optnext anop  , next
&oln     seta  &oln+1
         aif   (&oln gt n'&syslist(&sln)).opt2x
&opt     setc  '&syslist(&sln,&oln)'
&optl    seta  k'&opt
         aif   (&optl ge 3).optl9
         mnote 8,'*Length error: &opt'
         mexit
.optl9   anop
&optu    setc  (Upper '&opt')
&optd    setc  '&optu'(3,&optl-2)
.*       mnote *,'sln: &sln, iln: &oln opt: &opt / &optu, optd: &optd'
         aif   ('&optu'(1,2) eq 'V=').optfmt
         aif   ('&optu'(1,2) eq 'C=').optcnv
         aif   ('&optu'(1,2) eq 'A=').optabr
         aif   ('&optu'(1,2) eq 'I=').optini
         aif   ('&optu'(1,2) eq 'L=').optlen
         aif   ('&optu'(1,2) eq 'Q=').optqt
         aif   ('&optu'      eq 'L=Y').optlst
         mnote 8,'*Invalid option &opt in &sln,&oln'
         mexit
.optabr  anop
&pabr    setc  '&optd'
         ago   .optnext
.optlen  anop
&plen    setc  '&optd'
         ago   .optnext
.optqt   anop
&pqopt   setc  '&optd'
         ago   .optnext
.optfmt  anop
&pvfy    setc  '&optd'
         ago   .optnext
.optfmtn anop
&pvfy    setc  'N'
         ago   .optnext
.optcnv  anop
&pcnv    setc  '&optd'
         aif   ('&optd' eq 'B' or '&optd' eq 'P').optfmtn
         ago   .optnext
.optlst  anop
&plst    setc  'Y'
         ago   .optnext
.optini  anop
&setinil seta  k'&opt-2
&setini  setc  '&opt'(3,&optl-2)
         ago   .optnext
.opt2x   anop
 mnote *,'showit(2) pvfy=&pvfy pcnv=&pcnv'
         aif   ('&trn' eq 'CALL').callopt
.*       aif   ('&trn' eq 'DC').dcopt
         mnote 8,'*Invalid opt2 return: &rtn'
         Mexit
.*== optlist end
.*== build remote data list
.area    anop
         mnote *,'#parm: &strparsn'
&n       seta    0
.area100 anop
         aif   (&n ge &strparsn).area999
&n       seta  &n+1
&name    setc  '&strparsl(&n)'
&pvfy    setc  '&strparsf(&n)'
&pcnv    setc  '&strparsc(&n)'
&qopt    setc  '&strparsq(&n)'
&plen    setc  '&strparsk(&n)'
&name    StrParse ds,&plen,v=&pvfy,c=&pcnv,q=&pqopt
         ago   .area100
.area999 Mexit
.*-
.* XLA - subroutine, generate Lx instruction
.*-
.xla     anop
         lclc  &xlar,&xlap,&xla
         lcla  &xlapn,&xlan
&xlalen  setc   ''
&xlar    setc  '&syslist(2)'
&xlapn   seta  2
.xlanext anop
&xlapn   seta  &xlapn+1
         aif   (&xlapn gt n'&syslist).xlax
&xlap    setc  '&syslist(&xlapn)'
         aif   (k'&xlap eq 0).xlanext
         aif   ('&xlap '(1,1) eq '(').xlareg
         aif   ('&xlap '(1,1) eq '''').xlalit
         aif   ('&xlap '(2,1) eq '.').xlafld
&xla     setc  t'&xlap
         aif   ('&xla' eq 'N').xlanum
&lbl     la    &xlar,&xlap
         aif   ('&xlap  '(1,2) eq 'l''').xlax
&xlalen  setc   'l''&xlap'
         mexit
.xlanum  anop
&lbl     lgfi  &xlar,&xlap
         mexit
.xlafld  anop
&xlan    seta  k'&xlap-2
&xla     setc  '&xlap'(1,1)
&xlap    setc  '&xlap'(3,&xlan)
&xla     setc  lower('&xla')
         aif   ('&xla' ne 'c').xlafld1
&lbl     sr    &xlar,&xlar
         ic    &xlar,&xlap
         mexit
.xlafld1 aif   ('&xla' ne 'f').xlafld2
&xla     setc  ''
.xlafld2 anop
&lbl     l&xla &xlar,&xlap
         mexit
.xlareg  anop
&xlan    seta  k'&xlap-2
&xlap    setc  '&xlap'(2,&xlan)
&lbl     lr    &xlar,&xlap
         mexit
.xlalit  anop
&lbl     la    &xlar,=c&xlap
&xlan    seta  k'&xlap-2
&xlalen  setc  '&xlan'
.xlax    mexit
.x       Mend
         Macro
.*-
.* Test string against a pattern/mask.                          STRMACS
.*
.* Syntax
.*  STRPATRN DATA=data-addr,MASK=mask-addr,WC=ao|*%
.*
.*   'addr' is either a label, or (label,len) or 'literal'. 'label'
.*   and 'len' may be a register like (rn) or f/h/b/c.label to load
.*   from a fullword, halfword, byte or char field. See .XLA below.
.*   The mask may contain wildcards % for a single char and * for
.*   multiple or no chars.
.*   'ao' mask chars for all or none, or any one char. default is *%.
.*   STR= can be used instead of DATA=. This will probably be removed
.*   in a later version, so please use DATA=.
.*
.* Returns result in r15:
.*   0  Data matches mask
.*  >1  Data does not match mask, code indicates where in STRPATRN
.*      the check failed. Additional info is returned as follows:
.*        r0 -> data addr when check failed
.*        r1 -> mask addr when check failed
.*
.* Operation
.*   First time the macro is invoked an internal CSECT is generated,
.*   further macro invocations call the same CSECT.
.*   The save area pointed to by r13 is used as work area both for
.*   the call parameters and for saving registers. Registers 4-12 are
.*   restore when the program returns, registers 2 and 3 are not used
.*   so need not be preserved. Registers 0, 1, 14 and 15 are changed
.*   by the macro.
.*
.* Samples
.*    STRPATRN data=text1,mask=mask1
.*    STRPATRN data='ABCDE',mask='A%C*'
.*    STRPATRN data=((r2),(r3)),mask=(f.maskaddr,b.masklen)
.*    STRPATRN data=text1,mask='Doc*Brit*'
.*    . .
.*  text1    dc    c'Doctor Who is a British sci-fi TV series'
.*  mask1    dc    c'*Who*Brit*'
.*  maskaddr ds    a       contains address of mask
.*  masklen  ds    al1     max len 128 as field is signed
.*
.* Note that IBM supplies a similar function in macro ASAXWC in
.* SYS1.MODGEN. STRPATRN, however, is simpler to use and test has
.* shown it to be up to 4 times as fast as ASAXWC.
.*
.* History
.*  2019-12-01  Total rewrite, so is now new base
.*  2020-07-21  Fix false negative with equal mask- and string length
.*  2022-05-12  Remove unneccesary LTORG.
.*  2022-10-26  Fix problem with 1 char after last asterix i.a. ABC*F
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com
.*-
&ml      STRPATRN &str=,&data=,&mask=,&wc='*%'
         lclc  &l,&s,&c
         lcla  &qn
&l       setc  'sp&sysndx'
         gblb  &$STRPATRN
.* xla sub
         gblc  &xlalen
&s       setc  Upper('&syslist(1)')
         aif   ('&s' eq 'XLA').xla
.* call
         mnote *,'Version 2022-10-26'
&ml      la    r1,8(,r13)
         STRPATRN XLA,r14,&data(1),&str(1)
         STRPATRN XLA,r15,&data(2),&str(2),&xlalen,1
         stm   r14,r15,0(r1)
         STRPATRN XLA,r14,&mask(1)
         STRPATRN XLA,r15,&mask(2),&xlalen,1
         stm   r14,r15,8(r1)
         STRPATRN XLA,r14,&wc
         mvc   16(2,r1),0(r14)
         mvc   18(2,r1),=x'0000'
         l     r15,=v(ZTRPATRN)
         basr  r14,r15
         aif   (&$STRPATRN).x
&$STRPATRN setb 1
         j     &l.ltn
.*       ltorg          !not needed!
&l.ltn   ds    0a
* STRPATRN module
* r14  return address
* r12  basereg
* r11  -> string
* r10  -> mask
* r9   -> string end
* r8   -> mask end
* r7   wildcards : byte0 is 'all', byte1 = one
* r6   -> save mask ptr
* r5   -> last '*'
* r2-r4 are not used, they are not saved and restored as that space in
* the save area is used for the parm block.
&s       setc  '&sysect'
ZTRPATRN Amode 31
ZTRPATRN Rmode any
ZTRPATRN Csect
         save  (4,12)
         push  using
         lr    r12,r15
         using ZTRPATRN,r12
* set up registers
         using zptrnblk,r1
         l     r11,zptrnsa            -> string
         l     r9,zptrnsl             string length
         ar    r9,r11                 -> past string
         ahi   r9,-1                  -> end of string
         l     r10,zptrnma            -> mask
         l     r8,zptrnml             mask length
         ar    r8,r10                 -> past mask
         ahi   r8,-1                  -> end of mask
         l     r7,zptrnwc             wild cards and opts
* special case, mask='*' (fix 2020-07-21)
         la    r15,1
         c     r15,zptrnml            masklen=1 ?
         jne   &l.f001                no
         clm   r7,8,0(r10)            mask = '*' ?
         je    &l.q0                  yes
&l.f001  equ   *
*-
* Frontend - till '*' or end of mask or end of string
*-
         drop  r1
&l.f100  equ   *
         clm   r7,8,0(r10)            '*' ?
         je    &l.f400                then go handle block

* test char
&l.f200  equ   *
         clm   r7,4,0(r10)            '%' ?
         je    &l.f300                yes
         clc   0(1,r10),0(r11)        same char in string and mask?
         jne   &l.fe01                no, abort

* char ok, check/bump pointers
&l.f300  equ   *
         sr    r1,r1                  mask must also not be at end
         cr    r10,r8                 end of mask?
.*       jnh   &l.f302                nope        (fix 2020-07-21)
         jne   &l.f302                nope
         ahi   r1,1                   mask
&l.f302  cr    r11,r9                 end of data?
.*       jnh   &l.f304                nope        (fix 2020-07-21)
         jne   &l.f304                nope
         ahi   r1,1                   mark
&l.f304  ltr   r1,r1                  both before end?
         jz    &l.f310                good
         clfi  r1,2                   both are at the end
         je    &l.q0                  good
         cr    r10,r8                 end of mask?
         je    &l.fe03                mask end before string end

* string end before mask end, check if mask+1='*' and end of mask
         ahi   r10,1                  -> past '*'
         cr    r10,r8                 now end of mask?
         jne   &l.fe04                sadly not
         clm   r7,8,0(r10)            '*' ?
         je    &l.q0                  ok
         j     &l.fe05                bad

* both mask and string within bounds, bump and try next
&l.f310  equ   *
         ahi   r10,1                  bump mask ptr
         ahi   r11,1                  bump string ptr
         j     &l.f100                continue frontend processing

* mask (r10->) chr is '*'
&l.f400  equ   *
         cr    r10,r8                 end of mask?
         je    &l.q0                  yup, all is well

* handle multiple consequitive '*'
&l.f410  equ   *
         ahi   r10,1                  -> past '*'
         cr    r10,r8                 end of mask?
         je    &l.f430
         clm   r7,8,0(r10)            mask is * ?
         je    &l.f410                yes

* not end of mask, not '*'
&l.f420  equ   *
         ahi   r10,-1                 -> * ?
         j     &l.f500                go prep for mid- and backend

* end of mask
.* r9   -> string end
.* r8   -> mask end
&l.f430  equ   *
         clm   r7,8,0(r10)            mask is * ?
         je    &l.q0                  yes
* small backend of one char
         clm   r7,4,0(r10)            mask is % ?
         je    &l.q0                  yes
.*       clc   0(1,r10),0(r11)        char match ?
         clc   0(1,r9),0(r8)          last char match ?      2022-10-26
         je    &l.q0                  yes
         j     &l.fe06

* mask chr (r10->) is '*', locate last '*' in mask
* if this '*' is also last '*' in mask then just do backend
&l.f500  equ   *
         lr    r5,r8                  -> mask end
&l.f510  equ   *
         cr    r5,r10                 test against located '*'
         je    &l.f520                reached that
         clm   r7,8,0(r5)             is mask '*' ?
         je    &l.f530                yes
         bct   r5,&l.f510             else go test next

* last '*' = first '*' then no mid section, go do backend
&l.f520  equ   *
         j     &l.bep

* last '*' <> first '*' then there is a mid section
&l.f530  equ   *
         j     &l.msp

* Set return codes
&l.fe01  la    r15,101
         j     &l.qx
&l.fe02  la    r15,102
         j     &l.qx
&l.fe03  la    r15,103
         j     &l.qx
&l.fe04  la    r15,104
         j     &l.qx
&l.fe05  la    r15,105
         j     &l.qx
&l.fe06  la    r15,106
         j     &l.qx

*-
* mid section processing, find matching block in string.
* at entry: r10 -> position in mask, r11 -> position in text
* r6  -> save mask ptr
* r5  -> last '*'
*-
&l.msp   equ   *

* handle multiple '*'
&l.m010  equ   *
         ahi   r10,1                  -> past '*'
         clm   r7,8,0(r10)            mask is * ?
         jne   &l.m100                init properly
         cr    r10,r5                 = last '*' ?
         je    &l.m020                yes
         cr    r10,r8                 end of mask?
         je    &l.q0
         j     &l.bep                 else go do backend

* r10 -> last '*', also mask end?
&l.m020  equ   *
         cr    r10,r8                 mask end too?
         je    &l.q0                  then all is good
         j     &l.bep                 else do backend

* (re)start at submask
&l.m100  equ   *
         lr    r6,r10                 work mask ptr -> past '*'

&l.m200  equ   *
         cr    r6,r5                  mask work ptr gt subend?
         jh    &l.m100                then iterate
&l.m210  equ   *
         cr    r11,r9                 string gt end?
         jh    &l.me01                then error

* test match
&l.m300  equ   *
         clm   r7,4,0(r6)             mask is % ?
         je    &l.m310
         clc   0(1,r6),0(r11)         mask matches string?
         jne   &l.m400                nope, try next
* char match
&l.m310  equ   *
         ahi   r6,1                   bump maskworkptr
         cr    r6,r5                  last submsk done?
         je    &l.m600                yes, do backend
         clm   r7,8,0(r6)             mask is * ?  (submask end)
         je    &l.m500                nope
         ahi   r11,1                  bump strptr
         j     &l.m210                cont with test

* char don't match
&l.m400  equ   *
         cr    r6,r10                 past 1st char?
         jh    &l.m410                yes
         ahi   r11,1                  bump strptr
         j     &l.m100                restart submask
&l.m410  equ   *
         j     &l.m100                restart submask

* submask end
&l.m500  equ   *
         la    r10,1(,r6)             -> past '*'
         ahi   r11,1                  bump strptr
         j     &l.m100                restart submask

* work ptr -> last '*'
&l.m600  equ   *
         cr    r6,r8                  also end of mask?
         je    &l.q0
         lr    r10,r6
         j     &l.bep

* Set return code
&l.me01  la    r15,201
         j     &l.qx
&l.me02  la    r15,202
         j     &l.qx
&l.me03  la    r15,203
         j     &l.qx
&l.me04  la    r15,204
         j     &l.qx
&l.me05  la    r15,205
         j     &l.qx
&l.me06  la    r15,206
         j     &l.qx

*-
* backend procesing, scan backwards till '*'
* r11 -> string pos
* r10 -> last '*'
* r9  -> last byte of pos
* r8  -> last byte of mask
*-
&l.bep   equ   *
         ahi   r10,1
         lr    r4,r8
         sr    r4,r10                 length of backend
         lr    r5,r9
         sr    r5,r11                 length of str remainder
         cr    r5,r4
         jl    &l.be01

&l.b100  equ   *
         clm   r7,4,0(r8)             mask is % ?
         je    &l.b200                bad if not
         clc   0(1,r8),0(r9)          mask = text?
         jne   &l.be03                bad if not
&l.b200  equ   *
         cr    r8,r10                 locate last mask?
         jnh   &l.q0                  then all ok

&l.b300  equ   *
         ahi   r9,-1                  decr string ptr
         bct   r8,&l.b100             decr mask ptr

&l.be01  equ   *
         la    r15,301
         j     &l.be99
&l.be02  equ   *
         la    r15,302
         j     &l.be99
&l.be03  equ   *
         la    r15,303
         j     &l.be99
&l.be99  equ   *
         lr    r0,r9                  copy string addr for reporting
         lr    r1,r8                  copy mask addr for reporting
         j     &l.qx

*-
* return
*-
&l.q0    equ   *                      set good rc
         sr    r15,r15                set good rc
&l.qx    lr    r0,r11                 updated str addr for reporting
         lr    r1,r10                 updated mask addr for reporting
         return (4,12)
.*       ltorg          !not needed!
         pop   using

zptrnblk dsect
zptrnsa  ds    a                      string address
zptrnsl  ds    a                      string length
zptrnma  ds    a                      mask address
zptrnml  ds    a                      mask length
zptrnwc  ds    a                      wild cards etc
zptrnblkl equ  *-zptrnblk
.* resume main
&s       Csect                        resume main
         Mexit
.*-
.* $$LA - subroutine, generate Lx instruction (shortened $LA)
.* Syntax: $$LA  reg,what1,what2,,whatn
.*         what: label or (reg) or 'literal' or f/h/b/c.label
.*               c.label -> reg is cleared and the entire byte loaded
.*               1st non-null what is used
.*-
.xla     anop
         lclc  &xlar,&xlap,&xla
         lcla  &xlapn,&xlan
&xlalen  setc   ''
&xlar    setc  '&syslist(2)'
&xlapn   seta  2
.xlanext anop
&xlapn   seta  &xlapn+1
         aif   (&xlapn gt n'&syslist).xlax
&xlap    setc  '&syslist(&xlapn)'
         aif   (k'&xlap eq 0).xlanext
         aif   ('&xlap '(1,1) eq '(').xlareg
         aif   ('&xlap '(1,1) eq '''').xlalit
         aif   ('&xlap '(2,1) eq '.').xlafld
&xla     setc  t'&xlap
         aif   ('&xla' eq 'N').xlanum
&ml      la    &xlar,&xlap
         aif   ('&xlap  '(1,2) eq 'l''').xlax
&xlalen  setc   'l''&xlap'
         mexit
.xlanum  anop
&ml      lgfi  &xlar,&xlap
         mexit
.xlafld  anop
&xlan    seta  k'&xlap-2
&xla     setc  '&xlap'(1,1)
&xlap    setc  '&xlap'(3,&xlan)
&xla     setc  lower('&xla')
         aif   ('&xla' ne 'c' and '&xla' ne 'B').xlafld1
&ml      sr    &xlar,&xlar
         ic    &xlar,&xlap
         mexit
.xlafld1 aif   ('&xla' ne 'f').xlafld2
&xla     setc  ''
.xlafld2 anop
&ml      l&xla &xlar,&xlap
         mexit
.xlareg  anop
&xlan    seta  k'&xlap-2
&xlap    setc  '&xlap'(2,&xlan)
&ml      lr    &xlar,&xlap
         mexit
.xlalit  anop
&ml      la    &xlar,=c&xlap
&xlan    seta  k'&xlap-2
&xlalen  setc  '&xlan'
.xlax    mexit
.x       Mend
         Macro
.*-
.* Find position of argument in string.                         STRMACS
.*
.* Parameters
.*  arg       address and optionally length of argument
.*  str       address and optionally length of string
.*  default length for both is the first operand length
.*
.* Registers used
.*  r0, r1, r14, r15
.*
.* Registers at exit
.*  r1  -> argument in string if found
.*  r1  = 0 if argument is not found, or string is not big enough
.*
.* Samples
.*
.*         StrPos arg=arg1,str=str1    sets r1 = 7
.*         ltr   r1,r1
.*         bz    notfound
.*  arg1   dc    c'was'
.*  str1   dc    c'Kilroy was here'
.*
.*         StrPos arg=((r2),(r3)),str=((r4,r5)))
.*
.* yeah I know I really should use the SRST instruction, but that
.* requires more registers, and end-of-string handling is weird.
.*
.* History
.*  2022-06-19  Change $LA external macro call to SETREG.
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com
.*-
&ml      StrPos  &arg=,&str=
         gbla  &$SETREGL
         lclc  &l,&s
&l       setc  'zsp&sysndx'
&ml      SETREG  r1,&str(1)          -> string begin
         SETREG  r0,&str(2),l'&str(1) string length
         SETREG  r14,&arg(1)         arg
         SETREG  r15,&arg(2),l'&arg(1) arg length
.*
         cr    r0,r15                is string as wide
         jl    &l.n                    as arg?
         sr    r0,r15                length to scan
         ar    r0,r1                 last pos to scan
         bctr  r15,0                 arg mch length
         icm   r15,2,0(r14)          1st char of arg to 3rd byte of reg
&l.a     clm   r15,2,0(r1)           compare 1st char
         jne   &l.b
         ex    r15,&l.t              compare
         je    &l.x
&l.b     la    r1,1(,r1)             bump string ptr
         cr    r1,r0                 test end of string
         jnh   &l.a                  try next
&l.n     sr    r1,r1                 set not found
         j     &l.x
&l.t     clc   0(*-*,r1),0(r14)
&l.x     ltr   r1,r1
         Mend
         Macro
.*-
.* Convert packed decimal to zoned decimal                      STRMACS
.*
.* Syntax
.*  STRP2D FROM=(addr,len),TO=(addr,len)
.*        addr      label, (reg), F.label
.*        from-len  1-4
.*        to-len    default is from-len*3
.*
.* The macro calls an internally generated subroutine. This shortens
.* the code length for multiple executions of STRP2D, though adds a bit
.* to the program complexity.
.*
.* Returns
.*  r0  = length of output, either specified or computed
.*
.* Notes
.*  registes 0,1,14,15 are used by the macro.
.*  external macro SETREG is required.
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*-
&ml      StrP2D &from=,&to=
         lclc  &l,&s,&froml,&tol
         gblb  &$STRP2D
         gblc  &$SETREGLC
&l       setc  'PD&sysndx'
&ml      SETREG r15,&from(1)
&froml   setc  '&$SETREGLC'
         SETREG r0,&to(1)
&tol     setc  '&$SETREGLC'
         SETREG r1,&from(2),&froml
         SETREG r14,&to(2),0
         sll   r1,16
         ar    r1,r14
         l     r14,=v(ZSTRP2D)
         basr  r14,r14
.* module
         aif   (&$STRP2D).x            already done
&$STRP2D setb  1
&s       setc  '&sysloc'
ZSTRP2D  Amode 31
ZSTRP2D  Rmode any
ZSTRP2D  CSECT
         stm   r14,r2,12(r13)
         basr  r2,0
         ahi   r2,-6
         push  using
         using ZSTRP2D,r2
.* setup source length
         lh    r14,24(,r13)
.* setup target length
         lh    r15,26(,r13)
         ltr   r15,r15
         jnz   *+10
         lr    r15,r14                  use source
         sll   r15,1                    length*2
         lr    r0,r15                   save target length
.* compute and run
         bctr  r14,0
         bctr  r15,0
         sll   r15,4
         ar    r15,r14
         l     r14,16(,r13)            from
         l     r1,20(,r13)             to
         ex    r15,&l.a
         j     &l.a+6
&l.a     unpk  0(*-*,r1),0(*-*,r14)
         srl   r15,4                   leave mch tgt len
         ar    r1,r15
         oi    0(r1),x'F0'
.* back
         l     r14,12(r13)
         l     r2,28(r13)
         bsm   0,r14
         drop  r2
         pop   using
&s       Loctr                         resume main
.x       MEND
         Macro
.*-
.* Convert packed decimal to decimal without leading zeros      STRMACS
.*
.* Syntax
.*  STRP2N FROM=(addr,len),TO=addr
.*        addr      label, (reg), x.label
.*        len       value, (reg), x.label
.*        See the SETREG macro for details.
.*
.* The macro calls an internally generated subroutine. This shortens
.* the code length for multiple executions of STRP2D, though adds a bit
.* to the program complexity.
.*
.* Returns
.*  r0  = length of output, either specified or computed
.*
.* Notes
.*  registes 0,1,14,15 are used by the macro.
.*  external macro SETREG is required.
.*
.* History
.*  2021-10-06 Initial
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*-
&mlbl    StrP2N &from=,&to=,&print=off
         lclc  &l,&s
&l       setc  'ZPN&sysndx'
         gblc  &$setreglc
         gblb  &$strp2n
         aif   (&$strp2n).call
         push  print
         print &print
.* make code section
.* r15 -> output
.* r0  -> source length
.* r1  -> source addr
&$strp2n setb  1
&s       setc  '&sysect'
ZSTRP2N  Amode 31
ZSTRP2N  Rmode any
ZSTRP2N  CSECT
         stm   r14,r2,12(r13)
         basr  r2,0
         ahi   r2,-6
         push  using
         using ZSTRP2N,r2
* go
         mvc   40(8,r13),zstrp2nc
         lr    r14,r1                  addr
         lr    r15,0                   length
         sll   r15,1                   *2 = target length
         bctr  r15,0
         ex    r15,zstrp2ne            run instr
         jz    zstrp2nz
         la    r15,1(,r15)             reinstate length
         la    r15,40(r15,r13)
         sr    r15,r1                  length
         lr    r0,r15
         bctr  r15,0                   mch length
         l     r14,16(,13)             -> target area (old r15)
         ex    r15,zstrp2nm            copy data
         j     zstrp2nq                back
zstrp2nz l     r14,16(,13)             -> target area (old r15)
         mvi   0(r14),c'0'
         la    r0,r1                   set length
zstrp2nq l     r2,28(r13)              restore r2
         l     r14,12(r13)             restore r14 (return addr)
         bsm   0,r14
* defs
zstrp2nc dc    x'4020202020202020'
zstrp2ne edmk  40(*-*,r13),0(r14)      unpack
zstrp2nm mvc   0(*-*,r14),0(r1)
         drop  r2
         pop   using
&s       Csect                         resume main
         pop   print
.call    anop
         SETREG r1,&from(1)           addr
         SETREG r0,&from(2),&$setreglc  length
         SETREG r15,&to
         l     r14,=v(ZSTRP2N)
         basr  r14,r14
         Mend
         Macro
.*-
.* Convert value in register to readable (decimal)              STRMACS
.*
.* Syntax
.*  STRR2D ÝCALL,¨REG=register,TO=(addr,len)
.*        addr      label, (reg), F.label
.*        from-len  1-4
.*        to-len    default is from-len*3
.*        CALL      generates call to an internally created csect
.*
.* Returns
.*  r0  = length of output
.*
.* The  macro calls  an internally  generated subroutine.  This
.* shortens the code length  for multiple executions of STRC2B,
.* though adds a bit to the program complexity.
.*
.* Notes
.*  registers 0,1,14,15 are used by the macro
.*
.* History
.*  2022-06-19  Change $LA external macro call to SETREG.
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com
.*-
&mlbl    STRR2D &reg=,&to=
         lclc  &s,&l
         gblb  &$strr2d
&l       setc  'RD&sysndx'
.* call
         lr    r15,&reg
         SETREG  r0,&to(1)
         SETREG  r1,&to(2),0
         l     r14,=v(zstrr2d)
         basr  r14,r14
         aif   (&$strr2d).x
&$strr2d setb  1
.* module
&s       setc  '&sysloc'
ZSTRR2D  Amode 31
ZSTRR2D  Rmode any
ZSTRR2D  CSECT
         stm   r14,r2,12(r13)
         basr  r2,0
         ahi   r2,-6
         push  using
         using zstrr2d,r2
.* process
         l     r14,16(,r13)
         cvd   r14,60(,r13)
         lm    r14,r15,20(r13)         to addr and len
         ltr   r15,r15                 to-len given?
         jnz   *+8                     yes
         la    r15,12                  set default length
         lr    r0,r15                  save target size
         bctr  r15,0
         sll   r15,4
         ex    r15,&l.u
         srl   r15,4
         la    r15,0(r14,r15)
         oi    0(r15),x'f0'
.* return
         l     r14,12(,r13)
         l     r2,28(,r13)
         sr    r15,r15
         bsm   0,r14
&l.u     unpk  0(*-*,r14),60(8,r13)
         drop  r2
         pop   using
&s       Loctr                         resume main
.x       MEND
         Macro
.*-
.* Strip leading and/or trailing character                      STRMACS
.*
.* Syntax
.*  STRSTRIP string,where,char,LR=lenreg,TO=target
.*   string  address or (address,length)
.*   where   L (leading), T (training) or B (both), default is B.
.*   char    a single quoted character, default is ' ' (blanks)
.*   lenreg  length of string after strip, default is r15
.*   target  copy text to there, default is self
.*
.* Note that 'trailing' only sets the length reg, it does not modify
.* the data. 'leading' and 'both' do move data.
.*
.* Returns
.*  r0       length, copied to &LR if defined
.*  r15      rc, so far only 0 is set.
.*
.* Sample
.*  STRSTRIP dsname,b,'''',lr=r2    drop quotes at both ends
.*  STRSTRIP dw,l,'0',lr=r5         drop leading zeroes
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com
.*-
&ml      StrStrip &lr=,&to=
         gblc  &$setreglc
         gblc  &$SetMAddr,&$SetMAddrl,&$SetMAddrt
         gblb  &strstrip
         lclc  &l,&s,&str,&whr,&chr
&l       setc  'zstrip&sysndx'
&l       setc  'z&sysndx'
&whrmask setc  'b''0010'''
&chrmask setc  'b''0100'''
.* setup
&ml      SetReg r1,&syslist(1,1)             source address
         SetReg r0,&syslist(1,2),&$setreglc  source length
         SetReg r15,&to,&syslist(1,1)        target address
         SetMAddr &syslist(2),'B'
         icm   r0,&whrmask,&$SetMAddr        where
         SetMAddr &syslist(3),' '
         icm   r0,&chrmask,&$SetMAddr        where
         l     r14,=v(STRSTRIP)
         basr  r14,r14
         lclc  &$csct
&csct    setc  '&sysect'
         aif   (&strstrip).endmod
&strstrip setb  1
*- STRSTRIP module
STRSTRIP Amode 31
STRSTRIP Rmode any
STRSTRIP Csect
&l       setc  'STRSTRIP'
         stm   r14,r9,12(r13)
         push  using
         using STRSTRIP,r9
         basr  r9,0
         ahi   r9,-6
         lr    r2,r1                   source address
         lr    r3,r0                   source length, where and char
         sll   r3,24                   leave
         srl   r3,24                    length
         lr    r4,r15                  target address
         lr    r5,r0                   where and char
         o     r5,&l.o1                upcase where
*- what to do
         clm   r5,&whrmask,=c'T'       trailing
         je    &l.t0                    only
*- leading
&l.l0    ds    0h
         lr    r14,r2                  copy address
         lr    r15,r3                  copy length
&l.l1    ds    0h
         clm   r5,&chrmask,0(r14)     test char
         jne   &l.l2
         la    r14,1(,r14)             bump address
         bct   r15,&l.l1
         sr    r0,r0
         j     &l.x
&l.l2    ds    0h                      non-strip char found
         lr    r2,r14                  set new address
         clm   r5,&whrmask,=c'L'       just leading
         je    &l.cp
         lr    r3,r15                  set new length
*- trailing
&l.t0    ds    0h
         lr    r15,r3                  copy length
         la    r14,0(r15,r2)           add address -> past string
&l.t1    ds    0h
         bctr  r14,0                   adjust ptr
         clm   r5,&chrmask,0(r14)      test char
         jne   &l.t2                   not matched = end of text
         bct   r15,&l.t1
         sr    r15,r15                 rc = 0
         sr    r0,r0                   non-strip char not found
         j     &l.x
&l.t2    ds    0h                      non-strip char found
*- copy
&l.cp    ds    0h                      non-strip char found
         lr    r0,r15                  copy length
         bctr  r15,0                   machine length
         j     *+10
         mvc   0(*-*,r4),0(r2)
         ex    r15,*-6
         sr    r15,r15                 rc=0
*- return
&l.x     ds    0h
         l     r14,12(r13)
         lm    r2,r9,28(r13)
         bsm   0,r14
&l.o1    dc    a(x'00004000')
         pop   using
.* resume main
&csct    Csect                         resume main
.endmod  anop
         aif   (k'&lr eq 0).mend
         lr    &lr,r0                  set length
.mend    Mend
          Macro
.*
.* Test string for contents
.* Contents types: NUMeric
.*
&mlbl    StrTest &str=,&test=
         lclc  &s,&t,&l
         gblc  &$setreglc
&l       setc  'st&sysndx'
&mlbl    SETREG r14,&str(1)
         SETREG r15,&str(2),&$setreglc
&t       setc  Upper('&test')
         aif   ('&t   '(1,3) eq 'NUM').num
         mnote 8,'Invalid test type'
         mexit
.num     anop
&l.a     cli   0(r14),c'0'
         jl    &l.x
         cli   0(r14),c'9'
         jh    &l.x
         la    r14,1(,r14)
         bct   r15,&l.a
&l.x     ltr   r15,r15          zero => ok
         mexit
         Mend
         Macro
.*-
.* Return address and length of word.                           STRMACS
.* Using blank or specified char as delimiter .
.*
.* Syntax
.*  STRWORD  string-addr,string-len,number,DLM=d
.*  STRWORD  STR=(string-addr,string-len),NUM=number,DLM=d
.*           string-len default is length of string-addr
.*
.* Afterwards r1 -> word, r0 = word length. Both are zero if
.* word is not found.
.*
.* The  macro calls an internally generated subroutine. This
.* shortens the code length for multiple executions, though
.* adds a bit of program complexity.
.*
.* Notes
.*  Registes 0,1,14,15 are used by the macro
.*  External macro SETREG is used to setup parameters
.*  I know I should use TRT instead of loops, but TRT itself is
.*  expensive and somewhat complicated to set up, hence the loops.
.*
.* History
.*  2020-11-16  Created
.*  2021-03-15  Add DLM= parameter
.*  2021-07-19  Remove test for string-len, as it will be defaulted
.*  2021-12-29  Add STR= and NUM= parameters
.*
.* Author
.*  Willy Jensen
.*  mail: willy@harders-jensen.com
.*  web : http://harders-jensen.com
.*-
&ml      STRWORD &pa,&pl,&pn,&copyto=,&dlm==c' ',&str=,&num=
         gblb  &$STRWORD
         gblc  &$SETREGLC
         lclc  &sloc,&l
&l       setc  'ZSW&sysndx'
&sloc    setc  '&sysloc'
         aif   (k'&pa eq 0 and n'&str eq 0).p1e
.*       aif   (k'&pl eq 0).p2e
         aif   (k'&pn eq 0 and k'&num eq 0).p3e
         ago   .pok
.p1e     mnote 8,'*** addres parm missing'
         mexit
.p2e     mnote 8,'*** length parm missing'
         mexit
.p3e     mnote 8,'*** number parm missing'
         mexit
.pok     anop
         SETREG r0,&str(1),&pa
         SETREG r1,&str(2),&pl,&$SETREGLC
         SETREG r15,&num,&pn
         SETREG r14,&dlm
         icm   r15,8,0(r14)
         l     r14,=v(ZSTRWORD)
         basr  r14,r14
.* copyto
         aif   (k'&copyto eq 0).cp99
.*       ltr   r14,r0                   copy length
.*       jz    &l.n                     no data
         clfi  r0,1
         jl    &l.n
         lr    r14,r0
         SETREG r15,&copyto
         bctr  r14,0
         j     &l.m
         mvc   0(*-*,r15),0(r1)
&l.m     ex    r14,*-6
&l.n     equ   *
.cp99    anop
.* copyto end
.*-
.* module
.*  r12   basereg
.*  r6    number of word to return
.*  r5    current word number
.*  r4    string length
.*  r3    string address
.*
.* Entry
.*  r14   return
.*  r15   number
.*  r0    string address
.*  r1    string length
.*
.* Returns
.*  r0    word length or zero
.*  r1    word address or zero
.*-
         aif   (&$STRWORD).x           already done
&$STRWORD setb 1
&s       setc  '&sysloc'
ZSTRWORD Amode 31
ZSTRWORD Rmode any
         push  using
* Init
&l       setc  'ZSTRWORD'
ZSTRWORD CSECT
         stm   r14,r12,12(r13)
         balr  r12,0
         ahi   r12,ZSTRWORD-*
         using ZSTRWORD,r12
.* setup, copy parameters
         sr    r5,r5                   init number
         sr    r2,r2                   resultant word length
         lr    r7,r15                  setup
         srl   r7,24                     delimiter
         sll   r15,8                   remove
         srl   r15,8                     delimiter
         ltr   r6,r15                  word number
         jz    &l.90                   back now if zero
         ltr   r3,r0                   string address
         jz    &l.90                   back now if zero
         ltr   r4,r1                   string length
         jz    &l.90                   back now if zero
         ar    r4,r3                   -> past string
         bctr  r4,0                    -> last byte of string
* Locate non-blank = start of word
&l.10    equ   *
.*       cli   0(r3),c' '
         clm   r7,1,0(r3)
         jne   &l.20                   start of word
&l.12    equ   *
         cr    r3,r4                   at last??
         jnl   &l.90                   yup, back
         la    r3,1(,r3)
         j     &l.10
* Locate blank = end of word
&l.20    equ   *
         lr    r1,r3                   save address
         la    r5,1(,r5)               num+1
&l.22    equ   *
.*       cli   0(r3),c' '
         clm   r7,1,0(r3)
         je    &l.26
         cr    r3,r4                   at last??
         jnl   &l.28                   yes
&l.24    equ   *
         la    r3,1(,r3)
         j     &l.22
&l.26    equ   *                       blank found
         cr    r5,r6                   the one we want?
         jne   &l.12                   nope
         j     &l.60                   yes
* not end of text but end of string
&l.28    equ   *                       blank found
         cr    r5,r6                   the one we want?
         la    r3,1(,r3)               prep for length
* word found, get length
&l.60    sr    r3,r1                   get length
         lr    r2,r3                   copy length
* Back
&l.90    equ   *
         l     r14,12(r13)             restore return address
         ltr   r0,r2                   found??
         jnz   *+6
         sr    r1,r1                   set address to zero too
         lr    r15,r0                  copy length
         lm    r2,r12,28(r13)          restore other regs
         bsm   0,r14                   return
         pop   using
&sloc    Loctr                         resume main
.x       MEND
         Macro
.*-
.* Return number of words in string                             STRMACS
.* Using blank or specified char as delimiter .
.*
.* Syntax
.*  STRWORDS string-addr,string-len(,DLM=dlm)
.*  STRWORDS STR=(string-addr,string-len)(,DLM=dlm)(,REG=r)
.*           string-len default is length of string-addr
.*           dlm is default a blank. Must be an address i.e. =c','.
.*
.* The macro calls an internally generated subroutine. This
.* shortens the code length for multiple executions, though
.* adds a bit of program complexity.
.*
.* Returns
.*  r15 and r0 (and REG=r) = number of words
.*
.* Notes
.*  Registes 0,1,14, r15 are used by the macro
.*  External macro SETREG is used to setup parameters
.*  I know I should use TRT instead of loops, but TRT itself is
.*  expensive and somewhat complicated to set up, hence the loops.
.*
.* Author
.*     Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com
.*
.* History
.* 2020-11-14  Created
.* 2021-03-15  Add DLM= operand
.* 2021-12-29  Add STR= and REG= operands
.*-
&ml      STRWORDS &pa,&pl,&dlm==c' ',&str=,&reg=
         gblb  &$STRWORDS
         gblc  &$SETREGLC
         lclc  &sloc,&l
&sloc    setc  '&sysloc'
         SETREG r0,&str(1),&pa
         SETREG r1,&str(2),&pl,&$SETREGLC
         SETREG r15,&dlm
         l     r14,=v(ZSTRWRDS)
         basr  r14,r14
         aif   (k'&reg eq 0).regn
         lr    &reg,r15
.regn    anop
.*-
.* Module
.*  r8 is basereg
.* At entry
.*    r14 -> return
.*    r0  =  string length
.*    r1  -> string
.* Returns
.*  r15 = number of words
.*-
         aif   (&$STRWORDS).x          already done
&$STRWORDS setb 1
&s       setc  '&sysloc'
ZSTRWRDS Amode 31
ZSTRWRDS Rmode any
         push  using
* Init
&l       setc  'ZSTRWRDS'
ZSTRWRDS CSECT
         stm   r14,r12,12(r13)
         balr  r8,0
         ahi   r8,ZSTRWRDS-*
         using ZSTRWRDS,r8
         sr    r7,r7                   init number
         ltr   r3,r0                   string address
         jz    &l.99                   back now if zero
         ltr   r4,r1                   string length
         jz    &l.99                   back now if zero
         ar    r4,r3
         bctr  r4,0                    -> last byte of string
         ic    r6,0(r15)               delimiter
         j     &l.14                   go test
* Scan
&l.10    equ   *
         cr    r3,r4                   at last??
         jnl   &l.99                   yup, back
         la    r3,1(,r3)
&l.14    equ   *
* Locate non-blank
.*       cli   0(r3),c' '
         clm   r6,1,0(r3)
         je    &l.10                   blank, not yet word
         la    r7,1(,r7)               num+1
         j     &l.24
* Locate blank = end of word
&l.20    equ   *
.*       cli   0(r3),c' '
         clm   r6,1,0(r3)
         je    &l.10                   blank, end of word
         cr    r3,r4                   at last??
         je    &l.99                   yup, back
&l.24    equ   *
         la    r3,1(,r3)
         j     &l.20
* Back
&l.99    equ   *
         l     r14,12(r13)             restore return address
         lr    r15,r7                  copy number of words
         lr    r0,r7                   copy number of words
         lm    r2,r12,28(r13)          restore other regs
         bsm   0,r14                   return
         pop   using
&sloc    Loctr                         resume main
.x       MEND
* placeholder
         Macro
.* TrcBlk / TrcBlkE are used around larger instruction blocks.
.* This cuts down on the number of instructions executed.
.* If relies on a field callled TRACE to have a value of Y.
.* It includes the global suppresion macro CONDSECT.
         TrcBlk
         gblc  &trcblka
.* condsect begin
         lclc  &c
         Condsect ,TRCBLKE
         gblc  &$condsect
&c       setc  Upper('&$condsect ')
         aif   ('&c '(1,1) eq 'H').x
.* condsect end
         aif   ('&trcblka' eq '').go
         mnote 8,'***trcblka ne null'
         mexit
.go      anop
&trcblka setc  'TB&sysndx.END'
         cli   trace,c'Y'
         jne   &trcblka
.x       Mend
         Macro
.* End of trace block. See the TRCBLK macro for further info.
         TrcBlkE
         gblc  &trcblka
&trcblka ds    0h
&trcblka setc  ''
         Mend
         Macro
.* Generate translate table
.* Parameters are either duplets char,list or 'aaplha', 'lalpha',
.* 'uaplha', 'num' or 'spc'.
.*   char  defines the offset into the table, i.e. c'A'
.*   list  defines the list of charaters to place at char.
.*   i.e. t1 TrTable c'A',c'ABCDEF',c'G',c'GHIJ'
.*  ualpha is short for dublets defining uppercase letters.
.*  lalpha is short for dublets defining lowercase letters.
.*  aalpha is short for dublets defining upper- and lowercase letters.
.*  num    is short for dublets defining numbers 0-9.
.*  spc    is short for dublets defining various special characters.
.*  all    is short for dublets defining alpha+num+spc
.*   i.e. t2 TrTable aalpha,num,spc
.* Duplets and shorthands may be intermixed.
.* Shorthands are case insensitive, aAlpHa = AALPHA.
.*
&lbl     TRTABLE &defc=c'.'
&lbl     ds    0a
         dc    256&defc
         lcla  &p
         lclc  &c
.a       anop
         aif   (&p ge n'&syslist).x
&p       seta  &p+1
&c       setc  Upper('&syslist(&p)')
         aif   ('&c' eq 'UALPHA').ualpha
         aif   ('&c' eq 'LALPHA').lalpha
         aif   ('&c' eq 'AALPHA').ualpha
         aif   ('&c' eq 'NUM').num
         aif   ('&c' eq 'SPC').spc
         aif   ('&c' eq 'ALL').ualpha
&c       setc  '&syslist(&p)'
         org   &lbl+&c
&p       seta  &p+1
&c       setc  '&syslist(&p)'
         dc    &c
         ago   .a
.ualpha  org   &lbl+c'A'
         dc    c'ABCDEFGHI'
         org   &lbl+c'J'
         dc    c'JKLMNOPQR'
         org   &lbl+c'S'
         dc    c'STUVWXYZ'
         aif   ('&c' eq 'AALPHA').lalpha
         aif   ('&c' eq 'ALL').lalpha
         ago   .a
.lalpha  org   &lbl+c'a'
         dc    c'abcdefghi'
         org   &lbl+c'j'
         dc    c'jklmnopqr'
         org   &lbl+c's'
         dc    c'stuvwxyz'
         aif   ('&c' eq 'ALL').num
         ago   .a
.num     org   &lbl+c'0'
         dc    c'0123456789'
         aif   ('&c' eq 'ALL').spc
         ago   .a
.spc     org   &lbl+c'@'
         dc    c'@'
         org   &lbl+c'#'
         dc    c'#'
         org   &lbl+c'$'
         dc    c'$'
         org   &lbl+c','
         dc    c','
         org   &lbl+c':'
         dc    c':'
         org   &lbl+c'-'
         dc    c'-'
         org   &lbl+c' '
         dc    c' '
         ago   .a
.x       org
         Mend
         Macro
.*-
.*   TSOPUTLN - assembler macro - TSO putline not needing setup.
.*
.* The macro is self-contained in that  it does not need an external
.* subroutine, the  subroutine is generated internally  at the first
.* macro expansion.
.*
.* The macro  works even if  used in a  mdule started with  the BAKR
.* instruction, because  the generated  subroutine uses  EXTRACT and
.* LOCASCB to  get the necessary runtime  info, it does not  rely on
.* tracing back through save areas.
.*
.* It may cause a slight  performance degradation as the module must
.* format the message string, so GETMAINs and FREEMAINs a work area.
.* On the other hand, this  makes the subroutine fully reentrant and
.* reusable.
.*
.* The generated CSECT will by default use amode 31 and rmode ANY.
.* This can be changed in the main program like so:
.*           gblc  &#modrmod,&#modamod
.*  &#modamod setc  '24'             amode
.*  &#modrmod setc  '24'             rmode
.*
.* Syntax
.*
.*  TSOPUTLN address,length (,DSECT=YES/NO)
.*           address     Address of text. Required.
.*                       May be label, (reg) or F|H|B.label for
.*                       L label, LH label or LB label.
.*           length      Length of text. Number or (reg). Default
.*                       is length of 'address'.
.*           DSECT=YES   Generate various neccessary IBM dsects.
.*           DSECT=NO    Do not generate IBM dsects. This is used
.*                       when those dsects are generated elsewhere.
.*
.* Samples
.*
.*            la    r5,120
.*            TsoPutln msg,(r5)
.*
.*            la    r4,msg
.*            TsoPutln (r4),(r5)
.*
.*            TsoPutln text
.*
.*            TsoPutln text,25
.*
.*            TsoPutln 'Just another fine day'
.*
.*            TsoPutln f.textaddr,h.textlen
.*
.*   msg      ds    cl256
.*   textaddr dc    a(test)
.*   textlen  dc    y(l'test)
.*   text     dc    c'Kilroy was here'
.*   text2    dc    c' and it is such a nice day today'
.*
.* Note
.*
.* TSOPUTLN does not work when used in a REXX function, i.e. n=PGM()
.*
.* by: Willy Jensen
.*     mail: willy@harders-jensen.com
.*     web : http://harders-jensen.com
.*-
&mlbl    TSoPutLn &print=nogen,&dsects=YES
         lcla  &n,&pn
         lclc  &q,&l,&sect,&src,&len,&p,&r
         gblb  @@tsoputln
         gblc  $xlalen
&q       setc  Upper('&syslist(1)')
         aif   ('&q' eq 'XLA').xla
&l       setc  'tp&sysndx'
&sect    setc  '&sysect'
&src     setc  '&syslist(1)'
&len     setc  '&syslist(2)'
         aif   (k'&mlbl eq 0).mlbln
&mlbl    ds    0h
.mlbln   anop
.* text address - label, (reg) or 'literal'
         TSOPUTLN xla,r1,&src
.* text length - label, (reg) or null. if null then set l'text
         TSOPUTLN xla,r0,&len,&$xlalen
         l     r15,=v(TSOPUTLN)
         basr  r14,r15
         aif   (&@@tsoputln).x
.*-
.* module
.*-
&@@tsoputln setb 1
         push  using
         push  print
         print &print
*-
* TSOPUTLN module
*-
.* set amode/rmode, expects both defaultet in macro prototype
         gblc  &#modrmod,&#modamod
.* amode
         aif   ('&#modamod' ne '').#modam2
TSOPUTLN Amode 31
         ago   .#modamn
.#modam2 anop
TSOPUTLN Amode &#modamod
.#modamn anop
.* rmode
         aif   ('&#modrmod' ne '').#modrm2
TSOPUTLN Rmode ANY
         ago   .#modrmn
.#modrm2 anop
TSOPUTLN Rmode &#modrmod
.#modrmn anop
TSOPUTLN Csect
         save  (14,12)
         lr    r12,r15
         Using TSOPUTLN,r12
         Using @tputblk,r10
         lr    r2,r1                   copy text/buffer address
         lr    r3,r0                   copy text length
*- get storage
         la    r9,@tputblkl+4(r3)      blk+text length
         Getmain R,lv=(r9),loc=31
         lr    r10,r1
         lr    r0,r10
         la    r1,@tputblkl
.*       la    r14,=al1(0)
         la    r14,tsoputln_al10
         la    r15,1
         mvcl  r0,r14
         st    r10,8(,r13)             chain
         st    r13,4(,r10)               save
         lr    r13,r10                     areas
*- copy data
         la    r1,4(,r3)               set length
         sll   r1,16                   to upper halfword
         st    r1,@tputlen             store as prefix
         la    r14,@tputtext           target address
         lr    r15,r3                  copy length
         mvcl  r14,r2                  copy text
*- obtain address of the upt through the extract facility
         la    r0,@tputiopl
         EXTRACT (0),'S',FIELDS=(PSB,ASID),MF=(E,@tputextr)
         l     r1,@tputiopl
         mvc   @tputupta,pscbupt-pscb(r1)
*- obtain address of the ect from the lwa control block
         l     r1,@tputiopl+4          asid
         LOCASCB ASID=(1)
         l     r1,ascbasxb-ascb(,r1)   -> asxb
         l     r1,asxblwa-asxb(,r1)    -> lwa
         mvc   @tputecta,lwapect-lwa(r1) get ect address
*- do putline
         xc    @tputecb,@tputecb
         xc    @tputiopl(16),@tputiopl
         l     r14,@tputupta
         l     r15,@tputecta
         PUTLINE PARM=@tputmfl,UPT=(r14),ECT=(r15),ECB=@tputecb,       c
               OUTPUT=(@tputlen,TERM,SINGLE,DATA),MF=(E,@tputiopl)
         lr    r5,r15
*- release storage
         l     r13,4(,r13)             <- callers save area
         Freemain R,lv=(r9),a=(r10)
*- back
         lr    r15,r5                  set return code
         lm    r2,r12,28(r13)          reload gregs
         l     r14,12(,r13)            return address
         bsm   0,r14                   return
tsoputln_al10  dc al1(0)
         drop  r10,r12
*-
* TSOPUTLN local dsects
*-
@tputblk  dsect
@tputsa1  ds    18a
@tputextr EXTRACT MF=L
*         org   @tputextr
@tputecb  ds    a
@tputecta ds    a
@tputupta ds    a
*         org
@tputiopl ds    4a
@tputmfl  PUTLINE MF=L
@tputmsgl ds    a
@tputmsg  ds    cl255
@tputlen  ds    a
@tputtext ds    0c
@tputblkl equ   *-@tputblk
         aif   ('&dsects' ne 'YES').dsctn
*-
* TSOPUTLN IBM dsect expansions (if requested)
*-
         IKJPSCB
         IHAASCB
         IHAASXB
         IKJEFLWA
.dsctn   anop
         pop   print
.* rejoin csect
&sect    Csect                         resume main
         pop  using
.x       Mexit
.*-
.* XLA - subroutine, generate Lx instruction
.* Syntax: macname XLA,reg,ahat
.*                 what: label, (reg), 'literal', f/h/b.label
.*-
.XLA     anop
         lclc  &xlar,&xlap,&xla
         lcla  &xlapn,&xlan
&$xlalen setc  ''
&xlar    setc  '&syslist(2)'
&xlapn   seta  2
.xlanext anop
&xlapn   seta  &xlapn+1
         aif   (&xlapn gt n'&syslist).xlan
&xlap    setc  '&syslist(&xlapn)'
         aif   (k'&xlap eq 0).xlanext
         aif   ('&xlap '(1,1) eq '(').xlareg
         aif   ('&xlap '(1,1) eq '''').xlalit
         aif   ('&xlap  '(2,1) eq '.').xlafld
&xla     setc  t'&xlap
         aif   ('&xla' eq 'N').xlanum
         la    &xlar,&xlap
&$xlalen setc 'l''&xlap'
         mexit
.xlanum  anop
         lgfi  &xlar,&xlap
         mexit
.xlafld  anop
&xlan    seta  k'&xlap-2
&xla     setc  '&xlap'(1,1)
&xla     setc  Upper('&xla')
         aif   ('&xla' ne 'F').xlafld2
&xla     setc  ''
.xlafld2 anop
&xlap    setc  '&xlap'(3,&xlan)
         l&xla &xlar,&xlap
         mexit
.xlareg  anop
&xlan    seta  k'&xlap-2
&xlap    setc  '&xlap'(2,&xlan)
         lr    &xlar,&xlap
         mexit
.xlalit  anop
         la    &xlar,=c&xlap
&xlan    seta k'&xlap-2
&$xlalen setc '&xlan'
.xlan    mexit
         MEND
         Macro
.*-
.* Make parameter list for subroutine call
.*
.* Syntax
.*  WSAOPLST (parm1,parm2,..parmn),pl=parmlist
.*  The parameters must be enclosed in paranthesis.
.*  Each parameter must be a number, an address, a (register)
.*  or a field to load from. See the SETREG macro for details.
.*  pl= address of a bunch of fullwords
.*
.* Notes
.*  Requires external macro SETREG.
.*
.* Sample:
.*  WsaOplst (wrkname,(r2),dsetxt,(r3)),pl=callpl
.*-
&wsaoml  WsaOpLst &wsaoprm,&vl=,&pl=
         lcla  &wsaon,&wsaoo,&wsaom
         lclc  &wsaos,&wsaor,&wsaorl(3)
&wsaorl(1) setc '14'
&wsaorl(2) setc '15'
&wsaorl(3) setc '0'
         aif   (n'&syslist gt 1).wsaoe1
         aif   (n'&wsaoprm eq 0).wsaoe2
         aif   (k'&pl eq 0).wsaoa
&wsaoml  setreg r1,&pl
.wsaoa   anop
&wsaon   seta  &wsaon+1
&wsaom   seta  &wsaom+1
.* mnote *,'p=&wsaon, n=&wsaom'
         setreg &wsaorl(&wsaom),&wsaoprm(&wsaon),0
         aif   (&wsaon lt n'&wsaoprm and &wsaom lt 3).wsaoa
         aif   (&wsaom eq 1).wsaost
         stm   r14,r&wsaorl(&wsaom),&wsaoo.(r1)
         ago   .wsaonx
.wsaost  st    r14,&wsaoo.(r1)
         ago   .wsaovl
.wsaonx  anop
&wsaoo   seta  &wsaoo+12
&wsaom   seta  0
         aif   (&wsaon lt n'&wsaoprm).wsaoa
.wsaovl  aif   ('&vl' ne '1').x
&wsaoo   seta  n'&wsaoprm
&wsaoo   seta  (&wsaoo*4)-4
         oi    &wsaoo.(r1),x'80'
         mexit
.wsaoe1  mnote 8,'Too many positional parameters'
         mexit
.wsaoe2  mnote 8,'Missing parameters'
         mexit
.x       Mend
