//RXVB031  JOB (1),'vsam-bulkaccess-030',
//*    RESTART=IVP1,
//             CLASS=A,COND=(0,LT),TIME=(10),REGION=64M
//* ?? RXVSAMBA - VSAM bulk access from REXX ? e ?
//*
// SET VER=031
// SET IVP=I&VER
// SET IVP=IVP1
//*
/*JOBPARM L=9999
//*
//*** Build 031
//***
//*** Warnings:
//***  Build 015 Redefines the use of operands LIST(name) and
//***            KEYSTEM(name).
//***       -    Changes the FILTER(name) operand to
//***            TEXTSTEM(name).
//***       -    Redefines the use for the RXVBWRIT variable
//*
//A  EXEC ASMACL, XL,MACLIST=RXVSAMBA,
//             PARM.C='TERM,RENT',
//             PARM.L='LIST,RENT,REUS,REFR,RMODE(ANY)'
//C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB
//          DD DISP=SHR,DSN=SYS1.MODGEN
//          DD DISP=SHR,DSN=CBT669.PP.RXVSAMBA.LIB
//C.SYSTERM DD SYSOUT=*
//C.SYSIN   DD *
**asma syslib *
**asma opt    term
          lclc  &vsrclog,&section,&sectid,&name,&vers,&s,&jpaq
&jpaq     setc  'N'                     Do not keep module in the JPAQ
&jpaq     setc  'Y'                     Keep module in the JPAQ
&vsrclog  setc  'N'
&name     setc  'RXVSAMBA'
&@modname setc  '&name'
&vers     setc  '031.2'
&@modvers setc  '&vers'
*
*-
* Register usage
*
* 12     base for top routine (scheduler etc)
* 11     base for functional routines (GET.. PUT.. etc)
* 10     base for global dynamic work area
*  9     base for sub-functions (STEMGET STEMPUT etc)
*-
* Changes in this build - see member RVVBHIST for full list
*
*  New
*   Honor the MASKSTEM parameter, which was documented but not
*   implemented.
*
*  Changed
*   none
*
*  Fixed
*   none
*
*
* Installation notes
*
*   The  program may  be  set  to reload  itself  thus retaining  the
*  module in the  JPAQ. This improves performance  for multiple calls
*  significantly. This load will not be  done if the program is added
*  to the LPA, which is the recommended placement.
*   Enable  the   self-load  option  by  setting the &JPAQ variable
*  to 'Y'.
*
*  Warnings:
*   Build 015 Redefines the use of operands LIST(name) and
*             KEYSTEM(name).
*        -    Changes the FILTER(name) operand to
*             TEXTSTEM(name).
*        -    Redefines the use for the RXVBWRIT variable
*
* Contact info
*  email   willy@harders-jensen.com
*  web     https://harders-jensen.com  (newest version here)
*
*-

         print off
         Copy  WsamMacs
         Copy  RexxMacs
         Copy  SysMacs
         Copy  RXVBMacs
*        COPY  Z10MACS
         print on

*-
*
* VSAM  bulk access
*
*-
*
* Syntax, see the RXVBDOC member
         #subr set,entry=csect,base=r11,saend=@@@saend
RXVSAMBA #module base=(r12),text='&vers',                              c
               work=($wrkl,$wrk,r10,C),sa=@@@sa,                       c
               xprolog=prolog,xepilog=epilog
         if    (ltr,r15,r15,nz)           prolog ok?
           #module exit
         endif

         zap   sanum,=p'0'

*-
* Keep module in JPAQ for duration of job / TSO session
*-
         aif   ('&jpaq' ne 'Y').jpaqn
         CDEUCTZ2
.jpaqn   anop

* some functions do not require a libref
* i.e. RXVSAMBA.022 01/26/19 14.12
         if    (=c'VER',eq,function)
           la    r2,verstxt
           la    r3,l'verstxt
           stm   r2,r3,retval
           #module exit,rc=0
         Macro
         MkVersion &t
         lclc  &c
&c       setc  '&sysclock'(1,19)
verstxt  dc    c'&t &c'
         Mend
         MkVersion &@modname..&@modvers
         endif
*-
* handle allocation
*-
         if    (cli,da,ne,c' ')
           clear alcbfr1
           mvc   alcbfr2,alcbfr1
           strmake alcbfr1+2,'Alloc SHR Dsn(',(da,b.da_dl),')',        c
               lenreg=r2
           sth   r2,alcbfr1
           mvlit alcbfr2+2,'RTDDN'
           mvc   alcbfr2(2),=y(9)
           if    (cli,trace,eq,c'Y')
             strmake tracerec,(alcbfr1+2,(r2))
             xtrace ,(r2)
           endif
           la    r14,alcbfr1
           la    r15,alcbfr2
           sr    r0,r0
           Link  EP=BPXWDYN,param=((r14),(r15)),VL=1,mf=(E,alcpl)
           st    r15,fw
           if    (ltr,r15,r15,z)
             mvc   dd,alcbfr2+2
             mvc   dd_dl,alcbfr2+1
             xtrace 'Ok'
           else
             seterr 'alloc failure',12
             mvi   da,c' '
             #module exit,rc=12
           endif
         endif
         if    (cli,dd,eq,c' '),and,(cli,da,eq,c' ')
           mvc   dd,=cl8'VSAM'
         endif
*-
* determine which function to run
*-
         if     (cli,enq_dl,ne,0)     do enqueue
           la    r2,=cl8'RXVSAMBA'
           lb    r3,enq_dl
           la    r4,dd
           j     enqm
enqd       ENQ   (0,0,E,0,SYSTEMS),ret=HAVE,mf=L
enqm       mvc   wrk256(enqm-enqd),enqd
           ENQ   ((2),(4),E,(3),SYSTEMS),ret=HAVE,mf=(E,wrk256)
         endif

* load list
         if    (cli,textstem_dl,ne,0)
           xtrace 'Copy textstem to internal'
           la    r0,txtlstad
           la    r1,textstem_dl
           ICall stmcpymk              go make internal copy
         endif

* info
         if     (=c'INFO ',eq,function)
           ICall Info
* get
         elseif (=c'GET ',eq,function)
           if    (cli,stem_dl,eq,0),and,(cli,pstack,ne,c'Y')
             seterr 'Data target missing',12
           elseif (cli,key_dl,ne,0),or,(cli,keyvar_dl,ne,0)
             ICall GetKey
           elseif (cli,pkeystem_dl,ne,0)
             ICall GetKeyl
           else
             ICall GetTxt               really = ALL
           endif
* delete
         elseif (=c'DEL',eq,function),or,(=c'PULL ',eq,function)
           if     (cli,key_dl,ne,0)
             ICall DelKey               delete by key
           elseif (cli,pkeystem_dl,ne,0)
             ICall DelKeyl              delete sequential
           elseif (cli,mask_dl,ne,0)
             ICall DelTxt               delete by mask
           elseif (cli,text_dl,ne,0)
             ICall DelTxt    txt        delete by text
           elseif (cli,maskstem_dl,ne,0)
             ICall DelTxt               delete by mask in stem
           elseif (cli,textstem_dl,ne,0)
             ICall DelTxt               delete by text in stem
           else
             seterr 'Delete cmd error',12,t
           endif
* write
         elseif (=c'PUT ',eq,function),and,(cli,value_dl,ne,0)
           ICall PUTVAL
         elseif (=c'PUT ',eq,function)
           ICall PUT
         elseif (=c'INS',eq,function)
           ICall INSERT
         else
           seterr 'Cmd error',12,t
         endif

         #module exit
*
*---------------------------------------------------------------------*
*
acb1m    ACB   DDNAME=VSAM,RMODE31=ALL
acb1ml   equ   *-acb1m
         ds    xl40
rpl1m    RPL   acb=0 Acb1
rpl1ml   equ   *-rpl1m
         ds    xl40
acbopnm  open  0,mf=L
acbopnml equ   *-acbopnm
*
*---------------------------------------------------------------------*
*
zero     dc    a(0)
verinfo  dc    c'&name..&vers &sysdatc &systime'
* i.e. RXVSAMBA.022 01/26/19 14.12
*
*---------------------------------------------------------------------*
*
         ltorg

*---------------------------------------------------------------------*
*                        trace major values                           *
*---------------------------------------------------------------------*
Trace1   #subr
         st    r12,fw
         StrMake logr,'epa ',(fw,4,cvxd),                              c
               ' function ',function,                                  c
               ' key_dl ',(key_dl,1,cvd),                              c
               ' stem_dl ',(stem_dl,1,cvd),                            c
               ' list_dl ',(list_dl,1,cvd),                            c
               ' text_dl ',(text_dl,1,cvd),                            c
               ' pos ',(pos,4,cvd,4),                                  c
               ' endpos ',(endpos,4,cvd,4),lr=r0
         xtrace ,(r0)
         #subr exit,rc=0
         #subr drop

*---------------------------------------------------------------------*
*              parse parameters                                       *
*---------------------------------------------------------------------*
Prolog   #subr
         clear blank
         mvc   logr,blank
         mvc   errmsg,blank
         l     r1,=a(vsbfr1-$wrk)
         ar    r1,r10
         st    r1,vsbfr1a
         l     r1,=a(vsbfr2-$wrk)
         ar    r1,r10
         st    r1,vsbfr2a
         clear tracerec
         la    r3,pl4
         do    from=(r2,pl4num)
           zap   0(4,r3),=p'0'
           la    r3,4(,r3)
         enddo
         mvc   dd,blank
         mvc   stem,blank
         mvc   pkeystem,blank
         mvc   list,blank
         mvc   key,blank
         mvc   text,blank
         mvi   acb1stat,c' '
         mvc   vsbfr1l,=a(l'vsbfr1)
         mvc   vsbfr2l,=a(l'vsbfr2)
         mvc   acb1(acb1ml),acb1m
         mvc   rpl1(rpl1ml),rpl1m
         mvc   acbopn(acbopnml),acbopnm
*
         ereg  0,1
         RxInit parmlist=((parmstr,120))
*
         StrParse (parmstr,l'parmstr),                                 +
               (#p,function,l=8,c=u),             1st pos = function   c
               (igndup,pigndup,c=u,l=1),                               +
               (trace,trace,c=u,l=1),                                  +
               (dd,dd,v=a,c=u,l=8),                                    +
               (da,da,v=a,c=u,l=44),                                   +
               (enq,enq,v=a,c=u,l=16),                                 +
               (stem,stem,v=a,c=u,l=120),                              +
               (stack,pstack,c=u,l=1),                                 +
               (keystem,pkeystem,v=a,c=u,l=120),                       +
               (keyvar,keyvar,v=a,c=u,l=120),                          +
               (list,list,v=a,c=u,l=120),                              +
               (key,key,l=120),                                        +
               (value,value,l=120,a=3),                                +
               (mask,mask,l=60),                  v019                 +
               (text,text,l=120),                                      +
               (textstem,textstem,v=a,c=u,l=120),                      +
               (maskstem,maskstem,v=a,c=u,l=120),                      +
               (pos,pos,v=n,c=b,l=f),                                  +
               (endpos,endpos,v=n,c=b,l=f),                            +
               (to,keyto,l=120),                                       +
               (strip,strip,l=1),                                      +
               (maxout,maxout,v=n,c=b,l=f),       v029                 +
               (word,word,v=n,c=b,l=f),           v030                 +
               (dlm,dlm,c=u,l=1),                 v030                 +
               msg=logr,build=y,pp=#p
         if    (ltr,r5,r15,nz)         return message from parmscan
           strlen data=logr
           lr    r2,r15                copy length
           st    r2,errmsgl
           bctr  r2,0
           j     *+10
           mvc   errmsg(*-*),logr
           ex    r2,*-6
           mvi   rc+3,12
           #subr exit,rc=12
         endif
         clear logr
         oc    function,blank

* test for some mutually exclusive parms
         sr    r1,r1
         if    (cli,mask_dl,ne,0),then=(la,r1,1(,r1))
         if    (cli,text_dl,ne,0),then=(la,r1,1(,r1))
         if    (cli,textstem_dl,ne,0),then=(la,r1,1(,r1))
         if    (cli,maskstem_dl,ne,0),then=(la,r1,1(,r1))
         if    (clfi,r1,gt,1)
           seterr 'mutually exclusive parameters',12
           #subr exit,rc=12
         endif

* maskstem is mostly treated like the textstem
         if (cli,maskstem_dl,ne,0)
            mvc   textstem_dl(l'maskstem+1),maskstem_dl
         endif

* some field validation
         mvc   fw(1),strip
         oc    fw(1),blank
         if    (cli,fw,eq,c'B'),then=(mvi,strip,c' ')
         if    (cli,dlm,eq,c'b'),or,(cli,dlm,eq,c'B'),                 c
               then=(mvi,dlm,c' ')

* select stem or stack
         if    (cli,stem_dl,ne,0),and,(cli,pstack,eq,c'Y')
           seterr 'stem and stack are mutually exclusive',12,t
           #subr exit,rc=12
         endif
         if    (cli,stem_dl,ne,0),and,(cli,function,eq,c'G')
           RxStemPut name=wrk256,base=(stem,b.stem_dl),num=0,          c
               data==c'0'
         endif

* keyvar
         if    (cli,keyvar_dl,ne,0),and,(cli,key_dl,eq,0)
           RXvGet name=(keyvar,b.keyvar_dl),data=(key,l'key)
           if    (nz)           get failed
             strmake errmsg,'not found: ',(keyvar,b.keyvar_dl,,80),    c
               lr=r2
             st    r2,errmsgl
             setrc 12
             #subr exit,rc=8
           endif
           stc   r0,key_dl       save length
           mvi   keyvar_dl,0
         endif
*
         if    (pos,eq,zero),then=(mvc,pos,=A(1))
         if    (cli,trace,eq,c'Y'),then=(ICall,trace1)
         if    (cli,mask_dl,gt,0),or,(cli,text_dl,gt,0),               c
               or,(cli,textstem_dl,gt,0),or,(cli,maskstem_dl,gt,0)
           mvi   filter,c'Y'
         endif
*
         #subr exit,rc=0
         #subr drop

*---------------------------------------------------------------------*
*                    Epilog                                           *
*---------------------------------------------------------------------*
Epilog   #subr

*- close ACB
         if    (cli,dd,ne,c' '),and,(cli,openstat,eq,c'O')
           if    (cli,trace,eq,c'Y')
             xtrace 'close ACB1'
           endif
           j     acbclsm
acbclsd    close 0,mf=L,mode=31
acbclsm    mvc   wrk256(acbclsm-acbclsd),acbclsd
           la    r2,ACB1         just in case
           Close ((2)),mf=(E,wrk256),mode=31
           mvi   openstat,0
           if    (cli,trace,eq,c'Y')
             xtrace 'close ACB1 done'
           endif
         endif

         if     (cli,enq_dl,ne,0)     do enqueue
           la    r2,=cl8'RXVSAMBA'
           lb    r3,enq_dl
           la    r4,dd
           j     deqm
deqd       DEQ   (0,0,0,SYSTEMS),ret=HAVE,mf=L
deqm       mvc   wrk256(deqm-deqd),deqd
           DEQ   ((2),(4),(3),SYSTEMS),ret=HAVE,mf=(E,wrk256)
         endif
*-
* free dynamically allocated database
*-
         if    (cli,da,ne,c' ')
           clear alcbfr1
           strmake alcbfr1+2,'Free DD(',(dd,b.dd_dl),')',lenreg=r2
           sth   r2,alcbfr1
           if    (cli,trace,eq,c'Y')
             strmake tracerec,(alcbfr1,2,c2x),+1,(alcbfr1+2,40)
             xtrace ,
           endif
           la    r14,alcbfr1
           sr    r0,r0
           Link  EP=BPXWDYN,param=((r14)),VL=1,mf=(E,alcpl)
         endif
*
         if     (cli,stemupd,eq,c'Y')  stem.0
           StrP2d to=dw,from=stemnum
           RxStemPut name=wrk256,base=(stem,b.stem_dl),num=0,          c
               data=dw
         endif

         if     (cli,list_dl,ne,0)     stem.0
           StrP2d to=dw,from=listnum
           RxStemPut name=wrk256,base=(list,b.list_dl),num=0,          c
               data=dw
         endif

         if     (cli,pkeystem_dl,ne,0) keystem.0
           StrP2d to=dw,from=keynum
           RxStemPut name=wrk256,base=(pkeystem,b.pkeystem_dl),num=0,  c
               data=dw
         endif

         Macro
         VputDec &name=,&field=
         lclc  &s
         lcla  &l
&s       setc  Upper('&name')
&l       seta  k'&name
         la    r15,&field
         la    r0,=c'&s'
         la    r1,&l
         bal   r9,VputDec
         Mend

         VputDec name=RXVBREAD,field=reads
         VputDec name=RXVBINSE,field=inserts
         VputDec name=RXVBUPDT,field=updates
         ap    updates,inserts
         VputDec name=RXVBWRIT,field=updates
         VputDec name=RXVBDELE,field=deletes
         if    (rc,ne,zero),and,(cli,tracerec,ne,c' '),                c
               and,(cli,errmsg,eq,c' ')
           mvc   errmsg,tracerec
         endif
         RxVput name='RXVBDBTY',data=vsdbtype
         StrLen data=errmsg
         lr    r2,r15
         RxVput name='RXVBERRM',data=(errmsg,(r2))
*        RxVput name='RXVBVERS',data=(verinfo,l'verinfo)
         RxVput name='RXVBVERS',data=(verstxt,l'verstxt)
         strc2d from=(dbkeylen,4),to=(dw,8)
         RxVput name='RXVBKEYL',data=(dw,8)
         strc2d from=(dbkeypos,4),to=(dw,8)
         RxVput name='RXVBKEYP',data=(dw,8)
         strc2d from=(dbilrecl,4),to=(dw,8)
         RxVput name='RXVBRECL',data=(dw,8)

* drop stem copies
*        SlnkLst dropall,addr=f.txtlstad
         SlnkLst dropall,first=f.txtlstad
*        if    (icm,r2,15,txtlstad,nz)
*          l     r3,0(r2)                     size
*          STORAGE RELEASE,LENGTH=(3),ADDR=(2)
*        endif

*-
* set return value
*-
         if    (icm,r4,15,retval,nz)          specific retval
           l    r5,retval+4
         else
           strc2d from=rc,to=(dw,8)
           la    r4,dw
           la    r5,8
         endif
         RxRetval (r4),(r5)
         #subr exit,rc=0

*-
VputDec  ds    0a
         stm   r0,r1,wrk256
         unpk  dw,0(4,r15)
         oi    dw+7,x'f0'
         lm    r2,r3,wrk256
         RxVput name=((r2),(r3)),data=(dw,8)
         lm    r2,r3,wrk256+8                 restore
         br    r9
*-
         #subr drop
*
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
*  Global workarea                                                    *
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
$wrk     dsect
@@@sa    ds    (6*18)f
@@@saend equ   *
@@@salvl ds    pl2
blank    ds    cl120
sanum    ds    pl4
logr     ds    cl120
errmsgl  ds    a
errmsg   ds    cl120
acb1     ds    0a(0),xl(acb1ml)
rpl1     ds    0a(0),xl(rpl1ml)
acbopn   ds    0a(0),xl(acbopnml)
* do not change the order or size of DbKeyPos-DbReclen
DbKeypos ds    a
DbKeylen ds    a
Dbilrecl ds    a                     info - reclen
DbReclen ds    a
acb1stat ds    c
openstat ds    c
wrimode  ds    c
DbRecNum ds    a                     for RRDS
dw       ds    d
dw2      ds    d
fw       ds    f
fw2      ds    f
reason   ds    a
callparm ds    4a
stemupd  ds    c
listupd  ds    c
filter   ds    c
readtype ds    c
stacknum ds    a
stackcnt ds    a
pl4      equ   *
stemnum  ds    pl4
stemcnt  ds    pl4
keynum   ds    pl4
listnum  ds    pl4
reads    ds    pl4
updates  ds    pl4
inserts  ds    pl4
deletes  ds    pl4
pl4num   equ   (*-pl4)/4
textnum  ds    a
keycnt   ds    a
txtlstad ds    a
stemiorc ds    a
stemionl ds    a
stemida  ds    a
stemidl  ds    a
rc       ds    a
retval   ds    2a
vsbfr1a  ds    a
vsbfr1l  ds    a
vsbfr1dl ds    a
vsbfr2a  ds    a
vsbfr2l  ds    a
vsbfr2dl ds    a
vsdbtype ds    c
FDBAREA  DS    0F Feedback area for SHOWCB.
         DS    1x Reserved.
TYPECD   DS    1x Error type code.
CMPCD    DS    1x Component code.
ERRCD    DS    1x Reason code.
dupind   ds    1x

VsamRc   ds    a
vsamrs   ds    0a
VsamFdbk ds    a
fdbkcde  equ   *-1,1
fdbkeod  equ   4                       End of data set found
fdbkrnf  equ   16                      Record not found
fdbkild  equ   116                     Initial load
*-
         ds    0d
         StrParse area
         ds    0d
         RexxMacs ds
stemdl   equ   zrx_ShVbVbl,l'zrx_ShVbVbl
*
keypos   ds    a
keypos1  equ   keypos,l'keypos
keylen   ds    a
         ds    0d
wrk256   ds    xl256

tracerec ds    cl120
tracesa  ds    16a
tracesar15 equ *-4,4
*
*
rexxdata ds    0d
alcpl    ds    4a
alcbfr1  ds    cl120
alcbfr2  ds    cl120
         org   rexxdata
vsbfr1   ds    xl(32760)
vsbfr2   ds    xl(32760)
$wrkl    equ   *-$wrk

*---------------------------------------------------------------------*
*        Get next record from REXX list - stem or stack               *
*---------------------------------------------------------------------*

REXXGETL #subr xprolog=SubrProl,xepilog=SubrEpil
         if    (cli,stem_dl,eq,0),and,(cli,pstack,ne,c'Y')
           mvlit errmsg,'Data source missing'
           mvi   rc+3,20
           #subr exit,rc=8
         endif

*-
* handle data from stem
*-
         if    (cli,stem_dl,ne,0)
* if 1st time around get count from stem.0
           if    (cp,stemcnt,eq,=p'0')
             mvc   vsbfr1(8),blank
             RxStemGet name=wrk256,base=(stem,b.stem_dl),num=0,        c
               data=(vsbfr1,8)
             lr    r3,r0             data length
             trcblk
             StrMake logr,(stem,b.stem_dl),'0="',(vsbfr1,(r3)),'"'
             xtrace ,
             trcblke
* test datatype
             StrTest str=(vsbfr1,(r3)),test=num
             if    (nz)
               SetErr 'Stem.0 not numeric',8
               #subr exit,rc=8
             endif
*
             bctr  r3,0
             pack  stemcnt,vsbfr1(*-*)
             ex    r3,*-6
             if    (cp,stemcnt,eq,=p'0'),then=(#subrend,3) no data
           endif
* get stem data
           ap    stemnum,=p'1'
           if    (cp,stemnum,gt,stemcnt),then=(#subrend,3)
           if    (cli,trace,eq,c'Y'),then=(xtrace,'stemget')
           RxStemGet name=wrk256,base=(stem,b.stem_dl),pnum=stemnum,   c
               data=(vsbfr1,f.vsbfr1l)
           lr    r5,r15                   rc
           lr    r6,r0                    data length
           if    (ltr,r5,r5,z),and,(cli,trace,eq,c'Y')
             StrMake logr,'stemdata ',(r6,,cvdr,6),                    c
               +1,(vsbfr1,(r6),,80)
             xtrace ,
           endif
           lr    r0,r6                    data length
           #subr exit,rc=(r5)
         endif

*-
* handle data from stack
*-
         if    (cli,pstack,eq,c'Y')
* if 1st time around get count
           if    (stacknum,eq,zero)
             RxStack queued,data=stackcnt
             TrcBlk
             StrMake logr,'stackcnt ',(stackcnt,4,cvd,6)
             xtrace ,
             trcblke
             if    (stackcnt,eq,zero),then=(#subrend,8)
           endif
* get data
           l     r1,stacknum
           la    r1,1(,r1)
           st    r1,stacknum
           if    (c,r1,gt,stackcnt),then=(#subrend,3)
           if    (cli,trace,eq,c'Y'),then=(xtrace,'stackget')
           RxStack pull,data=(vsbfr1,f.vsbfr1l),lenreg=r6
           lr    r5,r15                       rc
           if    (ltr,r5,r5,z),and,(cli,trace,eq,c'Y')
             StrMake logr,'stackdata ',(r6,,cvdr,6),                   c
               +1,(vsbfr1,(r6),,80)
             xtrace ,
           endif
           lr    r0,r6                   copy data length
           #subr exit,rc=(r5)
         endif

         #subr exit,rc=0
         #subr drop

*---------------------------------------------------------------------*
*        Write record to REXX list - stem or stack                    *
*---------------------------------------------------------------------*

REXXPUTL #subr xprolog=SubrProl,xepilog=SubrEpil
*-
* handle maxout
*-
         if    (cli,maxout_dl,gt,0)
           if    (lt,r14,maxout,z)
             TrcBlk
             StrMake logr,'REXXPUTL maxout reached'
             xtrace ,
             trcblke
             #subr exit,rc=1           maxout reached
           endif
           bctr  r14,0
           st    r14,maxout
         endif
*-
* do some checks
*-
         if    (cli,stem_dl,eq,0),and,(cli,pstack,ne,c'Y')
           mvlit errmsg,'Data source missing'
           mvi   rc+3,20
           #subr exit,rc=8
         endif

*-
* handle data to stem
*-
         if    (cli,stem_dl,ne,0)
           ap    stemnum,=p'1'
           mvi   stemupd,c'Y'             remember update
           RxStemPut name=wrk256,base=(stem,b.stem_dl),pnum=stemnum,   c
               data=(vsbfr1,f.vsbfr1dl),namelenr=r3
           TrcBlk
           StrMake logr,'STEMPUT  ',(wrk256,(r3),,40),                 c
               '=',(vsbfr1,f.vsbfr1dl,,60)
           xtrace ,
           trcblke
           #subr exit,rc=(r15)
         endif

*-
* handle data to stack
*-
         if    (cli,pstack,eq,c'Y')
           l     r1,stacknum
           la    r1,1(,r1)
           st    r1,stacknum
           TrcBlk
           StrMake logr,'STACKPUT ',(vsbfr1,f.vsbfr1dl,,100)
           xtrace ,
           trcblke
           RxStack queue,data=(vsbfr1,f.vsbfr1dl)
           #subr exit,rc=(r15)
         endif

         #subr exit,rc=0
         #subr drop

*---------------------------------------------------------------------*
*        Write record to list stem                                    *
*---------------------------------------------------------------------*
LISTPUT  #subr xprolog=SubrProl,xepilog=SubrEpil
         if    (cli,list_dl,eq,0),then=(#subrend,0)
*
         ap    listnum,=p'1'
         mvi   listupd,c'Y'             remember update
         TrcBlk
         StrMake logr,'listput ',(listnum,4,cvd,6),                    c
               +1,(vsbfr1,f.vsbfr1dl,,80)
         xtrace ,
         trcblke
         RxStemPut name=wrk256,base=(list,b.list_dl),pnum=listnum,     c
               data=(vsbfr1,f.vsbfr1dl)
*
         #subr exit,rc=0
         #subr drop

*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
*                   VSAM                                              *
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*

*-
* open
*-
VsamOpen #subr xprolog=SubrProl,xepilog=SubrEpil
         if    (cli,openstat,eq,c'O')    already open?
           #subr exit,rc=0
         endif

         mvi   vsdbtype,c'K'             default is KSDS
         l     r2,vsbfr1a
         l     r3,vsbfr1l
         la    r4,acb1
         la    r14,rpl1
         ModCb rpl=(14),AREA=(2),arealen=(3),acb=(4),mf=(G,wrk256)
*
         StrMake logr,'VSMO open dd ',dd
         xtrace  ,
         mvc   acb1+40(8),dd      not nice
         la    r2,Acb1
         Open  ((2)),mf=(E,acbopn),mode=31
         st    r15,vsamrc
         lr    r5,r15
         StrMake logr,'VSMO open rc ',(r5,,cvdr,6)
         xtrace   ,
         Vsam  stat
         if    (ltr,r5,r5,z)
           la    r2,dbkeypos
           la    r4,acb1
           Showcb acb=(4),area=(2),                                    c
               length=16,fields=(RKP,KEYLEN,LRECL),                    c
               MF=(G,wrk256)
           mvi   acb1stat,c'O'
           mvi   openstat,c'O'
           if    (DbKeylen,eq,=a(0))
             mvi   vsdbtype,c'R'      set RRDS
           endif
           trcblk
           StrMake logr,'VSMO keyp ',(dbkeypos,4,cvd,4),               c
               ' keyl ',(dbkeylen,4,cvd,4),                            c
               ' recl ',(dbilrecl,4,cvd,6),                            c
               ' dbty ',vsdbtype
*            ' hex ',(dbkeypos,4,c2x),+1,(dbkeypos+4,4,c2x),         c
*            +1,(dbkeypos+8,4,c2x),lr=r2
           xtrace ,(r2)
           trcblke
         else
           mvi   acb1stat,c'F'        open failed
           mvi   openstat,c'F'        open failed
         endif

         #subr exit,rc=(r5)
         #subr drop

*-
* Get
*  returns code in r15:
*    00  all ok, data retrieved
*    01  mask/text check failed or short record
*    02  record not found / key check failed
*    03  end of file
*    >3  some error, refer to vsamrc / vsamfdbk
*-
VsamGet  #subr xprolog=SubrProl,xepilog=SubrEpil

         Get   rpl=rpl1
         lr    r5,r15
         st    r5,vsamrc
         mvi   acb1stat,c' '
         Vsam  stat
* if get rc > 0
         if    (ltr,r5,r5,nz)
           xtrace 'rc>0'
           if    (c,r5,eq,=a(8))
             if     (VsamFdbk,eq,=a(4))
               mvi   acb1stat,c'E'       set end-of-file
               xc    rc,rc               force rc 0
               #subr exit,rc=3
             elseif (VsamFdbk,eq,=a(16)),or,(VsamFdbk,eq,=a(116))
               mvi   acb1stat,c'N'       record not found
               xc    rc,rc               force rc 0
               #subr exit,rc=2           record not found
             endif
           endif
           #subr exit,rc=(r5)
         endif
* if get rc = 0
         Countup reads
         la    r2,DbReclen
         la    r4,rpl1
         ShowCb rpl=(4),area=(2),length=4,fields=RECLEN,               c
               MF=(G,wrk256)
*        handle recln<startpos
         if    (DbReclen,lt,pos)
           xtrace 'shortrec'
           #subr end,rc=1                same as filter fail
         endif
         mvc   vsbfr1dl,DbReclen
* check key
         if    (cli,vsdbtype,eq,c'K'),and,(cli,key_dl,ne,0) Indexd,KEY
           la    r2,vsbfr1
           a     r2,dbkeypos             -> key
           lb    r3,key_dl
           bctr  r3,0
*          j     *+10
*          clc   key(*-*),0(r2)
*          ex    r3,*-6
*          if    (ne),then=(#subrend,2) rc= key_check_failed
           if    (ex,r3,clc,key(*-*),0(r2),ne),then=(#subrend,2)
         endif
* text/mask search
         if    (cli,filter,eq,c'Y')
           la    r1,vsbfr1
           l     r0,vsbfr1dl
           icall FilterCk
           if    (nz),then=(#subrend,1)
         endif

         #subr exit,rc=0
         #subr drop

*-
* Put
*-
VsamPut  #subr xprolog=SubrProl,xepilog=SubrEpil
         Put   rpl=rpl1
         st    r15,vsamrc
         lr    r5,r15
         Vsam  stat
         if     (ltr,r5,r5,z)
           Countup updates
         endif
         #subr exit,rc=(r5)
         #subr drop

*-
* Insert
*-
VsamIns  #subr xprolog=SubrProl,xepilog=SubrEpil
         Put   rpl=rpl1
         st    r15,vsamrc
         lr    r5,r15
         Vsam  stat
         if     (ltr,r5,r5,z)
           Countup inserts
         endif
         #subr exit,rc=(r5)
         #subr drop

*-
* Delete
*-
VsamDel  #subr xprolog=SubrProl,xepilog=SubrEpil
         Erase rpl=rpl1
         st    r15,vsamrc
         lr    r5,r15
         Vsam  stat
         if     (ltr,r5,r5,z)
           Countup deletes
         endif
         #subr exit,rc=(r5)
         #subr drop

*-
* Status
*-
VsamStat #subr , xprolog=SubrProl,xepilog=SubrEpil
         xc    VsamFdbk,VsamFdbk
         if    (vsamrc,ne,zero),or,(cli,trace,eq,c'Y')
           la    r2,VsamFdbk
           la    r4,rpl1
           SHOWCB RPL=(4),AREA=(2),FIELDS=FDBK,LENGTH=4,mf=(G,wrk256)
           TrcBlk
           clear tracerec
           StrMake tracerec,'rc(',(VsamRc,4,cvxd),                     c
               ') fdbk(',(VsamFdbk,4,cvxd),')'
           trcblke
         endif
         TrcBlk
         clear logr
         StrMake logr,'VSAMSTAT ',(tracerec,28),(vsbfr1,f.vsbfr1l,,60)
         xtrace ,
         trcblke
         l     r5,vsamrc
         if    (=a(8),eq,VsamRc),and,(=a(8),eq,VSamFdbk),and,          c
               (cli,pigndup,eq,c'Y'),then=(sr,r5,r5) ignore duplicates
         #subr exit,rc=(r5)
         #subr drop

*---------------------------------------------------------------------*
*                                                                     *
*   GET skip-sequential subroutine                                    *
*   parms: KEY(value) | KEYVAR(name)  STEM(stembase) | STACK          *
*                                                                     *
*---------------------------------------------------------------------*
GETKEY   #subr xprolog=SubrProl,xepilog=SubrEpil

* open  db
         la    r14,acb1
         Modcb acb=(14),MACRF=(KEY,DIR,SEQ,IN),mf=(G,wrk256)
         mvi   readtype,c'K'           inital keyed access
         VSAM  Open,nz=exit
         if    (cli,vsdbtype,eq,c'R'),then=(j,GetKeyR)  RRDS?

* setup for KSDS
         la    r4,key
         lb    r5,key_dl
         if    (c,r5,gt,dbkeylen),then=(l,r5,dbkeylen)
         la    r14,rpl1
         ModCb rpl=(14),arg=(4),keylen=(5),mf=(G,wrk256),              c
               OPTCD=(KEY,DIR,SYN,NSP,KEQ,GEN,MVE)
*
         TrcBlk
         StrMake logr,'key ',(r5,,cvdr,4),' ',(key,(r5),,60)
         xtrace ,
         trcblke
*
* locate and read record with matching key prefix into vsbfr1,
* data length in vsbfr1dl.
         if    (cli,trace,eq,c'Y'),then=(xtrace,'GETK get first')
         VSAM  Get
         if    (clfi,r15,ge,2),then=#subrend eof
         if    (ltr,r15,r15,z)
           icall REXXPUTL
           if    (nz),then=(#subrend,(r15))
         endif

* if request keylen = dbkeylen then no next
         if    (c,r5,ge,DbKeylen),then=(#subrend,0)

* get rest
         la    r14,rpl1
         Modcb rpl=(14),optcd=SEQ,mf=(G,wrk256)
         mvi   readtype,c'S'           set sequrential
*
         l     r8,vsbfr1a
         a     r8,DbKeypos      key address
         l     r7,DbKeyLen      db key length
         bctr  r5,0             mch search key length

         xtrace 'GET seq hereafter'
         do    forever
           VSAM  Get   ,nz=leave
           if    (clfi,r15,ge,2),then=#subrend eof
           if    (ltr,r15,r15,z)
             icall REXXPUTL
             if    (nz),then=(#subrend,(r15))
           endif
         enddo  ,          do inf

         #subr exit,rc=8           shouldnt come here
*-
* RRDS
*-
GetKeyR  ds    0a
         xtrace 'GetKeyR'
* convert key to binary slotnum
         lb    r2,key_dl              key length
         bctr  r2,0
         j     *+10
         pack  dw,key(*-*)
         ex    r2,*-6
         cvb   r2,dw
         st    r2,dbRecNum
* setup for RRDS
         la    r14,rpl1
         la    r2,DbRecNum
         l     r3,vsbfr1a
         la    r3,8(,r3)
         l     r4,vsbfr1l
         Modcb rpl=(14),arg=(2),area=(3),arealen=(4),                  c
               OPTCD=(KEY,DIR,SYN,NUP,KEQ,GEN,MVE),mf=(G,wrk256)
         VSAM  Get
         if    (ltr,r15,r15,nz),then=(#subrend,8) error

         l     r1,vsbfr1dl
         la    r1,8(,r1)               add slot number
         st    r1,vsbfr1dl
         l     r1,dbrecnum
         $cvd  r1,vsbfr1,len=8
         StrLen data=(vsbfr1,f.vsbfr1dl)
         st    r15,vsbfr1dl
         ICall REXXPUTL
         if    (nz),then=(#subrend,(r15))

* do to
         if    (cli,keyto_dl,eq,0),then=(#subrend,0) just the one
         lb    r4,keyto_dl            key length
         bctr  r4,0
         j     *+10
         pack  dw,keyto(*-*)
         ex    r4,*-6
         cvb   r4,dw
         s     r4,dbrecnum
* get rest
         do over(r4)
           l     r1,dbrecnum
           la    r1,1(,r1)
           st    r1,dbrecnum
           VSAM  Get
           if    (cli,acb1stat,eq,c'N') not found is acceptable
             xtrace 'record not found'
             iterate
           endif
           if    (clfi,r15,ge,2),then=(#subrend,0) eof
           if    (ltr,r5,r15,z)        all ok?
             l     r1,vsbfr1dl
             la    r1,8(,r1)           add slot number
             st    r1,vsbfr1dl
             l     r1,dbrecnum
             $cvd  r1,vsbfr1,len=8
             StrLen data=(vsbfr1,f.vsbfr1dl)
             st    r15,vsbfr1dl
             ICall REXXPUTL
             if    (nz),then=leave
           endif
         enddo
*
         #subr exit,rc=0
         #subr drop

*---------------------------------------------------------------------*
*                                                                     *
*   GET data based on a keylist, write to stem or stack.              *
*   Parms: KEYSTEM(name) STEM(name) | STACK                           *
*                                                                     *
*---------------------------------------------------------------------*
GETKEYL  #subr xprolog=SubrProl,xepilog=SubrEpil

* get count from keystem.0
         RxStemGet name=wrk256,base=(pkeystem,b.pkeystem_dl),          c
               data=(vsbfr1,8),pnum=keynum
         lr    r3,r0
* test datatype
         StrTest str=(vsbfr1,(r3)),test=num
         if    (nz)
           SetErr 'Stem.0 not numeric',8
           #subr exit,rc=8
         endif
*
         bctr  r3,0
         j     *+10
         pack  dw,vsbfr1(*-*)
         ex    r3,*-6
         cvb   r9,dw
         mvc   keycnt,dw+4

         do    over(r9)
           ap    keynum,=p'1'
           RxStemGet name=wrk256,base=(pkeystem,b.pkeystem_dl),        c
               data=(key,b.key_fl),pnum=keynum
           stc   r0,key_dl
           TrcBlk
           lr    r4,r0
           StrMake logr,'keylst ',(r4,,cvdr,3),+1,(key,(r4),,80)
           xtrace ,
           trcblke
           ICall GetKey                read and copy
           if    (nz),then=(leave)
         enddo
*
         #subr exit,rc=0
         #subr drop

*---------------------------------------------------------------------*
*                                                                     *
*   GET for text or mask, scan entire db                              *
*   Syntax: GET ÝÝTEXT(value)¨ ÝMASK(value)¨ POS(p) ÝENDPOS=n¨¨       *
*               STEM(stembase) | STACK                                *
*           GET STEM(result) | STACK                                  *
*                                                                     *
*---------------------------------------------------------------------*
GETTXT   #subr xprolog=SubrProl,xepilog=SubrEpil
* open db
         mvi   readtype,c'S'           set sequrential
         la    r14,acb1
         Modcb acb=(14),MACRF=(KEY,SEQ,IN),mf=(G,wrk256)
         la    r14,rpl1
         Modcb rpl=(14),OPTCD=(KEY,SEQ,SYN,NUP,MVE),mf=(G,wrk256)
*
         VSAM  Open
         if    (nz),then=(#subrend,20)
         if    (cli,vsdbtype,eq,c'R'),then=(j,GetTxtR)  RRDS?
*
         do inf
           VSAM  Get
           if    (clfi,r15,ge,2),then=(#subrend,0) eof
           lr    r5,r15
           if    (ltr,r5,r5,z)         all ok?
             ICall REXXPUTL
             if    (nz),then=(leave)   some error / maxout reached
           endif
         enddo
*
         #subr exit,rc=0
*
GetTxtR  ds    0a
         xc    DbRecNum,DbRecNum       just in case
         la    r14,rpl1
         la    r2,DbRecNum
         l     r3,vsbfr1a
         la    r3,8(,r3)
         l     r4,vsbfr1l
         Modcb rpl=(14),arg=(2),area=(3),arealen=(4),mf=(G,wrk256)
*
         do inf
           VSAM  Get
           if    (clfi,r15,ge,2),then=(#subrend,0) eof
           if    (ltr,r5,r15,z)        get ok?
             l     r1,vsbfr1dl
             la    r1,8(,r1)           add slot number length (8)
             st    r1,vsbfr1dl
             l     r1,dbrecnum
             $cvd  r1,vsbfr1,len=8
             StrLen data=(vsbfr1,f.vsbfr1dl)
             st    r15,vsbfr1dl
             ICall REXXPUTL
             if    (nz),then=(leave)   some error / maxout reached
           endif
         enddo
*
         #subr exit,rc=0
         #subr drop

*---------------------------------------------------------------------*
*                                                                     *
*   DEL - delete by key prefix                                        *
*   parms: KEY(value) | KEYVAR(name) ÝLIST(name)¨                     *
*                                                                     *
*---------------------------------------------------------------------*
DELKEY   #subr xprolog=SubrProl,xepilog=SubrEpil
         if    (cli,trace,eq,c'Y')
           xtrace 'Delkey'
         endif
         if    (key_dl,eq,0)
           seterr 'KEY missing',12
           #subr exit,rc=20
         endif
*
         la    r14,acb1
         ModCb Acb=(14),MACRF=(KEY,DIR,SEQ,OUT),mf=(G,wrk256)
         la    r14,rpl1
         ModCb Rpl=(14),OPTCD=(KEY,DIR,SYN,UPD,KEQ,GEN,MVE),           c
               mf=(G,wrk256)
         VSAM  Open,nz=exit
*
* locate and read record with matching key prefix
         la    r4,key
         lb    r5,key_dl
         if    (c,r5,gt,dbkeylen),then=(l,r5,dbkeylen)
         la    r14,rpl1
         ModCb rpl=(14),arg=(4),keylen=(5),mf=(G,wrk256)
         VSAM  Get
         lr    r6,r15                  save rc
         if    (clfi,r15,ge,2),then=(#subrend,2) eof
         if    (ltr,r15,r15,z)         all ok
*          if list requested, then write to list
           if    (cli,list_dl,ne,0),then=(icall,ListPut)
*          if PULL then write stem or stack
           if    (=c'PULL',eq,function),then=(ICall,REXXPUTL)
         endif
* get rest
         la    r14,rpl1
         Modcb rpl=(14),optcd=SEQ,mf=(G,wrk256)
         l     r4,vsbfr1a
         a     r4,DbKeypos
         bctr  r5,0

         do    inf
           if    (ltr,r6,r6,z)
             VSAM  Del,nz=leave
           endif
*          if request keylen = dbkeylen then no next
           lb    r2,key_dl
           if    (c,r2,ge,DbKeylen),then=(#subrend,0)
           VSAM  Get
           lr    r6,r15                  save rc
           if    (clfi,r15,ge,2),then=leave
           if    (ltr,r15,r15,nz),then=iterate
*          if list requested, then write to list
           if    (cli,list_dl,ne,0),then=(icall,ListPut)
*          if PULL then write stem or stack
           if    (=c'PULL',eq,function),then=(ICall,REXXPUTL)
         enddo
*- if PULL then stem.0 is written at program exit

         #subr exit,rc=0
         #subr drop

*---------------------------------------------------------------------*
*                                                                     *
*   DELKEYL - delete by key values in stem                            *
*   Parms: KEYSTEM(name) ÝLIST(name)¨                                 *
*                                                                     *
*---------------------------------------------------------------------*
DELKEYL  #subr xprolog=SubrProl,xepilog=SubrEpil

* get count from keystem.0
         RxStemGet name=wrk256,base=(pkeystem,b.pkeystem_dl),          c
               data=(vsbfr1,8),pnum=keynum
         lr    r3,r0
* test datatype
         StrTest str=(vsbfr1,(r3)),test=num
         if    (nz)
           SetErr 'Stem.0 not numeric',8
           #subr exit,rc=8
         endif
*
         bctr  r3,0
         j     *+10
         pack  dw,vsbfr1(*-*)
         ex    r3,*-6
         cvb   r9,dw
         mvc   keycnt,dw+4

         do    over(r9)
           ap    keynum,=p'1'
           RxStemGet name=wrk256,base=(pkeystem,b.pkeystem_dl),        c
               data=(key,b.key_fl),pnum=keynum
           stc   r0,key_dl
           TrcBlk
           lr    r4,r0
           StrMake logr,'keylst ',(r4,,cvdr,3),+1,(key,(r4),,80)
           xtrace ,
           trcblke
           ICall DelKey                delete
         enddo
         #subr exit,rc=0
         #subr drop

*---------------------------------------------------------------------*
*                                                                     *
*   DELTXT  - delete by text or mask                                  *
*   Parms: TEXT(v) | MASK(v) POS(p) ÝENDPOS(ep)¨ ÝLIST(name)¨         *
*                                                                     *
*---------------------------------------------------------------------*
DELTXT   #subr xprolog=SubrProl,xepilog=SubrEpil
*
         la    r14,acb1
         Modcb acb=(14),MACRF=(KEY,SEQ,OUT),mf=(G,wrk256)
         la    r14,rpl1
         Modcb rpl=(14),OPTCD=(KEY,SEQ,SYN,UPD,MVE),mf=(G,wrk256)
         VSAM  Open,nz=exit

*
         Do    inf
           VSAM  Get
           if    (clfi,r15,ge,2),then=#subrend
           if    (ltr,r15,r15,nz),then=iterate
* if list requested then write it
           if    (cli,list_dl,ne,0),then=(icall,ListPut)
* if PULL then write stem or stack
           if    (=c'PULL',eq,function),then=(ICall,REXXPUTL)
* finally delete
           VSAM  Del,nz=leave
         Enddo

         #subr exit,rc=0
         #subr drop

*---------------------------------------------------------------------*
*                                                                     *
*   PUT - write data in stem or stack to database                     *
*   Parms: STEM(name) | STACK                                         *
*                                                                     *
*---------------------------------------------------------------------*
PUT      #subr xprolog=SubrProl,xepilog=SubrEpil

*- setup VSAM options, open
         la    r14,acb1
         modcb acb=(14),MACRF=(KEY,DIR,OUT),mf=(G,wrk256)
*
         la    r14,rpl1
         modcb rpl=(14),OPTCD=(KEY,DIR,SYN,UPD,KEQ,FKS,MVE),           c
               mf=(G,wrk256)
*
         Vsam  open
         if    (ltr,r15,r15,nz)
           StrMake errmsg,'Open rc ',(vsamrc,8,cvxd)
           mvi   rc+3,20
           #subr exit,rc=8
         endif

         do    forever

* get data to write
           ICall REXXGETL
           if    (ltr,r15,r15,nz)
             if    (clfi,r15,gt,4),then=(#subrend,(r15))
             mvc   rc,zero
             #subr exit,rc=0
           endif
           lr    r6,r0              data size

*read VSAM, determine INSERT or UPDATE
           if    (cli,wrimode,ne,c'L')  not initial load
             l     r4,vsbfr2a         -> data area
             l     r5,vsbfr2l         data length
             if    (cli,vsdbtype,eq,c'K') KSDS
               l     r2,vsbfr1a       -> key area
               a     r2,dbkeypos      key offset
               l     r3,dbkeylen      key length
             endif
             if    (cli,vsdbtype,eq,c'R') RRDS
               pack  dw,vsbfr1(8)     convert 8-byte key
               cvb   r2,dw             to
               st    r2,dbrecnum         binary recno
               la    r2,dbrecnum      record number
               la    r3,4             key length
             endif
             la    r14,rpl1
             modcb rpl=(14),arg=(2),keylen=(3),area=(4),arealen=(5),   c
               OPTCD=UPD,mf=(G,wrk256)

             VSAM  get
             if    (ltr,r5,r15,nz)
               if   (cli,acb1stat,ne,c'N') if not 'record not found'
                 clear errmsg
                 StrMake errmsg,'Get ',(tracerec,100)
                 mvi   rc+3,20
                 leave
               endif
               if    (cli,fdbkcde,eq,fdbkild)  initial load?
                 mvi   wrimode,c'L' remember
               endif
             endif
           endif

* update or insert
           if    (cli,vsdbtype,eq,c'K') KSDS
             xtrace 'put ksds'
             l     r2,vsbfr1a       -> key
             a     r2,dbkeypos        area
             l     r3,dbkeylen      key length
             la    r4,vsbfr1        -> data
           endif
           if    (cli,vsdbtype,eq,c'R') KSDS
             la    r2,dbrecnum      -> rec no
             la    r3,4
             ahi   r6,-8            adjust data size
             trcblk
             strmake logr,'put rrds # ',(dbrecnum,4,cvd,6),            c
               +1,(vsbfr1+8,(r6),,60),lenreg=r7
             xtrace   ,(r7)
             trcblke
* copy and pad
             la    r14,vsbfr1+8      -> source
             lr    r15,r6            source length
             la    r1,c' '           set
             sll   r1,24               pad
             ar    r15,r1                in source length
             l     r0,vsbfr2a        -> target
             l     r1,dbilrecl       target size
             mvcl  r0,r14
             l     r4,vsbfr2a        -> target
             l     r6,dbilrecl       target size
           endif
*
           if    (ltr,r5,r5,nz)     record don't exist, insert
             if   (cli,wrimode,eq,c'L')   initial load?
               xtrace 'first'
               la    r14,rpl1
               modcb rpl=(14),arg=(2),keylen=(3),area=(4),reclen=(6),  c
               OPTCD=(KEY,SEQ,SYN,NUP,MVE),mf=(G,wrk256)
             else
               xtrace 'insert'
               la    r14,rpl1
               modcb rpl=(14),arg=(2),keylen=(3),area=(4),reclen=(6),  c
               OPTCD=(KEY,DIR,SYN,NUP,KEQ,FKS,MVE),mf=(G,wrk256)
             endif
             VSAM ins
           else  ,                  record found, update
             xtrace 'update'
             la    r14,rpl1
             modcb rpl=(14),arg=(2),keylen=(3),area=(4),reclen=(6),    c
               OPTCD=UPD,mf=(G,wrk256)
             VSAM put
           endif
           if    (ltr,r15,r15,nz)
             st    r15,dw
             mvc   dw+4(4),vsamfdbk
             StrMake errmsg,'Put rc ',(dw,8,cvxd)
             mvi   rc+3,20
             leave
           endif

         enddo

         #subr exit,rc=0
         #subr drop

*---------------------------------------------------------------------*
*                                                                     *
*   PUT data in 'value' to databazse                                  *
*   Parms: VALUE(text)                                                *
*                                                                     *
*---------------------------------------------------------------------*
PUTVAL   #subr xprolog=SubrProl,xepilog=SubrEpil
*
         if    (cli,value_dl,eq,0)
           mvlit errmsg,'VALUE missing'
           mvi   rc+3,20
           #subr exit,rc=8
         endif
*
         la    r14,acb1
         modcb acb=(14),MACRF=(KEY,DIR,OUT),mf=(G,wrk256)
         la    r14,rpl1
         modcb rpl=(14),OPTCD=(KEY,DIR,SYN,UPD,KEQ,FKS,MVE),           c
               mf=(G,wrk256)
*
         Vsam  open
         if    (ltr,r15,r15,nz)
           StrMake errmsg,'Open rc ',(vsamrc,8,cvxd)
           mvi   rc+3,20
           #subr exit,rc=8
         endif
*
* read using key
         if    (cli,vsdbtype,eq,c'R') RRDS
           pack  dw,value(8)      convert 8-byte key
           cvb   r2,dw             to
           st    r2,dbrecnum         binary recno
           la    r2,dbrecnum      record number
           la    r3,4             key length
         else
           la    r2,value         -> key area
           a     r2,dbkeypos      key offset
           l     r3,dbkeylen      key length
         endif
         l     r4,vsbfr2a         -> data output area
         l     r5,vsbfr2l         output area length
         la    r14,rpl1
         modcb rpl=(14),arg=(2),keylen=(3),area=(4),arealen=(5),       c
               OPTCD=UPD,mf=(G,wrk256)
*
         VSAM  get
         if    (ltr,r5,r15,nz)
           if   (cli,acb1stat,ne,c'N') if not 'record not found'
             clear errmsg
             StrMake errmsg,'Get ',(tracerec,100)
             mvi   rc+3,20
             #subr exit,rc=8
           endif
         endif
*
* update or insert
         if    (cli,vsdbtype,eq,c'R') KSDS
           la    r2,dbrecnum      -> rec no
           la    r3,4
           lb    r4,value_dl
           ahi   r4,-8            adjust data size
           trcblk
           strmake logr,'put rrds # ',(dbrecnum,4,cvd,6),              c
               +1,(value+8,(r4),,60),lenreg=r7
           xtrace   ,(r7)
           trcblke
* copy and pad
           la    r14,value+8       -> source
           lr    r15,r4            adjusted source length
           la    r1,c' '           set
           sll   r1,24               pad
           ar    r15,r1                in source length
           l     r0,vsbfr2a        -> target
           l     r1,dbilrecl       target size
           mvcl  r0,r14
           l     r5,vsbfr2a        -> target
           l     r4,dbilrecl       target size
         else
           la    r2,value           -> key area
           a     r2,dbkeypos        key offset
           l     r3,dbkeylen        key length
           lb    r4,value_dl
           la    r5,value           -> data area
         endif
         la    r14,rpl1
*        if    (ltr,r5,r5,nz)       record don't exist, insert
         if    (cli,acb1stat,eq,c'N') record not found, insert
           modcb rpl=(14),arg=(2),keylen=(3),area=(5),reclen=(4),      c
               OPTCD=NUP,mf=(G,wrk256)
           VSAM ins
           la    r6,=c'INS '
         else  ,                     record found, update
           modcb rpl=(14),arg=(2),keylen=(3),area=(5),reclen=(4),      c
               OPTCD=UPD,mf=(G,wrk256)
           VSAM put
           la    r6,=c'UPD '
         endif
         if    (ltr,r15,r15,nz)
           st    r15,dw
           mvc   dw+4(4),vsamfdbk
           StrMake errmsg,((r6),4),'rc ',(dw,8,cvxd)
           mvi   rc+3,20
           #subr exit,rc=8
         endif

         #subr exit,rc=0
         #subr drop

*---------------------------------------------------------------------*
*                                                                     *
*   INSERT data in stem to database. Like PUT above execpt no         *
*          GET is attempted and we don't care about the key           *
*          position nor length.                                       *
*   parms: STEM(s)                                                    *
*                                                                     *
*---------------------------------------------------------------------*
INSERT   #subr xprolog=SubrProl,xepilog=SubrEpil
         if    (cli,trace,eq,c'Y')
           xtrace 'insert'
         endif
*
         la    r14,acb1
         modcb acb=(14),MACRF=(KEY,DIR,OUT),mf=(G,wrk256)
         la    r14,rpl1
         modcb rpl=(14),OPTCD=(KEY,DIR,SYN,NUP,MVE),mf=(G,wrk256)
         VSAM  Open

* Insert into a RRDS = PUT
         if    (cli,vsdbtype,eq,c'R') RRDS
           ICall  Put
           #subrend rc=(r15)
         endif

* Process list
         do    forever
* get data from REXX
           ICall REXXGETL
           if    (ltr,r15,r15,nz)
             if    (clfi,r15,lt,4),then=(sr,r15,r15)  just EOF
             leave
           endif
           lr    r6,r0                     data length
* write data to db
           la    r14,rpl1
           modcb rpl=(14),reclen=(6),mf=(G,wrk256)
           VSAM  Ins,nz=leave
         enddo
         st    r15,rc

         #subr exit,rc=(r15)
         #subr drop

*---------------------------------------------------------------------*
*                                                                     *
*   Copy data from stem to internal buffer                            *
*                                                                     *
*   At entry                                                          *
*     r0  -> list anchor point                                        *
*     r1  -> al1(l'stemname),c'stemname'                              *
*                                                                     *
*   At exit                                                           *
*     r15  rc  0=ok, else not ok                                      *
*                                                                     *
*---------------------------------------------------------------------*
StmCpyMk #subr xprolog=SubrProl,xepilog=SubrEpil
         lr    r8,r0              -> list anchor
         lr    r9,r1              -> list name
* copy stemname
         sr    r2,r2
         ic    r2,0(,r9)
         j     *+10
         mvc   wrk256(*-*),0(r9)  length plus name
         ex    r2,*-6

* get count from stem.0
         clear vsbfr1,l=200
         RxStemGet name=wrk256+140,base=(wrk256+1,b.wrk256),           c
               data=(vsbfr1,8),pnum=keynum
         lr    r3,r0              datalength
* test datatype
         StrTest str=(vsbfr1,(r3)),test=num
         if    (nz)
           SetErr 'Stem.0 not numeric',8
           #subr exit,rc=8
         endif
*
         bctr  r3,0
         j     *+10               around pack
         pack  dw,vsbfr1(*-*)
         ex    r3,*-6
         cvb   r7,dw              r7=count

* get filter list
         do    over(r7)
           ap    keynum,=p'1'
           RxStemGet name=wrk256+140,base=(wrk256+1,b.wrk256),         c
               data=(vsbfr1,f.vsbfr1l),pnum=keynum
           if    (ltr,r15,r15,nz),then=iterate
           lr    r3,r0            copy length
           SlnkLst add,size=(r3),addr=(r8),data=(vsbfr1,(r3))
           lr    r8,r1            copy new address
         enddo

         #subr exit,rc=0
         #subr drop

*---------------------------------------------------------------------*
*                                                                     *
*   SHOW vsam specs                                                   *
*   key length- and offset are set by VSAM open                       *
*                                                                     *
*---------------------------------------------------------------------*
INFO     #subr xprolog=SubrProl,xepilog=SubrEpil
         if    (DbKeylen,ne,zero)       already set??
           #subr exit,rc=0
         endif
*
         if    (cli,trace,eq,c'Y')
           xtrace 'modacb'
         endif
         la    r3,acb1
         modcb acb=(3),MACRF=(KEY,DIR,SEQ,OUT),mf=(G,wrk256)
*
 ago .b
         if    (cli,trace,eq,c'Y')
           xtrace 'modrpl'
         endif
         la    r4,rpl1
         la    r3,acb1
         modcb rpl=(4),acb=(3),OPTCD=(KEY,DIR,SYN,NUP,MVE),            c
               mf=(G,wrk256)
*
.b anop
         if    (cli,trace,eq,c'Y')
           xtrace 'open'
         endif
         VSAM  Open
*
         #subr exit,rc=0
         #subr drop

*-------------------------------------------------------------------- *
*-------------------------------------------------------------------- *
* Filter - check string for text/textstem, mask/maskstem              *
*                                                                     *
*  at entry                                                           *
*    r0 =  string length                                              *
*    r1 -> string                                                     *
*                                                                     *
*  at exit                                                            *
*    r15 = 0 => ok                                                    *
*    r15 > 0 => not ok                                                *
*-------------------------------------------------------------------- *
*-------------------------------------------------------------------- *
FilterCk #subr xprolog=SubrProl,xepilog=SubrEpil
         lr    r8,r1                  -> string
         lr    r9,r0                  length of string

* by word, r1 -> word, r0 = word length, both are zero if not found
         if    (cli,word_dl,ne,0)
           STRWORD  STR=((r8),(r9)),NUM=f.word,DLM=dlm
           if    (ltr,r1,r1,z),then=(#subrend,8) word not found
           lr    r8,r1                set new string pos
           lr    r9,r0                set new string length
         endif

* setup for optional start and length or end-dlm of string
         if    (cli,pos_dl,ne,0)      pos defined
           if    (c,r9,lt,pos),then=(#subrend,4) short record
           a     r8,pos               adjust
           bctr  r8,0                  address
           if    (cli,dlm_dl,ne,0)    end-dlm defined
*            Returns position in r1, r1=0 if not found
             STRLOCCH STR=((r8),(r9)),rchr=(dlm)
             if    (ltr,r1,r1,z),then=(#subrend,8) dlm not found
             lr    r9,r1
             sr    r9,r8              compute new length
           else
             if    (endpos,ne,zero),and,(c,r9,gt,endpos)
               l     r9,endpos          adjust length
             endif
             s     r9,pos               minus start
             la    r9,1(,r9)
           endif
         endif
* r8 -> string, r9 = length

* test for text
         sr    r3,r3
         if    (icm,r3,1,text_dl,nz)         text search
           trcblk
           strmake logr,'test for text "',(text,(r3),,40),             c
               '" in "',((r8),(r9),,60),'"',lr=r2
           xtrace ,(r2)
           trcblke
           StrPos arg=(text,(r3)),str=((r8),(r9))
           if    (ltr,r1,r1,nz),then=(#subrend,0) match
           #subr exit,rc=8                   no match
         endif

* test for mask in stem
         if    (cli,maskstem_dl,ne,0)        mask stem search
           llc   r3,textstem_dl              using the text stem
           xtrace 'mask stem test'
           if    (icm,r6,15,txtlstad,z),then=(#subrend,9) no list
           do    forever
             l     r3,4(,r6)                 length
             ahi   r3,-slnklstpfxl           data length
             StrPatrn data=((r8),(r9)),mask=(slnklstdatao(r6),(r3))
             if    (ltr,r15,r15,z),then=(#subrend,0) match
             SlnkLst next,addr=(r6)
             if    (ltr,r6,r1,z),then=(#subrend,8)
           enddo
           #subr end,rc=1                    not found
         endif

* test for text in stem
         if    (icm,r3,1,textstem_dl,nz)     text search
           xtrace 'text stem test'
           if    (icm,r6,15,txtlstad,z),then=(#subrend,9) no list
           do    forever
             l     r3,4(,r6)                 length
             ahi   r3,-slnklstpfxl           data length
             StrPos arg=(slnklstdatao(r6),(r3)),str=((r8),(r9))
             if    (ltr,r1,r1,nz),then=(#subrend,0) match
             SlnkLst next,addr=(r6)
             if    (ltr,r6,r1,z),then=(#subrend,8)
           enddo
         endif

* test for mask
         if    (cli,mask_dl,ne,0)            mask search
           if   (cli,strip_dl,ne,0)          strip text
             clear wrk256
             STRSTRIP ((r8),(r9)),b,strip,to=wrk256,lr=r9
             la    r8,wrk256
           endif
           trcblk
           strmake logr,'test for mask "',(mask,b.mask_dl,,30),        c
               '" in "',((r8),(r9),,50),'"',lr=r2
           xtrace ,(r2)
           trcblke
           StrPatrn data=((r8),(r9)),mask=(mask,b.mask_dl)
           lr    r5,r15
           st    r5,fw
           strmake logr,'rc=x',(fw+2,2,c2x),+1,(r5,,cvdr,4),lr=r2
           xtrace ,(r2)
           #subr end,rc=(r5)
         endif
*
         #subr exit,rc=8
         #subr drop

* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
* Subroutine prolog / epilog  - do tracing                            *
* r10 -> global storage                                               *
* ------------------------------------------------------------------- *
* ------------------------------------------------------------------- *
SubrProl #subr base=r6
         ap    sanum,=p'1'
         if    (zrx_ExComA,eq,zero),then=(#subrend,0)   no REXX
*
         TrcBlk
         l     r3,4(,r13)              reload callers
         l     r3,64(,r3)                basereg (r11)
         strmake logr,(14(,r3),8),' ',(sanum,4,p2d,2),' entry',        c
               lenreg=r2
         xtrace   ,(r2)
         l     r1,4(,r13)              reload callers
         lm    r0,r1,20(r1)              r0+r1
         trcblke
*
         #subr exit,rc=0
         #subr drop
*--
* r2 = #subr end rc
SubrEpil #subr base=r6
         if    (zrx_ExComA,eq,zero),then=(#subrend,(r2))  no REXX
         lr    r5,r2                   copy rc
*
         TrcBlk
         l     r3,4(,r13)              reload callers
         l     r3,64(,r3)                basereg
         strmake logr,(14(,r3),8),' ',(sanum,4,p2d,2),                 c
               ' exit rc ',(r5,,cvdr,8),lenreg=r2
         xtrace   ,(r2)
         l     r1,4(,r13)              reload callers
         lm    r0,r1,20(r1)              r0+r1
         trcblke
*
         sp    sanum,=p'1'
         #subr exit,rc=(r5)            r5 = original r15
         #subr drop

*---------------------------------------------------------------------*
*                                                                     *
*          end of program                                             *
*                                                                     *
*---------------------------------------------------------------------*

         RexxMacs dsect
         End
//*
//* Production version is in LPALIB
//*
//* activate dynamic:
//*   (old) SETPROG LPA,ADD,MODNAME=RXVSAMBA,DSNAME=CBT669.LINKLIB
//*   Copy to CBT669.LINKLIB, then do F LLA,REFRESH
//*
//L.SYSLMOD DD DSN=CBT669.LINKLIB(RXVSAMBA),DISP=SHR
//*.SYSLMOD DD DSN=&YOUR.LINKLIB(RXVSAMBA)
//*
//IVP1     EXEC PGM=IKJEFT1B,PARM='RXVB&IVP'  DELA(N)'
//STEPLIB  DD DISP=SHR,DSN=CBT669.LINKLIB
//SYSEXEC  DD DISP=SHR,DSN=CBT669.PP.RXVSAMBA.LIB
//SYSTSPRT DD SYSOUT=*,OUTLIM=10000
//SYSTSIN  DD DUMMY
